/*
 * src/log/logger.h - Legacy Compatibility Header
 * 
 * Diese Datei leitet nur noch auf das neue Debug-System weiter
 */

#ifndef LOGGER_H
#define LOGGER_H

/* Das neue Debug-System verwenden */
#include "../debug/debug_system.h"

/* Alle benĆ¶tigten Definitionen sind jetzt in debug_system.h */

#endif /* LOGGER_H */
/*
 * src/ssl/ssl_config.h - SSL Configuration with DOS Client Support
 */

#ifndef _SSL_CONFIG_H_
#define _SSL_CONFIG_H_

#include <arpa/inet.h>
#include <openssl/pem.h>
#include <openssl/ssl.h>
#include <openssl/opensslv.h>

/* OpenSSL version compatibility */
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
#define OPENSSL_API_1_1 1
#else
#define OPENSSL_API_1_1 0
#endif

#define SSLGATE_SSL_SESS_CACHE_SIZE 128*20
#define SSLGATE_SSL_SESS_TIMEOUT 30 /* seconds - HTTPS Session LĆ¤nge fĆ¼r AdBlock optimiert */
#define SSLGATE_TLS_EARLYDATA_SIZE 16384

/* DOS Client specific settings */
#define SSLGATE_DOS_SESS_CACHE_SIZE 10
#define SSLGATE_DOS_SESS_TIMEOUT 300    /* 5 minutes for slow DOS clients */
#define SSLGATE_DOS_BUFFER_SIZE 1024    /* Smaller buffers for DOS clients */
#define SSLGATE_DOS_MAX_CERT_SIZE 2048  /* Smaller certificates for DOS */

#ifndef DEFAULT_PEM_PATH
#define DEFAULT_PEM_PATH "/opt/var/cache/SSLGateNX"
#endif

#define SSLGATENX_MAX_PATH 1024
#define SSLGATENX_MAX_SERVER_NAME 255

extern char ssl_gate_pipe[SSLGATENX_MAX_PATH];

/* Modern cipher list for regular clients */
#define SSLGATENX_CIPHER_LIST \
  "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:" \
  "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:" \
  "ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:" \
  "ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:" \
  "DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256:" \
  "DHE-RSA-AES128-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA"

/* DOS-compatible cipher list with legacy support */
#define SSLGATENX_CIPHER_LIST_DOS \
  "RC4-MD5:RC4-SHA:DES-CBC3-SHA:DES-CBC-SHA:" \
  "AES128-SHA:AES256-SHA:AES128-SHA256:" \
  "DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:" \
  "EDH-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC-SHA:" \
  SSLGATENX_CIPHER_LIST

/* SSLv2 compatible cipher list (very legacy) */
#define SSLGATENX_CIPHER_LIST_SSLv2 \
  "RC4-MD5:RC2-CBC-MD5:DES-CBC-MD5:DES-CBC3-MD5:" \
  "RC4-64-MD5:NULL-MD5"

#define SSLGATENXV1_3_CIPHERS \
  "TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256"

/* DOS Client information structure */
typedef struct {
    int is_dos_client;
    int use_small_buffers;
    int legacy_ssl_mode;
    time_t connect_time;
    int ssl_version_detected;
    char user_agent[256];
} dos_client_info_t;

/* Certificate storage structure */
typedef struct {
    const char* pem_dir;
    STACK_OF(X509_INFO) *cachain;
    X509_NAME *issuer;
    EVP_PKEY *privkey;
} cert_tlstor_t;

/* SSL status enumeration */
typedef enum {
    SSL_NOT_TLS,
    SSL_ERR,
    SSL_MISS,
    SSL_HIT,
    SSL_HIT_CLS,
    SSL_HIT_RTT0,
    SSL_UNKNOWN,
    SSL_DOS_LEGACY,    /* New: DOS client with legacy SSL */
    SSL_DOS_DOWNGRADE  /* New: Downgraded connection for DOS */
} ssl_enum;

/* TLS extension callback argument structure */
typedef struct {
    const char *tls_pem;
    const STACK_OF(X509_INFO) *cachain;
    char servername[65]; /* max legal domain name 63 chars; INET6_ADDRSTRLEN 46 bytes */
    char server_ip[INET6_ADDRSTRLEN];
    ssl_enum status;
    int sslctx_idx;
    dos_client_info_t *dos_info;  /* New: DOS client information */
} tlsext_cb_arg_struct;

/* Connection TLS storage structure */
typedef struct {
    int new_fd;
    SSL *ssl;
    double init_time;
    tlsext_cb_arg_struct *tlsext_cb_arg;
    int allow_admin;
    char *early_data;
    tlsext_cb_arg_struct v;
    dos_client_info_t dos_client_info;  /* New: DOS client info */
    char *small_buffer;                 /* New: Small buffer for DOS clients */
    size_t buffer_size;                 /* New: Actual buffer size used */
} conn_tlstor_struct;

/* SSL context cache structure - optimized with atomic operations */
typedef struct {
    int alloc_len;
    char *cert_name;
    unsigned int last_use; /* seconds since process up - made atomic in implementation */
    int reuse_count;       /* made atomic in implementation */
    SSL_CTX *sslctx;
    SSL_CTX *dos_sslctx;   /* New: DOS-compatible SSL context */
    pthread_mutex_t lock;  /* Keep individual locks for SSL_CTX operations */
    int is_dos_compatible; /* New: Flag for DOS compatibility */
} sslctx_cache_struct;

/* Global SSL context */
extern SSL_CTX *g_sslctx;
extern SSL_CTX *g_dos_sslctx;  /* New: Global DOS-compatible SSL context */

/* External variables from util.h/main */
extern char ssl_gate_pipe[SSLGATENX_MAX_PATH];
extern volatile sig_atomic_t kcc;

/* DOS Client detection and handling */
int detect_dos_client_by_handshake(SSL *ssl, const unsigned char *data, size_t len);
int configure_dos_ssl_context(SSL_CTX *ctx, dos_client_info_t *dos_info);
SSL_CTX* create_dos_compatible_sslctx(const char *pem_dir);
int is_legacy_cipher_request(const unsigned char *client_hello, size_t len);

/* Enhanced SSL context creation with DOS support */
SSL_CTX *create_default_sslctx_with_dos_support(const char *pem_dir);
SSL_CTX *create_child_sslctx_with_dos_support(const char* full_pem_path, 
                                              const STACK_OF(X509_INFO) *cachain,
                                              dos_client_info_t *dos_info);

/* Buffer management for DOS clients */
char* allocate_dos_buffer(size_t *size);
void free_dos_buffer(char *buffer);
int resize_buffer_for_dos_client(conn_tlstor_struct *conn);

/* Function from util.h */
unsigned int process_uptime(void);
double elapsed_time_msec(const struct timespec start_time);
void get_time(struct timespec *tm);

#define CONN_TLSTOR(p, e) ((conn_tlstor_struct*)p)->e

/* Function declarations */
void ssl_init_locks(void);
void ssl_free_locks(void);
void cert_tlstor_init(const char *pem_dir, cert_tlstor_t *c);
void cert_tlstor_cleanup(cert_tlstor_t *c);
void *cert_generator(void *ptr);

/* SSL context table management */
void sslctx_tbl_init(int tbl_size);
void sslctx_tbl_cleanup(void);
void sslctx_tbl_load(const char* pem_dir, const STACK_OF(X509_INFO) *cachain);
void sslctx_tbl_save(const char* pem_dir);
void sslctx_tbl_lock(int idx);
void sslctx_tbl_unlock(int idx);

/* Statistics functions - now with atomic operations */
int sslctx_tbl_get_cnt_total(void);
int sslctx_tbl_get_cnt_hit(void);
int sslctx_tbl_get_cnt_miss(void);
int sslctx_tbl_get_cnt_purge(void);
int sslctx_tbl_get_sess_cnt(void);
int sslctx_tbl_get_sess_hit(void);
int sslctx_tbl_get_sess_miss(void);
int sslctx_tbl_get_sess_purge(void);

/* DOS-specific statistics */
extern volatile sig_atomic_t dos_client_count;
extern volatile sig_atomic_t dos_ssl_downgrades;
extern volatile sig_atomic_t dos_legacy_handshakes;

/* SSL context creation and management */
SSL_CTX *create_default_sslctx(const char *pem_dir);
SSL_CTX *create_child_sslctx(const char* full_pem_path, const STACK_OF(X509_INFO) *cachain);
int is_ssl_conn(int fd, char *srv_ip, int srv_ip_len, const int *ssl_ports, int num_ssl_ports);

/* Connection storage management - enhanced for DOS clients */
void conn_stor_init(int slots);
void conn_stor_relinq(conn_tlstor_struct *p);
conn_tlstor_struct* conn_stor_acquire(void);
void conn_stor_flush(void);

/* TLS 1.3 specific functions */
#ifdef TLS1_3_VERSION
int tls_clienthello_cb(SSL *ssl, int *ad, void *arg);
char* read_tls_early_data(SSL *ssl, int *err);
#endif

/* Legacy SSL support for DOS clients */
#ifndef OPENSSL_NO_SSL2
int ssl2_clienthello_cb(SSL *ssl, int *ad, void *arg);
#endif

/* Benchmark function */
void run_benchmark(const cert_tlstor_t *ct, const char *cert);

/* Internal SSL context table functions */
int sslctx_tbl_lookup(const char* cert_name, int* found_idx, int* ins_idx);
int sslctx_tbl_cache(const char *cert_name, SSL_CTX *sslctx, int ins_idx);
int sslctx_tbl_cache_dos_context(const char *cert_name, SSL_CTX *sslctx, SSL_CTX *dos_sslctx, int ins_idx);
int sslctx_tbl_purge(int idx);
int sslctx_tbl_check_and_flush(void);

/* Debug function */
#ifdef DEBUG
void sslctx_tbl_dump(int idx, const char *func);
#endif

/* Certificate generation functions */
void generate_cert(const char *cert_name,
                   const char *pem_dir,
                   X509_NAME *issuer,
                   EVP_PKEY *privkey,
                   const STACK_OF(X509_INFO) *cachain);

void generate_dos_compatible_cert(const char *cert_name,
                                  const char *pem_dir,
                                  X509_NAME *issuer,
                                  EVP_PKEY *privkey,
                                  const STACK_OF(X509_INFO) *cachain);

void generate_universal_ip_cert(const char *pem_dir,
                               X509_NAME *issuer,
                               EVP_PKEY *privkey,
                               const STACK_OF(X509_INFO) *cachain);

/* Worker thread functions */
void *cert_worker(void *arg);
void shutdown_cert_workers(void);
void enqueue_cert_job(const char *cert_name);

/* Utility functions */
int is_ip_address(const char *addr);
int pem_passwd_cb(char *buf, int size, int rwflag, void *u);

/* Additional utility functions */
SSL_CTX* sslctx_tbl_get_ctx(const char *cert_name);
SSL_CTX* sslctx_tbl_get_dos_ctx(const char *cert_name);
int validate_certificate_chain(SSL_CTX *ctx);
int check_cert_expiration(const char *cert_path, time_t *expires_at);
void log_ssl_errors(const char *operation);
void sslctx_tbl_cleanup_expired(void);
size_t sslctx_tbl_memory_usage(void);
void pregenerate_common_certs(cert_tlstor_t *ct);
void print_cert_statistics(void);
void print_dos_statistics(void);

/* High-performance connection management */
int create_listening_socket(const char *ip_addr, const char *port, int use_ip);
void configure_socket_for_high_load(int sockfd);
void optimize_ssl_for_dos_client(SSL *ssl, dos_client_info_t *dos_info);

#endif /* _SSL_CONFIG_H_ */
/*
 * src/ssl/ssl_modules.h - SSL Context Management and TLS Callbacks
 */

#ifndef _SSL_MODULES_H_
#define _SSL_MODULES_H_

#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509v3.h>
#include <openssl/opensslv.h>
#include "../ssl/ssl_config.h"

/* Job Queue for parallel certificate generation */
typedef struct cert_job {
    char cert_name[SSLGATENX_MAX_SERVER_NAME+1];
    struct cert_job *next;
} cert_job_t;

/* Internal macros */
#define SSLCTX_TBL_ptr(h)         ((sslctx_cache_struct *)(sslctx_tbl + h))
#define SSLCTX_TBL_get(h, k)      SSLCTX_TBL_ptr(h)->k
#define SSLCTX_TBL_set(h, k, v)   SSLCTX_TBL_ptr(h)->k = v

/* External variables */
extern sslctx_cache_struct *sslctx_tbl;
extern cert_job_t *cert_q_head, *cert_q_tail;
extern pthread_mutex_t cert_q_lock;
extern pthread_cond_t cert_q_cond;
extern volatile int cert_workers_shutdown;

/* Certificate generation functions - no longer static */
void generate_cert(const char *cert_name,
                   const char *pem_dir,
                   X509_NAME *issuer,
                   EVP_PKEY *privkey,
                   const STACK_OF(X509_INFO) *cachain);

void generate_universal_ip_cert(const char *pem_dir,
                               X509_NAME *issuer,
                               EVP_PKEY *privkey,
                               const STACK_OF(X509_INFO) *cachain);

/* IP detection functions */
int is_ip_address(const char *addr);

/* Worker thread functions */
void *cert_worker(void *arg);
void shutdown_cert_workers(void);
void enqueue_cert_job(const char *cert_name);

/* Password callback */
int pem_passwd_cb(char *buf, int size, int rwflag, void *u);

#endif /* _SSL_MODULES_H_ */
/*
 * src/http/http_responses.h - HTTP Response Templates Header
*/

#ifndef HTTP_RESPONSES_H
#define HTTP_RESPONSES_H

/* HTTP Response Templates */
extern const char httpcors_headers[];
extern const char httpnulltext[];
extern const char http204[];
extern const char httpstats1[];
extern const char httpstats2[];
extern const char httpstats3[];
extern const char httpstats4[];
extern const unsigned int statsbaselen;
extern const char txtstats1[];
extern const char txtstats2[];
extern const char txtstats3[];
extern const char httpredirect[];
extern const char httpnullpixel[];
extern const char http501[];
extern const char httpnull_png[];
extern const char httpnull_jpg[];
extern const char httpnull_swf[];
extern const char httpnull_ico[];

/* ASP/Server-side Script Responses */
extern const char httpnull_asp[];
extern const char httpnull_aspx[];
extern const char httpnull_ashx[];
extern const char httpnull_php[];
extern const char httpnull_jsp[];
extern const char httpnull_js[];

/* HTTP Options Response */
extern const char httpoptions[];

/* CA Certificate Response */
extern const char httpcacert[];
extern const char httpcacert2[];

/* Response Lengths - fĆ¼r sizeof() Ersatz */
extern const int http501_len;

#endif /* HTTP_RESPONSES_H */
/*
 * src/http/http_utils.h - HTTP Utility Functions Header
*/

#ifndef HTTP_UTILS_H
#define HTTP_UTILS_H

#include <netinet/in.h>

/* String utilities */
char* strstr_last(const char* const str1, const char* const str2);
char* strstr_first(const char* const str1, const char* const str2);
char from_hex(const char ch);
void urldecode(char* const decoded, char* const encoded);

/* Network utilities */
void get_client_ip(int socket_fd, char *ip, int ip_len, char *port, int port_len);

/* Debug utilities - nur bei DEBUG aktiv */
#ifdef HEX_DUMP
void hex_dump(void *data, int size);
#endif

#ifdef DEBUG
void child_signal_handler(int sig);
#endif

#endif /* HTTP_UTILS_H */
/* 
favicon.h

Note and create favicon.h:
1. Download xdd
2. Create a C-Code for this:
xxd -i favicon.ico > favicon.h
add the next lines and - done
*/

#ifndef FAVICON_H
#define FAVICON_H

extern unsigned char favicon_ico[];
extern unsigned int  favicon_ico_len;

#endif /* FAVICON_H */

unsigned char favicon_ico[] = {
  0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x10, 0x10, 0x00, 0x00, 0x01, 0x00,
  0x20, 0x00, 0x68, 0x04, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x20, 0x20,
  0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x28, 0x11, 0x00, 0x00, 0x9e, 0x04,
  0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x68, 0x26,
  0x00, 0x00, 0xc6, 0x15, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00,
  0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x37, 0x00, 0x66, 0xff, 0x50, 0x00, 0x66, 0xff, 0x50, 0x00, 0x65,
  0xff, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0xff, 0x20, 0x00, 0x65,
  0xff, 0x72, 0x00, 0x65, 0xff, 0x6f, 0x00, 0x64, 0xff, 0x5e, 0x00, 0x64,
  0xff, 0x1c, 0x00, 0x66, 0xff, 0x1e, 0x00, 0x65, 0xff, 0x58, 0x00, 0x6a,
  0xff, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x37, 0x00, 0x65,
  0xff, 0x74, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x66, 0xff, 0x64, 0x00, 0x65,
  0xff, 0x5b, 0x00, 0x66, 0xff, 0xa2, 0x00, 0x65, 0xff, 0xe0, 0x00, 0x67,
  0xff, 0x52, 0x00, 0x64, 0xff, 0x42, 0x00, 0x64, 0xff, 0x2e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0xff, 0x3d, 0x00, 0x65,
  0xff, 0xa4, 0x00, 0x66, 0xff, 0x7b, 0x00, 0x65, 0xff, 0x86, 0x00, 0x65,
  0xff, 0xe5, 0x00, 0x65, 0xff, 0xfe, 0x00, 0x66, 0xff, 0xad, 0x00, 0x66,
  0xff, 0x9b, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66, 0xff, 0x55, 0x00, 0x64,
  0xff, 0x45, 0x00, 0x64, 0xff, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6b, 0xff, 0x13, 0x00, 0x66,
  0xff, 0xdd, 0x00, 0x65, 0xff, 0x83, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x65,
  0xff, 0xbb, 0x00, 0x66, 0xff, 0xda, 0x00, 0x66, 0xff, 0xe4, 0x00, 0x66,
  0xff, 0xd4, 0x00, 0x65, 0xff, 0x90, 0x00, 0x65, 0xff, 0x53, 0x00, 0x67,
  0xff, 0xae, 0x00, 0x68, 0xff, 0x20, 0x00, 0x65, 0xff, 0x74, 0x00, 0x5d,
  0xff, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x91, 0x00, 0x66, 0xff, 0x82, 0x00, 0x66, 0xff, 0xa7, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xd5, 0x00, 0x66, 0xff, 0x9d, 0x00, 0x66,
  0xff, 0x78, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66, 0xff, 0xee, 0x00, 0x65,
  0xff, 0x86, 0x00, 0x66, 0xff, 0xe4, 0x00, 0x67, 0xff, 0x86, 0x00, 0x68,
  0xff, 0x16, 0x00, 0x65, 0xff, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62,
  0xff, 0x0d, 0x00, 0x66, 0xff, 0xad, 0x00, 0x65, 0xff, 0x7c, 0x00, 0x66,
  0xff, 0xeb, 0x00, 0x66, 0xff, 0xdc, 0x00, 0x66, 0xff, 0xb9, 0x00, 0x67,
  0xff, 0x6d, 0x00, 0x65, 0xff, 0xde, 0x00, 0x65, 0xff, 0xcf, 0x00, 0x66,
  0xff, 0xf0, 0x00, 0x66, 0xff, 0xdd, 0x00, 0x66, 0xff, 0x93, 0x00, 0x66,
  0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x8f, 0x00, 0x40,
  0xff, 0x04, 0x00, 0x65, 0xff, 0x53, 0x00, 0x66, 0xff, 0xc3, 0x00, 0x66,
  0xff, 0xc0, 0x00, 0x66, 0xff, 0xce, 0x00, 0x66, 0xff, 0x8f, 0x00, 0x66,
  0xff, 0xf9, 0x00, 0x65, 0xff, 0xba, 0x00, 0x66, 0xff, 0xf2, 0x00, 0x66,
  0xff, 0xc0, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x65, 0xff, 0x88, 0x00, 0x65,
  0xff, 0x56, 0x00, 0x65, 0xff, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
  0xff, 0x5e, 0x00, 0x63, 0xff, 0x3e, 0x00, 0x65, 0xff, 0x88, 0x00, 0x65,
  0xff, 0x7e, 0x00, 0x66, 0xff, 0xf6, 0x00, 0x65, 0xff, 0x4e, 0x00, 0x65,
  0xff, 0xef, 0x00, 0x66, 0xff, 0xd5, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x85, 0x00, 0x66, 0xff, 0x76, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x66,
  0xff, 0xe7, 0x00, 0x66, 0xff, 0x94, 0x00, 0x65, 0xff, 0xab, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x65, 0xff, 0x30, 0x00, 0x66, 0xff, 0x73, 0x00, 0x66,
  0xff, 0xa3, 0x00, 0x62, 0xff, 0x27, 0x00, 0x66, 0xff, 0xbb, 0x00, 0x66,
  0xff, 0x67, 0x00, 0x66, 0xff, 0xe7, 0x00, 0x66, 0xff, 0xe5, 0x00, 0x66,
  0xff, 0xb7, 0x00, 0x65, 0xff, 0xae, 0x00, 0x66, 0xff, 0x69, 0x00, 0x65,
  0xff, 0xb0, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x66, 0xff, 0x96, 0x00, 0x66,
  0xff, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0xff, 0x1c, 0x00, 0x65,
  0xff, 0x8d, 0x00, 0x65, 0xff, 0x9f, 0x00, 0x6a, 0xff, 0x18, 0x00, 0x65,
  0xff, 0x5d, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x65, 0xff, 0x74, 0x00, 0x66,
  0xff, 0xc1, 0x00, 0x65, 0xff, 0xae, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xd8, 0x00, 0x66, 0xff, 0xe4, 0x00, 0x66, 0xff, 0x76, 0x00, 0x63,
  0xff, 0x48, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62,
  0xff, 0x27, 0x00, 0x66, 0xff, 0x8a, 0x00, 0x67, 0xff, 0x7e, 0x00, 0x65,
  0xff, 0x3f, 0x00, 0x55, 0xff, 0x06, 0x00, 0x66, 0xff, 0xb2, 0x00, 0x66,
  0xff, 0xf7, 0x00, 0x66, 0xff, 0x46, 0x00, 0x65, 0xff, 0x95, 0x00, 0x66,
  0xff, 0xdf, 0x00, 0x65, 0xff, 0xc7, 0x00, 0x65, 0xff, 0x5d, 0x00, 0x67,
  0xff, 0x54, 0x00, 0x68, 0xff, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x4f, 0x00, 0x65, 0xff, 0x6a, 0x00, 0x65,
  0xff, 0x3f, 0x00, 0x66, 0xff, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0xff, 0x02, 0x00, 0x65, 0xff, 0x4e, 0x00, 0x66, 0xff, 0xa5, 0x00, 0x65,
  0xff, 0xea, 0x00, 0x65, 0xff, 0x9c, 0x00, 0x65, 0xff, 0x3f, 0x00, 0x60,
  0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x94, 0x00, 0x65,
  0xff, 0x2b, 0x00, 0x80, 0xff, 0x02, 0x00, 0x66, 0xff, 0xc1, 0x00, 0x66,
  0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x05, 0x00, 0x60, 0xff, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0xff, 0x0c, 0x00, 0x65,
  0xff, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x60, 0x00, 0x66, 0xff, 0x6e, 0x00, 0x66, 0xff, 0x05, 0x00, 0x62,
  0xff, 0x22, 0x00, 0x65, 0xff, 0x2b, 0x00, 0x62, 0xff, 0x1a, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x64, 0xff, 0x1c, 0x00, 0x65,
  0xff, 0x2b, 0x00, 0x64, 0xff, 0x21, 0x00, 0x40, 0xff, 0x04, 0x00, 0x66,
  0xff, 0x80, 0x00, 0x65, 0xff, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x66, 0xff, 0x8c, 0x00, 0x65,
  0xff, 0x79, 0x00, 0x66, 0xff, 0x64, 0x00, 0x66, 0xff, 0x5f, 0x00, 0x66,
  0xff, 0x73, 0x00, 0x65, 0xff, 0x8d, 0x00, 0x65, 0xff, 0x8b, 0x00, 0x64,
  0xff, 0x70, 0x00, 0x67, 0xff, 0x5e, 0x00, 0x65, 0xff, 0x65, 0x00, 0x66,
  0xff, 0x7b, 0x00, 0x64, 0xff, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x19, 0x00, 0x65,
  0xff, 0x6a, 0x00, 0x65, 0xff, 0x65, 0x00, 0x61, 0xff, 0x15, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0xff, 0x42, 0x00, 0x65,
  0xff, 0x9c, 0x00, 0x65, 0xff, 0x88, 0x00, 0x65, 0xff, 0x35, 0x00, 0x65,
  0xff, 0x3a, 0x00, 0x65, 0xff, 0x8d, 0x00, 0x66, 0xff, 0x9b, 0x00, 0x68,
  0xff, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0xff, 0x2f, 0x00, 0x66,
  0xff, 0xa3, 0x00, 0x66, 0xff, 0x67, 0x00, 0x60, 0xff, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x0a, 0x00, 0x65, 0xff, 0x6f, 0x00, 0x66,
  0xff, 0xa0, 0x00, 0x64, 0xff, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xff, 0x03, 0x00, 0x65,
  0xff, 0x7e, 0x00, 0x66, 0xff, 0x91, 0x00, 0x66, 0xff, 0x64, 0x00, 0x67,
  0xff, 0x95, 0x00, 0x66, 0xff, 0xb9, 0x00, 0x65, 0xff, 0xbf, 0x00, 0x65,
  0xff, 0xb8, 0x00, 0x65, 0xff, 0x6d, 0x00, 0x40, 0xff, 0x04, 0x00, 0x00,
  0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0xff, 0x0e, 0x00, 0x66,
  0xff, 0x8a, 0x00, 0x66, 0xff, 0x75, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x0f, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x66, 0xff, 0x73, 0x00, 0x67,
  0xff, 0x77, 0x00, 0x65, 0xff, 0x6f, 0x00, 0x66, 0xff, 0x7a, 0x00, 0x65,
  0xff, 0x97, 0x00, 0x66, 0xff, 0x96, 0x00, 0x64, 0xff, 0x40, 0x00, 0x65,
  0xff, 0x62, 0x00, 0x66, 0xff, 0xb7, 0x00, 0x65, 0xff, 0xef, 0x00, 0x65,
  0xff, 0x95, 0x00, 0x66, 0xff, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x47, 0x00, 0x65, 0xff, 0x9c, 0x00, 0x66, 0xff, 0x0a, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x1c, 0x00, 0x65, 0xff, 0xb0, 0x00, 0x66,
  0xff, 0x23, 0x00, 0x66, 0xff, 0x99, 0x00, 0x66, 0xff, 0xda, 0x00, 0x66,
  0xff, 0xd7, 0x00, 0x65, 0xff, 0x5d, 0x00, 0x62, 0xff, 0x22, 0x00, 0x65,
  0xff, 0x65, 0x00, 0x66, 0xff, 0x32, 0x00, 0x66, 0xff, 0x82, 0x00, 0x65,
  0xff, 0xef, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xeb, 0x00, 0x65, 0xff, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x26, 0x00, 0x66, 0xff, 0xa2, 0x00, 0x5b, 0xff, 0x0e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0xff, 0x1b, 0x00, 0x66,
  0xff, 0xda, 0x00, 0x66, 0xff, 0x5f, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x64,
  0xff, 0x45, 0x00, 0x66, 0xff, 0xac, 0x00, 0x66, 0xff, 0x37, 0x00, 0x65,
  0xff, 0x9a, 0x00, 0x66, 0xff, 0xfb, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfa, 0x00, 0x65, 0xff, 0x9c, 0x00, 0x66, 0xff, 0x2d, 0x00, 0x66,
  0xff, 0xaa, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfb, 0x00, 0x66, 0xff, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
  0xff, 0x25, 0x00, 0x66, 0xff, 0xb1, 0x00, 0x66, 0xff, 0x0a, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d,
  0xff, 0x0b, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x66,
  0xff, 0xb7, 0x00, 0x66, 0xff, 0xeb, 0x00, 0x61, 0xff, 0x15, 0x00, 0x64,
  0xff, 0x45, 0x00, 0x66, 0xff, 0xf1, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0xed, 0x00, 0x67, 0xff, 0x48, 0x00, 0x66,
  0xff, 0x7b, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x65,
  0xff, 0xdb, 0x00, 0x64, 0xff, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
  0xff, 0x3d, 0x00, 0x65, 0xff, 0xae, 0x00, 0x80, 0xff, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xa2, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x67, 0xff, 0x54, 0x00, 0x65, 0xff, 0xc9, 0x00, 0x64,
  0xff, 0x40, 0x00, 0x64, 0xff, 0x59, 0x00, 0x62, 0xff, 0x39, 0x00, 0x66,
  0xff, 0xb4, 0x00, 0x66, 0xff, 0xb4, 0x00, 0x65, 0xff, 0xb5, 0x00, 0x66,
  0xff, 0xf0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x66,
  0xff, 0xb7, 0x00, 0x66, 0xff, 0xad, 0x00, 0x61, 0xff, 0x15, 0x00, 0x68,
  0xff, 0x2c, 0x00, 0x66, 0xff, 0x32, 0x00, 0x67, 0xff, 0x4f, 0x00, 0x66,
  0xff, 0x6b, 0x00, 0x66, 0xff, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x7f, 0x00, 0x66, 0xff, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x4e, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd4, 0x00, 0x62,
  0xff, 0x27, 0x00, 0x65, 0xff, 0xc9, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xb4, 0x00, 0x65,
  0xff, 0xed, 0x00, 0x65, 0xff, 0xa9, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66,
  0xff, 0xfb, 0x00, 0x66, 0xff, 0x84, 0x00, 0x67, 0xff, 0x39, 0x00, 0x66,
  0xff, 0xb7, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xff, 0x06, 0x00, 0x66,
  0xff, 0xd3, 0x00, 0x65, 0xff, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x05, 0x00, 0x66, 0xff, 0xdd, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0x74, 0x00, 0x67, 0xff, 0x48, 0x00, 0x66,
  0xff, 0xd0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0x70, 0x00, 0x63, 0xff, 0x2c, 0x00, 0x66,
  0xff, 0xf7, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xd9, 0x00, 0x65, 0xff, 0xb8, 0x00, 0x62, 0xff, 0x27, 0x00, 0x66,
  0xff, 0xf8, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x80,
  0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xff, 0x56, 0x00, 0x65,
  0xff, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67,
  0xff, 0x63, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0x8e, 0x00, 0x6d,
  0xff, 0x07, 0x00, 0x66, 0xff, 0xd8, 0x00, 0x66, 0xff, 0xac, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xa1, 0x00, 0x65,
  0xff, 0xb6, 0x00, 0x66, 0xff, 0x37, 0x00, 0x64, 0xff, 0x40, 0x00, 0x65,
  0xff, 0x8b, 0x00, 0x67, 0xff, 0xb8, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x65,
  0xff, 0xcf, 0x00, 0x66, 0xff, 0x6b, 0x00, 0x66, 0xff, 0x9b, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x68, 0xff, 0x36, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0xff, 0x02, 0x00, 0x66, 0xff, 0xdb, 0x00, 0x65,
  0xff, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xd3, 0x00, 0x66,
  0xff, 0xa0, 0x00, 0x64, 0xff, 0x54, 0x00, 0x65, 0xff, 0x51, 0x00, 0x66,
  0xff, 0xe8, 0x00, 0x66, 0xff, 0xe8, 0x00, 0x65, 0xff, 0xc4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xeb, 0x00, 0x66, 0xff, 0x55, 0x00, 0x61,
  0xff, 0x2a, 0x00, 0x66, 0xff, 0x71, 0x00, 0x66, 0xff, 0xad, 0x00, 0x65,
  0xff, 0xfe, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xe5, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x65, 0xff, 0xcf, 0x00, 0x65,
  0xff, 0xd6, 0x00, 0x64, 0xff, 0x38, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x78, 0x00, 0x65, 0xff, 0xab, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
  0xff, 0x33, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x67, 0xff, 0x48, 0x00, 0x66,
  0xff, 0xf6, 0x00, 0x65, 0xff, 0x56, 0x00, 0x66, 0xff, 0xdf, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xb2, 0x00, 0x66, 0xff, 0xfb, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0xa4, 0x00, 0x67, 0xff, 0xf1, 0x00, 0x67,
  0xff, 0x2a, 0x00, 0x66, 0xff, 0xcd, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xde, 0x00, 0x65, 0xff, 0x79, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xe2, 0x00, 0x65, 0xff, 0xcf, 0x00, 0x66, 0xff, 0xff, 0x00, 0x63,
  0xff, 0x2c, 0x00, 0x66, 0xff, 0xeb, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x23, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x5a, 0xff, 0x11, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x84, 0x00, 0x67,
  0xff, 0xc2, 0x00, 0x66, 0xff, 0xdc, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x6a, 0x00, 0x66, 0xff, 0xc0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xdf, 0x00, 0x65, 0xff, 0x98, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xf8, 0x00, 0x65, 0xff, 0xab, 0x00, 0x66, 0xff, 0xa5, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xa8, 0x00, 0x66,
  0xff, 0xbc, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x65,
  0xff, 0xab, 0x00, 0x66, 0xff, 0x99, 0x00, 0x64, 0xff, 0x29, 0x00, 0x64,
  0xff, 0x33, 0x00, 0x64, 0xff, 0x33, 0x00, 0x63, 0xff, 0x1f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0xda, 0x00, 0x65, 0xff, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x65, 0xff, 0xc7, 0x00, 0x65, 0xff, 0x86, 0x00, 0x65,
  0xff, 0xea, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0x98, 0x00, 0x65,
  0xff, 0x8b, 0x00, 0x65, 0xff, 0xef, 0x00, 0x63, 0xff, 0x3b, 0x00, 0x66,
  0xff, 0x8c, 0x00, 0x66, 0xff, 0xef, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xb7, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xcb, 0x00, 0x66, 0xff, 0xde, 0x00, 0x65, 0xff, 0xbf, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x65, 0xff, 0x47, 0x00, 0x65,
  0xff, 0x97, 0x00, 0x66, 0xff, 0x66, 0x00, 0x65, 0xff, 0x97, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xff, 0x9f, 0x00, 0x65,
  0xff, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xff, 0x03, 0x00, 0x66,
  0xff, 0xf8, 0x00, 0x67, 0xff, 0x57, 0x00, 0x66, 0xff, 0xcd, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xda, 0x00, 0x64, 0xff, 0x38, 0x00, 0x65,
  0xff, 0x4c, 0x00, 0x65, 0xff, 0xbf, 0x00, 0x65, 0xff, 0xfe, 0x00, 0x64,
  0xff, 0xad, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x64, 0xff, 0x40, 0x00, 0x65,
  0xff, 0x92, 0x00, 0x65, 0xff, 0x81, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xe2, 0x00, 0x65, 0xff, 0xcf, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x8f, 0x00, 0x65, 0xff, 0x9a, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x70, 0x00, 0x66, 0xff, 0xd2, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x65, 0xff, 0x26, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x37, 0x00, 0x66, 0xff, 0x9e, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0x2d, 0x00, 0x64, 0xff, 0x87, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xcd, 0x00, 0x66,
  0xff, 0xdd, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xa9, 0x00, 0x66, 0xff, 0x2d, 0x00, 0x62, 0xff, 0x1a, 0x00, 0x65,
  0xff, 0xab, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x66,
  0xff, 0xd0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0x85, 0x00, 0x66,
  0xff, 0xa3, 0x00, 0x66, 0xff, 0xff, 0x00, 0x68, 0xff, 0x3b, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x50, 0x00, 0x66, 0xff, 0xf9, 0x00, 0x00, 0xff, 0x01, 0x00, 0x67,
  0xff, 0x3e, 0x00, 0x66, 0xff, 0xff, 0x00, 0x64, 0xff, 0x21, 0x00, 0x66,
  0xff, 0x55, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xc8, 0x00, 0x61,
  0xff, 0x2a, 0x00, 0x65, 0xff, 0x4c, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xab, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x67, 0xff, 0x2f, 0x00, 0x65,
  0xff, 0xb8, 0x00, 0x66, 0xff, 0x4b, 0x00, 0x65, 0xff, 0x68, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xd3, 0x00, 0x66, 0xff, 0xe4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0x67, 0x00, 0x65, 0xff, 0xc4, 0x00, 0x66,
  0xff, 0xe6, 0x00, 0x55, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x3c, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x60, 0xff, 0x18, 0x00, 0x64, 0xff, 0x4f, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x60, 0xff, 0x20, 0x00, 0x6d, 0xff, 0x07, 0x00, 0x66,
  0xff, 0xe6, 0x00, 0x66, 0xff, 0x41, 0x00, 0x66, 0xff, 0xe7, 0x00, 0x66,
  0xff, 0x41, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xed, 0x00, 0x66, 0xff, 0x9b, 0x00, 0x65,
  0xff, 0x4e, 0x00, 0x66, 0xff, 0xd3, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xe1, 0x00, 0x60, 0xff, 0x10, 0x00, 0x66, 0xff, 0x64, 0x00, 0x66,
  0xff, 0x8a, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x64,
  0xff, 0x38, 0x00, 0x66, 0xff, 0xf6, 0x00, 0x66, 0xff, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x33, 0x00, 0x66, 0xff, 0xff, 0x00, 0x60,
  0xff, 0x20, 0x00, 0x64, 0xff, 0x4a, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67,
  0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0xff, 0x2a, 0x00, 0x65,
  0xff, 0x8d, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xe3, 0x00, 0x62,
  0xff, 0x22, 0x00, 0x66, 0xff, 0xbe, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xf4, 0x00, 0x66, 0xff, 0x3c, 0x00, 0x65, 0xff, 0xd1, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xa1, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x66, 0xff, 0xc3, 0x00, 0x65,
  0xff, 0xef, 0x00, 0x66, 0xff, 0xaa, 0x00, 0x62, 0xff, 0x0d, 0x00, 0x67,
  0xff, 0x2f, 0x00, 0x55, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
  0xff, 0x42, 0x00, 0x66, 0xff, 0xff, 0x00, 0x60, 0xff, 0x20, 0x00, 0x63,
  0xff, 0x36, 0x00, 0x66, 0xff, 0xff, 0x00, 0x68, 0xff, 0x3b, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xbe, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x68,
  0xff, 0x20, 0x00, 0x65, 0xff, 0xab, 0x00, 0x65, 0xff, 0x65, 0x00, 0x66,
  0xff, 0xad, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xc1, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xd5, 0x00, 0x67, 0xff, 0x25, 0x00, 0x64,
  0xff, 0x1c, 0x00, 0x65, 0xff, 0x9f, 0x00, 0x65, 0xff, 0x44, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xff, 0x5b, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x55, 0xff, 0x0c, 0x00, 0x68, 0xff, 0x16, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x19, 0x00, 0x66, 0xff, 0xde, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xdf, 0x00, 0x66,
  0xff, 0x2d, 0x00, 0x63, 0xff, 0x1f, 0x00, 0x66, 0xff, 0xe1, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xe3, 0x00, 0x64, 0xff, 0x54, 0x00, 0x69,
  0xff, 0x27, 0x00, 0x66, 0xff, 0xcc, 0x00, 0x67, 0xff, 0x45, 0x00, 0x66,
  0xff, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x65, 0xff, 0x83, 0x00, 0x66, 0xff, 0xed, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xe5, 0x00, 0x66,
  0xff, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x1c, 0x00, 0x66, 0xff, 0xcf, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x68, 0xff, 0x40, 0x00, 0x65,
  0xff, 0x8b, 0x00, 0x62, 0xff, 0x22, 0x00, 0x64, 0xff, 0x54, 0x00, 0x66,
  0xff, 0xa3, 0x00, 0x66, 0xff, 0xdc, 0x00, 0x65, 0xff, 0xf4, 0x00, 0x66,
  0xff, 0x46, 0x00, 0x65, 0xff, 0x9c, 0x00, 0x65, 0xff, 0x5d, 0x00, 0x60,
  0xff, 0x10, 0x00, 0x67, 0xff, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0xb9, 0x00, 0x65, 0xff, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x66, 0xff, 0xde, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x60, 0xff, 0x08, 0x00, 0x66, 0xff, 0x84, 0x00, 0x66,
  0xff, 0xb4, 0x00, 0x67, 0xff, 0x74, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfb, 0x00, 0x66, 0xff, 0xb9, 0x00, 0x66, 0xff, 0x71, 0x00, 0x64,
  0xff, 0x40, 0x00, 0x55, 0xff, 0x03, 0x00, 0x68, 0xff, 0x20, 0x00, 0x63,
  0xff, 0x36, 0x00, 0x68, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x55, 0xff, 0x09, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x65,
  0xff, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x58, 0x00, 0x66, 0xff, 0xff, 0x00, 0x64, 0xff, 0x33, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x5f, 0x00, 0x66, 0xff, 0xc1, 0x00, 0x65, 0xff, 0xf4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xbf, 0x00, 0x66,
  0xff, 0x41, 0x00, 0x65, 0xff, 0x97, 0x00, 0x64, 0xff, 0x3d, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x53, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0x2d, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xff, 0x09, 0x00, 0x66,
  0xff, 0xef, 0x00, 0x65, 0xff, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x14, 0x00, 0x66,
  0xff, 0x19, 0x00, 0x55, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xb9, 0x00, 0x66,
  0xff, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x8a, 0x00, 0x66,
  0xff, 0xf5, 0x00, 0x68, 0xff, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x30, 0x00, 0x65, 0xff, 0xfe, 0x00, 0x65, 0xff, 0x60, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x17, 0x00, 0x66, 0xff, 0xf2, 0x00, 0x66,
  0xff, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xb4, 0x00, 0x66,
  0xff, 0xdc, 0x00, 0x66, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x67, 0xff, 0x77, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x68,
  0xff, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x14, 0x00, 0x64,
  0xff, 0x38, 0x00, 0x64, 0xff, 0x4f, 0x00, 0x66, 0xff, 0x5a, 0x00, 0x65,
  0xff, 0x51, 0x00, 0x67, 0xff, 0x45, 0x00, 0x63, 0xff, 0x24, 0x00, 0x80,
  0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0xff, 0x04, 0x00, 0x64, 0xff, 0x29, 0x00, 0x65, 0xff, 0x49, 0x00, 0x65,
  0xff, 0x56, 0x00, 0x65, 0xff, 0x56, 0x00, 0x67, 0xff, 0x4f, 0x00, 0x67,
  0xff, 0x34, 0x00, 0x66, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x4b, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0x50, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x05, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66, 0xff, 0xdb, 0x00, 0x66,
  0xff, 0xdb, 0x00, 0x66, 0xff, 0xed, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x65,
  0xff, 0xbf, 0x00, 0x66, 0xff, 0xbb, 0x00, 0x65, 0xff, 0xc2, 0x00, 0x66,
  0xff, 0xd5, 0x00, 0x65, 0xff, 0xf4, 0x00, 0x66, 0xff, 0xf1, 0x00, 0x66,
  0xff, 0xaf, 0x00, 0x65, 0xff, 0xba, 0x00, 0x66, 0xff, 0xf6, 0x00, 0x65,
  0xff, 0xef, 0x00, 0x65, 0xff, 0xd1, 0x00, 0x65, 0xff, 0xbf, 0x00, 0x66,
  0xff, 0xbb, 0x00, 0x65, 0xff, 0xc2, 0x00, 0x66, 0xff, 0xd4, 0x00, 0x66,
  0xff, 0xf1, 0x00, 0x65, 0xff, 0xd4, 0x00, 0x66, 0xff, 0xe7, 0x00, 0x65,
  0xff, 0xae, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
  0xff, 0x29, 0x00, 0x65, 0xff, 0x5d, 0x00, 0x64, 0xff, 0x1c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0xff, 0x02, 0x00, 0x66, 0xff, 0x28, 0x00, 0x66, 0xff, 0x6c, 0x00, 0x66,
  0xff, 0x5f, 0x00, 0x63, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x67,
  0xff, 0x25, 0x00, 0x66, 0xff, 0x67, 0x00, 0x61, 0xff, 0x15, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x30, 0x00,
  0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
  0xff, 0x04, 0x00, 0x68, 0xff, 0x16, 0x00, 0x68, 0xff, 0x2c, 0x00, 0x61,
  0xff, 0x2a, 0x00, 0x66, 0xff, 0x14, 0x00, 0x55, 0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x6a, 0xff, 0x0c, 0x00, 0x67, 0xff, 0x43, 0x00, 0x65,
  0xff, 0x83, 0x00, 0x65, 0xff, 0x9f, 0x00, 0x65, 0xff, 0x9c, 0x00, 0x66,
  0xff, 0x9d, 0x00, 0x66, 0xff, 0x9e, 0x00, 0x66, 0xff, 0x80, 0x00, 0x65,
  0xff, 0x3f, 0x00, 0x71, 0xff, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x4b, 0x00, 0x66, 0xff, 0xbc, 0x00, 0x66, 0xff, 0xb1, 0x00, 0x65,
  0xff, 0x5b, 0x00, 0x68, 0xff, 0x20, 0x00, 0x5b, 0xff, 0x0e, 0x00, 0x66,
  0xff, 0x0f, 0x00, 0x66, 0xff, 0x23, 0x00, 0x64, 0xff, 0x63, 0x00, 0x65,
  0xff, 0xba, 0x00, 0x65, 0xff, 0xb8, 0x00, 0x66, 0xff, 0x41, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
  0xff, 0x08, 0x00, 0x63, 0xff, 0x3b, 0x00, 0x65, 0xff, 0xab, 0x00, 0x66,
  0xff, 0xc1, 0x00, 0x65, 0xff, 0x49, 0x00, 0x80, 0xff, 0x04, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55,
  0xff, 0x06, 0x00, 0x65, 0xff, 0x53, 0x00, 0x65, 0xff, 0xc7, 0x00, 0x66,
  0xff, 0xa3, 0x00, 0x67, 0xff, 0x34, 0x00, 0x6d, 0xff, 0x07, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xff, 0x27, 0x00, 0x66,
  0xff, 0x89, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x65, 0xff, 0x56, 0x00, 0x6a,
  0xff, 0x18, 0x00, 0x67, 0xff, 0x2a, 0x00, 0x67, 0xff, 0x3e, 0x00, 0x64,
  0xff, 0x40, 0x00, 0x64, 0xff, 0x40, 0x00, 0x67, 0xff, 0x34, 0x00, 0x6a,
  0xff, 0x1d, 0x00, 0x66, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x0f, 0x00, 0x64,
  0xff, 0x5e, 0x00, 0x66, 0xff, 0xa5, 0x00, 0x64, 0xff, 0x84, 0x00, 0x60,
  0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0xff, 0x02, 0x00, 0x66, 0xff, 0x4b, 0x00, 0x65, 0xff, 0xcc, 0x00, 0x67,
  0xff, 0x72, 0x00, 0x65, 0xff, 0x68, 0x00, 0x65, 0xff, 0xab, 0x00, 0x66,
  0xff, 0xd9, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x66, 0xff, 0xe9, 0x00, 0x65,
  0xff, 0xea, 0x00, 0x65, 0xff, 0xea, 0x00, 0x66, 0xff, 0xe6, 0x00, 0x65,
  0xff, 0xb5, 0x00, 0x67, 0xff, 0x3e, 0x00, 0x80, 0xff, 0x02, 0x00, 0x00,
  0xff, 0x01, 0x00, 0x00, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0xff, 0x02, 0x00, 0x60, 0xff, 0x18, 0x00, 0x65, 0xff, 0x77, 0x00, 0x67,
  0xff, 0xcb, 0x00, 0x67, 0xff, 0x3e, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xff, 0x08, 0x00, 0x66,
  0xff, 0x5a, 0x00, 0x66, 0xff, 0xc3, 0x00, 0x66, 0xff, 0x87, 0x00, 0x66,
  0xff, 0xbc, 0x00, 0x67, 0xff, 0xc4, 0x00, 0x65, 0xff, 0xba, 0x00, 0x65,
  0xff, 0xc7, 0x00, 0x66, 0xff, 0xd6, 0x00, 0x66, 0xff, 0xdf, 0x00, 0x66,
  0xff, 0xdf, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x64, 0xff, 0x42, 0x00, 0x64,
  0xff, 0x1c, 0x00, 0x67, 0xff, 0x48, 0x00, 0x66, 0xff, 0x9e, 0x00, 0x65,
  0xff, 0xe8, 0x00, 0x67, 0xff, 0xb0, 0x00, 0x68, 0xff, 0x3b, 0x00, 0x5d,
  0xff, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x41, 0x00, 0x66, 0xff, 0xbe, 0x00, 0x66, 0xff, 0x50, 0x00, 0x66,
  0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x17, 0x00, 0x66, 0xff, 0x87, 0x00, 0x66,
  0xff, 0xa3, 0x00, 0x63, 0xff, 0x4d, 0x00, 0x64, 0xff, 0x59, 0x00, 0x68,
  0xff, 0x5b, 0x00, 0x65, 0xff, 0x60, 0x00, 0x65, 0xff, 0x60, 0x00, 0x64,
  0xff, 0x52, 0x00, 0x63, 0xff, 0x1f, 0x00, 0x63, 0xff, 0x1f, 0x00, 0x67,
  0xff, 0x25, 0x00, 0x80, 0xff, 0x04, 0x00, 0x65, 0xff, 0x3f, 0x00, 0x67,
  0xff, 0xbd, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xf4, 0x00, 0x66,
  0xff, 0x9b, 0x00, 0x68, 0xff, 0x31, 0x00, 0x80, 0xff, 0x02, 0x00, 0x00,
  0xff, 0x01, 0x00, 0x66, 0xff, 0x32, 0x00, 0x66, 0xff, 0xa8, 0x00, 0x67,
  0xff, 0x74, 0x00, 0x5d, 0xff, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
  0xff, 0x10, 0x00, 0x67, 0xff, 0x9f, 0x00, 0x66, 0xff, 0x96, 0x00, 0x61,
  0xff, 0x1d, 0x00, 0x64, 0xff, 0x3d, 0x00, 0x66, 0xff, 0xd9, 0x00, 0x67,
  0xff, 0xf1, 0x00, 0x66, 0xff, 0xf4, 0x00, 0x66, 0xff, 0xdc, 0x00, 0x65,
  0xff, 0x5d, 0x00, 0x60, 0xff, 0x10, 0x00, 0x65, 0xff, 0x56, 0x00, 0x66,
  0xff, 0xb6, 0x00, 0x66, 0xff, 0x70, 0x00, 0x6b, 0xff, 0x1f, 0x00, 0x68,
  0xff, 0x2c, 0x00, 0x66, 0xff, 0x94, 0x00, 0x66, 0xff, 0xf6, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfd, 0x00, 0x66, 0xff, 0xd9, 0x00, 0x65, 0xff, 0x3f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xff, 0x15, 0x00, 0x66,
  0xff, 0xa5, 0x00, 0x66, 0xff, 0x7b, 0x00, 0x60, 0xff, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x0f, 0x00, 0x65,
  0xff, 0xa1, 0x00, 0x66, 0xff, 0xc6, 0x00, 0x68, 0xff, 0x40, 0x00, 0x66,
  0xff, 0xc5, 0x00, 0x6a, 0xff, 0x18, 0x00, 0x65, 0xff, 0x9d, 0x00, 0x66,
  0xff, 0xea, 0x00, 0x66, 0xff, 0x98, 0x00, 0x64, 0xff, 0x21, 0x00, 0x67,
  0xff, 0x3e, 0x00, 0x66, 0xff, 0xc1, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x66,
  0xff, 0x82, 0x00, 0x64, 0xff, 0x21, 0x00, 0x65, 0xff, 0x3f, 0x00, 0x65,
  0xff, 0xca, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x65,
  0xff, 0x4c, 0x00, 0x66, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61,
  0xff, 0x15, 0x00, 0x66, 0xff, 0xaf, 0x00, 0x66, 0xff, 0x70, 0x00, 0x55,
  0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x14, 0x00, 0x67, 0xff, 0x9c, 0x00, 0x66,
  0xff, 0xf3, 0x00, 0x65, 0xff, 0x6f, 0x00, 0x66, 0xff, 0xb4, 0x00, 0x66,
  0xff, 0xf8, 0x00, 0x65, 0xff, 0x79, 0x00, 0x66, 0xff, 0x1e, 0x00, 0x66,
  0xff, 0x4b, 0x00, 0x67, 0xff, 0x45, 0x00, 0x66, 0xff, 0xa3, 0x00, 0x66,
  0xff, 0xf5, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfd, 0x00, 0x66, 0xff, 0xd1, 0x00, 0x66, 0xff, 0x69, 0x00, 0x63,
  0xff, 0x1f, 0x00, 0x66, 0xff, 0x8c, 0x00, 0x66, 0xff, 0xf4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xe8, 0x00, 0x65, 0xff, 0x51, 0x00, 0x55, 0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x2d, 0x00, 0x65, 0xff, 0xc9, 0x00, 0x66,
  0xff, 0x73, 0x00, 0x55, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0xff, 0x06, 0x00, 0x66, 0xff, 0x7f, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x66,
  0xff, 0xd2, 0x00, 0x65, 0xff, 0x5d, 0x00, 0x66, 0xff, 0xee, 0x00, 0x66,
  0xff, 0xf4, 0x00, 0x66, 0xff, 0x6c, 0x00, 0x80, 0xff, 0x04, 0x00, 0x62,
  0xff, 0x22, 0x00, 0x66, 0xff, 0xdc, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x65,
  0xff, 0xa6, 0x00, 0x64, 0xff, 0x1c, 0x00, 0x66, 0xff, 0x73, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xf9, 0x00, 0x65,
  0xff, 0xd4, 0x00, 0x65, 0xff, 0x8b, 0x00, 0x66, 0xff, 0x0f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x66, 0xff, 0x32, 0x00, 0x66,
  0xff, 0xe1, 0x00, 0x66, 0xff, 0x5a, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x46, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x70, 0x00, 0x66, 0xff, 0x93, 0x00, 0x66, 0xff, 0xe1, 0x00, 0x67,
  0xff, 0x57, 0x00, 0x62, 0xff, 0x22, 0x00, 0x66, 0xff, 0x67, 0x00, 0x60,
  0xff, 0x18, 0x00, 0x67, 0xff, 0x9a, 0x00, 0x66, 0xff, 0xe6, 0x00, 0x66,
  0xff, 0xe6, 0x00, 0x66, 0xff, 0xe6, 0x00, 0x66, 0xff, 0xe6, 0x00, 0x66,
  0xff, 0xf7, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfe, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x66, 0xff, 0xe7, 0x00, 0x66,
  0xff, 0xe4, 0x00, 0x66, 0xff, 0x85, 0x00, 0x55, 0xff, 0x09, 0x00, 0x65,
  0xff, 0x49, 0x00, 0x66, 0xff, 0x3c, 0x00, 0x66, 0xff, 0x19, 0x00, 0x66,
  0xff, 0x19, 0x00, 0x68, 0xff, 0x20, 0x00, 0x67, 0xff, 0x25, 0x00, 0x55,
  0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x62, 0x00, 0x66, 0xff, 0xcd, 0x00, 0x66, 0xff, 0x28, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0xff, 0x20, 0x00, 0x66,
  0xff, 0xd9, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xeb, 0x00, 0x66,
  0xff, 0x28, 0x00, 0x67, 0xff, 0x95, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x65,
  0xff, 0xa4, 0x00, 0x65, 0xff, 0xa9, 0x00, 0x66, 0xff, 0xb1, 0x00, 0x65,
  0xff, 0xa4, 0x00, 0x65, 0xff, 0xac, 0x00, 0x66, 0xff, 0xb4, 0x00, 0x66,
  0xff, 0xb4, 0x00, 0x66, 0xff, 0xb4, 0x00, 0x65, 0xff, 0xb6, 0x00, 0x65,
  0xff, 0xae, 0x00, 0x66, 0xff, 0xf6, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xd6, 0x00, 0x66, 0xff, 0xaf, 0x00, 0x65, 0xff, 0xb6, 0x00, 0x66,
  0xff, 0xb4, 0x00, 0x66, 0xff, 0x6e, 0x00, 0x69, 0xff, 0x2e, 0x00, 0x6a,
  0xff, 0x0c, 0x00, 0x68, 0xff, 0x40, 0x00, 0x66, 0xff, 0xa8, 0x00, 0x65,
  0xff, 0xc9, 0x00, 0x66, 0xff, 0xdf, 0x00, 0x66, 0xff, 0xee, 0x00, 0x65,
  0xff, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
  0xff, 0x10, 0x00, 0x66, 0xff, 0xac, 0x00, 0x65, 0xff, 0xab, 0x00, 0x49,
  0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x05, 0x00, 0x66, 0xff, 0xa8, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67, 0xff, 0xa4, 0x00, 0x80,
  0xff, 0x04, 0x00, 0x67, 0xff, 0x68, 0x00, 0x66, 0xff, 0xf2, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xd3, 0x00, 0x66, 0xff, 0xc8, 0x00, 0x65, 0xff, 0xcc, 0x00, 0x66,
  0xff, 0x8c, 0x00, 0x66, 0xff, 0xf3, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xee, 0x00, 0x65, 0xff, 0x79, 0x00, 0x65,
  0xff, 0x8b, 0x00, 0x68, 0xff, 0x20, 0x00, 0x66, 0xff, 0xd8, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xd0, 0x00, 0x5e, 0xff, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xff, 0x01, 0x00, 0x65, 0xff, 0x47, 0x00, 0x66, 0xff, 0xe8, 0x00, 0x65,
  0xff, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xff, 0x01, 0x00, 0x65, 0xff, 0x4c, 0x00, 0x66, 0xff, 0xed, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xf6, 0x00, 0x66, 0xff, 0x55, 0x00, 0x60,
  0xff, 0x10, 0x00, 0x66, 0xff, 0x76, 0x00, 0x66, 0xff, 0xf4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xc8, 0x00, 0x68, 0xff, 0x31, 0x00, 0x61, 0xff, 0x1d, 0x00, 0x66,
  0xff, 0xea, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xb8, 0x00, 0x65,
  0xff, 0xbd, 0x00, 0x64, 0xff, 0x45, 0x00, 0x67, 0xff, 0x57, 0x00, 0x66,
  0xff, 0xfb, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xf1, 0x00, 0x66, 0xff, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x55, 0xff, 0x03, 0x00, 0x66, 0xff, 0xaf, 0x00, 0x66,
  0xff, 0xe0, 0x00, 0x63, 0xff, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b,
  0xff, 0x0e, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x66,
  0xff, 0xf6, 0x00, 0x65, 0xff, 0x88, 0x00, 0x6a, 0xff, 0x0c, 0x00, 0x66,
  0xff, 0x84, 0x00, 0x65, 0xff, 0xb6, 0x00, 0x66, 0xff, 0xd7, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xe8, 0x00, 0x65, 0xff, 0xbf, 0x00, 0x65, 0xff, 0xbf, 0x00, 0x67,
  0xff, 0xb5, 0x00, 0x65, 0xff, 0xb0, 0x00, 0x66, 0xff, 0xa3, 0x00, 0x65,
  0xff, 0x47, 0x00, 0x68, 0xff, 0x36, 0x00, 0x67, 0xff, 0x9c, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xcc, 0x00, 0x65,
  0xff, 0xb5, 0x00, 0x66, 0xff, 0xaa, 0x00, 0x63, 0xff, 0x12, 0x00, 0x67,
  0xff, 0xb8, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xfe, 0x00, 0x66, 0xff, 0x8f, 0x00, 0x6d, 0xff, 0x07, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xff, 0x30, 0x00, 0x66,
  0xff, 0xf0, 0x00, 0x66, 0xff, 0x7d, 0x00, 0x66, 0xff, 0x05, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63,
  0xff, 0x31, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x9c, 0x00, 0x64, 0xff, 0x17, 0x00, 0x80, 0xff, 0x04, 0x00, 0x66,
  0xff, 0xc5, 0x00, 0x66, 0xff, 0xf1, 0x00, 0x66, 0xff, 0x8a, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xd5, 0x00, 0x66, 0xff, 0x8a, 0x00, 0x66, 0xff, 0xd9, 0x00, 0x64,
  0xff, 0x1c, 0x00, 0x70, 0xff, 0x10, 0x00, 0x63, 0xff, 0x4d, 0x00, 0x67,
  0xff, 0xbd, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x66, 0xff, 0xea, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xcf, 0x00, 0x66,
  0xff, 0xaf, 0x00, 0x66, 0xff, 0xf4, 0x00, 0x69, 0xff, 0x38, 0x00, 0x66,
  0xff, 0x41, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0xc2, 0x00, 0x68, 0xff, 0x16, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x67,
  0xff, 0xa9, 0x00, 0x66, 0xff, 0xcd, 0x00, 0x62, 0xff, 0x1a, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65,
  0xff, 0x9a, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x64,
  0xff, 0x17, 0x00, 0x66, 0xff, 0x7d, 0x00, 0x64, 0xff, 0x1c, 0x00, 0x66,
  0xff, 0xd7, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xc0, 0x00, 0x65,
  0xff, 0xb8, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xf4, 0x00, 0x65, 0xff, 0xa7, 0x00, 0x67, 0xff, 0x68, 0x00, 0x60,
  0xff, 0x10, 0x00, 0x68, 0xff, 0x1b, 0x00, 0x66, 0xff, 0xcb, 0x00, 0x66,
  0xff, 0xd7, 0x00, 0x65, 0xff, 0xb5, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x66, 0xff, 0xf9, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66,
  0xff, 0xaf, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x60,
  0xff, 0x18, 0x00, 0x66, 0xff, 0xc6, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xea, 0x00, 0x63, 0xff, 0x24, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
  0xff, 0x40, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x65, 0xff, 0x58, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0xff, 0x18, 0x00, 0x66,
  0xff, 0xf0, 0x00, 0x66, 0xff, 0xc0, 0x00, 0x6a, 0xff, 0x24, 0x00, 0x66,
  0xff, 0x96, 0x00, 0x65, 0xff, 0xca, 0x00, 0x68, 0xff, 0x1b, 0x00, 0x66,
  0xff, 0xd7, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x9c, 0x00, 0x66, 0xff, 0xe3, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xc1, 0x00, 0x63, 0xff, 0x3b, 0x00, 0x66,
  0xff, 0xaa, 0x00, 0x67, 0xff, 0x4d, 0x00, 0x64, 0xff, 0x45, 0x00, 0x66,
  0xff, 0x8e, 0x00, 0x66, 0xff, 0xee, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfe, 0x00, 0x65, 0xff, 0xb1, 0x00, 0x66, 0xff, 0xcd, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66,
  0xff, 0xaf, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xf1, 0x00, 0x68,
  0xff, 0x1b, 0x00, 0x66, 0xff, 0x8e, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66, 0xff, 0x37, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62,
  0xff, 0x1a, 0x00, 0x66, 0xff, 0xcb, 0x00, 0x66, 0xff, 0xc3, 0x00, 0x00,
  0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xff, 0x6d, 0x00, 0x66,
  0xff, 0xfc, 0x00, 0x66, 0xff, 0x80, 0x00, 0x65, 0xff, 0x8e, 0x00, 0x66,
  0xff, 0xfa, 0x00, 0x66, 0xff, 0xda, 0x00, 0x66, 0xff, 0x1e, 0x00, 0x65,
  0xff, 0xc4, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xe0, 0x00, 0x66, 0xff, 0xb2, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xfb, 0x00, 0x65, 0xff, 0x81, 0x00, 0x66,
  0xff, 0xee, 0x00, 0x67, 0xff, 0xb8, 0x00, 0x66, 0xff, 0x19, 0x00, 0x66,
  0xff, 0xcd, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xee, 0x00, 0x67, 0xff, 0x52, 0x00, 0x66, 0xff, 0xbc, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66,
  0xff, 0xaf, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x63,
  0xff, 0x5a, 0x00, 0x67, 0xff, 0x63, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0x50, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d,
  0xff, 0x07, 0x00, 0x65, 0xff, 0x95, 0x00, 0x66, 0xff, 0xfb, 0x00, 0x60,
  0xff, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0xff, 0x04, 0x00, 0x67, 0xff, 0xc2, 0x00, 0x66,
  0xff, 0xee, 0x00, 0x66, 0xff, 0x9d, 0x00, 0x65, 0xff, 0xef, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xe4, 0x00, 0x62, 0xff, 0x22, 0x00, 0x66,
  0xff, 0xa3, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xf7, 0x00, 0x66, 0xff, 0x9d, 0x00, 0x66, 0xff, 0xe1, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xeb, 0x00, 0x66,
  0xff, 0x87, 0x00, 0x66, 0xff, 0xdd, 0x00, 0x65, 0xff, 0x8d, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xc4, 0x00, 0x66, 0xff, 0x8a, 0x00, 0x66, 0xff, 0xd3, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x65,
  0xff, 0xa7, 0x00, 0x67, 0xff, 0xe7, 0x00, 0x66, 0xff, 0xda, 0x00, 0x67,
  0xff, 0x72, 0x00, 0x64, 0xff, 0x21, 0x00, 0x65, 0xff, 0x62, 0x00, 0x67,
  0xff, 0x54, 0x00, 0x66, 0xff, 0x50, 0x00, 0x66, 0xff, 0x1e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x65, 0xff, 0x65, 0x00, 0x66, 0xff, 0xf6, 0x00, 0x66,
  0xff, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x28, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x66,
  0xff, 0xe0, 0x00, 0x65, 0xff, 0x92, 0x00, 0x66, 0xff, 0xf9, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x64, 0xff, 0x33, 0x00, 0x65,
  0xff, 0x6f, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xbf, 0x00, 0x63, 0xff, 0x3b, 0x00, 0x65, 0xff, 0x8d, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xae, 0x00, 0x66, 0xff, 0x73, 0x00, 0x66, 0xff, 0xe1, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xeb, 0x00, 0x66,
  0xff, 0x8c, 0x00, 0x66, 0xff, 0xc8, 0x00, 0x66, 0xff, 0xd4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x64,
  0xff, 0x40, 0x00, 0x67, 0xff, 0x3e, 0x00, 0x68, 0xff, 0x31, 0x00, 0x66,
  0xff, 0x37, 0x00, 0x66, 0xff, 0x0f, 0x00, 0x65, 0xff, 0x68, 0x00, 0x66,
  0xff, 0x80, 0x00, 0x66, 0xff, 0x82, 0x00, 0x63, 0xff, 0x2c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x68, 0xff, 0x3b, 0x00, 0x66, 0xff, 0xe8, 0x00, 0x66,
  0xff, 0xc8, 0x00, 0x6d, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x52, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x66,
  0xff, 0xcb, 0x00, 0x66, 0xff, 0x6c, 0x00, 0x66, 0xff, 0xf7, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67, 0xff, 0x61, 0x00, 0x65,
  0xff, 0x35, 0x00, 0x66, 0xff, 0xf9, 0x00, 0x66, 0xff, 0xd3, 0x00, 0x66,
  0xff, 0x23, 0x00, 0x67, 0xff, 0x83, 0x00, 0x67, 0xff, 0x9a, 0x00, 0x66,
  0xff, 0xd4, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xf0, 0x00, 0x65, 0xff, 0xcc, 0x00, 0x66, 0xff, 0xfb, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0x8a, 0x00, 0x66,
  0xff, 0xe8, 0x00, 0x65, 0xff, 0xcf, 0x00, 0x66, 0xff, 0xd4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x65,
  0xff, 0x56, 0x00, 0x65, 0xff, 0xbf, 0x00, 0x66, 0xff, 0xdf, 0x00, 0x66,
  0xff, 0xc5, 0x00, 0x66, 0xff, 0x23, 0x00, 0x66, 0xff, 0xdb, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67, 0xff, 0x48, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x68, 0xff, 0x16, 0x00, 0x66, 0xff, 0xdc, 0x00, 0x66,
  0xff, 0xe1, 0x00, 0x62, 0xff, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x75, 0x00, 0x66, 0xff, 0xfb, 0x00, 0x66,
  0xff, 0x9e, 0x00, 0x64, 0xff, 0x54, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xac, 0x00, 0x66,
  0xff, 0x19, 0x00, 0x67, 0xff, 0xa8, 0x00, 0x6a, 0xff, 0x30, 0x00, 0x66,
  0xff, 0x66, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x66, 0xff, 0xfc, 0x00, 0x65,
  0xff, 0x81, 0x00, 0x65, 0xff, 0xf7, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0xcc, 0x00, 0x67, 0xff, 0x34, 0x00, 0x66,
  0xff, 0xda, 0x00, 0x65, 0xff, 0x88, 0x00, 0x66, 0xff, 0xc3, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66,
  0xff, 0xaf, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xda, 0x00, 0x61, 0xff, 0x2a, 0x00, 0x66, 0xff, 0xdd, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0xf9, 0x00, 0x67, 0xff, 0x2a, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xc5, 0x00, 0x66,
  0xff, 0xee, 0x00, 0x65, 0xff, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55,
  0xff, 0x06, 0x00, 0x65, 0xff, 0x92, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67,
  0xff, 0x72, 0x00, 0x67, 0xff, 0x39, 0x00, 0x67, 0xff, 0xe7, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x6a,
  0xff, 0x1d, 0x00, 0x62, 0xff, 0x1a, 0x00, 0x66, 0xff, 0x5f, 0x00, 0x66,
  0xff, 0xf2, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xcc, 0x00, 0x67, 0xff, 0xbd, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xf5, 0x00, 0x65, 0xff, 0x92, 0x00, 0x60, 0xff, 0x10, 0x00, 0x63,
  0xff, 0x24, 0x00, 0x65, 0xff, 0x2b, 0x00, 0x67, 0xff, 0xb7, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66,
  0xff, 0xaf, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xd9, 0x00, 0x61, 0xff, 0x2a, 0x00, 0x66, 0xff, 0xde, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xda, 0x00, 0x66, 0xff, 0x1e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x9e, 0x00, 0x66,
  0xff, 0xf7, 0x00, 0x66, 0xff, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x0f, 0x00, 0x65, 0xff, 0xab, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x53, 0x00, 0x61, 0xff, 0x15, 0x00, 0x66, 0xff, 0xdb, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x5d, 0x00, 0x66, 0xff, 0x23, 0x00, 0x66, 0xff, 0xd8, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xf4, 0x00, 0x65, 0xff, 0xab, 0x00, 0x66, 0xff, 0xed, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xd2, 0x00, 0x64, 0xff, 0x33, 0x00, 0x66, 0xff, 0x0a, 0x00, 0x71,
  0xff, 0x09, 0x00, 0x66, 0xff, 0x67, 0x00, 0x67, 0xff, 0xc7, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66,
  0xff, 0xb1, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xd4, 0x00, 0x61, 0xff, 0x2a, 0x00, 0x66, 0xff, 0xe1, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0xb0, 0x00, 0x60, 0xff, 0x10, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xff, 0x7c, 0x00, 0x66,
  0xff, 0xfe, 0x00, 0x66, 0xff, 0x80, 0x00, 0x00, 0xff, 0x01, 0x00, 0x66,
  0xff, 0x14, 0x00, 0x66, 0xff, 0xbb, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xa5, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xce, 0x00, 0x66,
  0xff, 0x0f, 0x00, 0x62, 0xff, 0x0d, 0x00, 0x67, 0xff, 0xa4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xc3, 0x00, 0x65, 0xff, 0xc2, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x67,
  0xff, 0x52, 0x00, 0x64, 0xff, 0x29, 0x00, 0x66, 0xff, 0xbe, 0x00, 0x65,
  0xff, 0x4e, 0x00, 0x6a, 0xff, 0x18, 0x00, 0x66, 0xff, 0xad, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xc6, 0x00, 0x65,
  0xff, 0xc4, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xb7, 0x00, 0x63, 0xff, 0x3e, 0x00, 0x66, 0xff, 0xe9, 0x00, 0x67,
  0xff, 0xfb, 0x00, 0x66, 0xff, 0x7b, 0x00, 0x80, 0xff, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x69, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x67, 0xff, 0x92, 0x00, 0x80, 0xff, 0x06, 0x00, 0x6a,
  0xff, 0x18, 0x00, 0x66, 0xff, 0xc8, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x41, 0x00, 0x66,
  0xff, 0xfd, 0x00, 0x65, 0xff, 0xea, 0x00, 0x68, 0xff, 0x40, 0x00, 0x66,
  0xff, 0x6b, 0x00, 0x65, 0xff, 0x6d, 0x00, 0x63, 0xff, 0x24, 0x00, 0x66,
  0xff, 0xd8, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x65, 0xff, 0xa4, 0x00, 0x65,
  0xff, 0xc4, 0x00, 0x65, 0xff, 0xe0, 0x00, 0x66, 0xff, 0x8e, 0x00, 0x66,
  0xff, 0x41, 0x00, 0x66, 0xff, 0xcb, 0x00, 0x65, 0xff, 0xfe, 0x00, 0x66,
  0xff, 0xd3, 0x00, 0x65, 0xff, 0x26, 0x00, 0x65, 0xff, 0x44, 0x00, 0x66,
  0xff, 0xd0, 0x00, 0x66, 0xff, 0xd9, 0x00, 0x66, 0xff, 0x96, 0x00, 0x66,
  0xff, 0xf3, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x64,
  0xff, 0x84, 0x00, 0x64, 0xff, 0x5e, 0x00, 0x65, 0xff, 0xf4, 0x00, 0x66,
  0xff, 0xe7, 0x00, 0x66, 0xff, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0xff, 0x57, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0x9f, 0x00, 0x5d, 0xff, 0x0b, 0x00, 0x68,
  0xff, 0x1b, 0x00, 0x65, 0xff, 0xcf, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x04, 0x00, 0x66,
  0xff, 0xc1, 0x00, 0x67, 0xff, 0x95, 0x00, 0x64, 0xff, 0x33, 0x00, 0x66,
  0xff, 0xf2, 0x00, 0x66, 0xff, 0xda, 0x00, 0x69, 0xff, 0x22, 0x00, 0x65,
  0xff, 0x44, 0x00, 0x66, 0xff, 0xee, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x66,
  0xff, 0xc1, 0x00, 0x67, 0xff, 0x39, 0x00, 0x66, 0xff, 0x4b, 0x00, 0x66,
  0xff, 0xe7, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfb, 0x00, 0x66, 0xff, 0x89, 0x00, 0x71, 0xff, 0x09, 0x00, 0x69,
  0xff, 0x22, 0x00, 0x66, 0xff, 0x37, 0x00, 0x65, 0xff, 0xc5, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x64,
  0xff, 0x42, 0x00, 0x65, 0xff, 0x88, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x67,
  0xff, 0xae, 0x00, 0x66, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x5a, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0x9f, 0x00, 0x5d, 0xff, 0x0b, 0x00, 0x62,
  0xff, 0x1a, 0x00, 0x66, 0xff, 0xcd, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67,
  0xff, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
  0xff, 0x2e, 0x00, 0x65, 0xff, 0x3f, 0x00, 0x66, 0xff, 0xb9, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xb1, 0x00, 0x6b,
  0xff, 0x13, 0x00, 0x66, 0xff, 0x73, 0x00, 0x66, 0xff, 0xf3, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xf9, 0x00, 0x66,
  0xff, 0x7a, 0x00, 0x64, 0xff, 0x3d, 0x00, 0x66, 0xff, 0xe4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xe6, 0x00, 0x65, 0xff, 0x5d, 0x00, 0x66,
  0xff, 0xed, 0x00, 0x66, 0xff, 0xf1, 0x00, 0x66, 0xff, 0x94, 0x00, 0x66,
  0xff, 0xf8, 0x00, 0x66, 0xff, 0xf4, 0x00, 0x66, 0xff, 0xd2, 0x00, 0x66,
  0xff, 0x0a, 0x00, 0x66, 0xff, 0x41, 0x00, 0x66, 0xff, 0x46, 0x00, 0x69,
  0xff, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x6c, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0x9f, 0x00, 0x5d, 0xff, 0x0b, 0x00, 0x68,
  0xff, 0x16, 0x00, 0x66, 0xff, 0xc0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x65, 0xff, 0x49, 0x00, 0x66, 0xff, 0xed, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x98, 0x00, 0x61, 0xff, 0x1d, 0x00, 0x66, 0xff, 0x76, 0x00, 0x66,
  0xff, 0xf3, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66, 0xff, 0x93, 0x00, 0x65,
  0xff, 0x26, 0x00, 0x66, 0xff, 0xc5, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xdd, 0x00, 0x66, 0xff, 0xc8, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x66,
  0xff, 0x87, 0x00, 0x65, 0xff, 0x62, 0x00, 0x66, 0xff, 0x1e, 0x00, 0x68,
  0xff, 0x20, 0x00, 0x65, 0xff, 0x65, 0x00, 0x61, 0xff, 0x15, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x7f, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0x98, 0x00, 0x60, 0xff, 0x08, 0x00, 0x69,
  0xff, 0x11, 0x00, 0x66, 0xff, 0xb1, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67,
  0xff, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x6a, 0xff, 0x29, 0x00, 0x66, 0xff, 0xdf, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0xf9, 0x00, 0x66, 0xff, 0x93, 0x00, 0x63, 0xff, 0x12, 0x00, 0x65,
  0xff, 0x4e, 0x00, 0x65, 0xff, 0xa7, 0x00, 0x6a, 0xff, 0x1d, 0x00, 0x66,
  0xff, 0xaf, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xf0, 0x00, 0x67, 0xff, 0xa9, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x66,
  0xff, 0x14, 0x00, 0x65, 0xff, 0x4e, 0x00, 0x60, 0xff, 0x10, 0x00, 0x66,
  0xff, 0x9b, 0x00, 0x66, 0xff, 0x9e, 0x00, 0x6d, 0xff, 0x0e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0x87, 0x00, 0x55, 0xff, 0x03, 0x00, 0x66,
  0xff, 0x0a, 0x00, 0x66, 0xff, 0x9d, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67,
  0xff, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x46, 0x00, 0x66,
  0xff, 0xed, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xa6, 0x00, 0x62,
  0xff, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x4b, 0x00, 0x66,
  0xff, 0xef, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xc5, 0x00, 0x65,
  0xff, 0x77, 0x00, 0x66, 0xff, 0x73, 0x00, 0x6a, 0xff, 0x24, 0x00, 0x67,
  0xff, 0xce, 0x00, 0x67, 0xff, 0x8b, 0x00, 0x67, 0xff, 0x3e, 0x00, 0x66,
  0xff, 0xc8, 0x00, 0x66, 0xff, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0xff, 0x02, 0x00, 0x66, 0xff, 0xcb, 0x00, 0x67,
  0xff, 0xfb, 0x00, 0x67, 0xff, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0xff, 0x02, 0x00, 0x66, 0xff, 0x7f, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x65,
  0xff, 0xc9, 0x00, 0x66, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67,
  0xff, 0x52, 0x00, 0x65, 0xff, 0xdb, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x92, 0x00, 0x63, 0xff, 0x12, 0x00, 0x63, 0xff, 0x12, 0x00, 0x65,
  0xff, 0x53, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x66, 0xff, 0xe4, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x67, 0xff, 0x8d, 0x00, 0x67,
  0xff, 0x25, 0x00, 0x66, 0xff, 0x5a, 0x00, 0x69, 0xff, 0x11, 0x00, 0x66,
  0xff, 0x7b, 0x00, 0x65, 0xff, 0x3f, 0x00, 0x65, 0xff, 0x77, 0x00, 0x66,
  0xff, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x1c, 0x00, 0x66, 0xff, 0xde, 0x00, 0x66,
  0xff, 0xf1, 0x00, 0x65, 0xff, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x67, 0xff, 0x5c, 0x00, 0x66, 0xff, 0xf3, 0x00, 0x66,
  0xff, 0xe0, 0x00, 0x63, 0xff, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55,
  0xff, 0x03, 0x00, 0x68, 0xff, 0x40, 0x00, 0x66, 0xff, 0xdd, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65, 0xff, 0xfe, 0x00, 0x68,
  0xff, 0x3b, 0x00, 0x67, 0xff, 0x83, 0x00, 0x66, 0xff, 0xc1, 0x00, 0x66,
  0xff, 0x4b, 0x00, 0x60, 0xff, 0x10, 0x00, 0x62, 0xff, 0x22, 0x00, 0x65,
  0xff, 0x53, 0x00, 0x66, 0xff, 0x9b, 0x00, 0x66, 0xff, 0xd2, 0x00, 0x66,
  0xff, 0xee, 0x00, 0x66, 0xff, 0x93, 0x00, 0x68, 0xff, 0x16, 0x00, 0x66,
  0xff, 0xb4, 0x00, 0x66, 0xff, 0xc6, 0x00, 0x65, 0xff, 0x30, 0x00, 0x6d,
  0xff, 0x07, 0x00, 0x63, 0xff, 0x12, 0x00, 0x69, 0xff, 0x11, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x67, 0xff, 0x43, 0x00, 0x66, 0xff, 0xeb, 0x00, 0x65,
  0xff, 0xe5, 0x00, 0x68, 0xff, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x64, 0xff, 0x33, 0x00, 0x66, 0xff, 0xe5, 0x00, 0x66,
  0xff, 0xf0, 0x00, 0x67, 0xff, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xff, 0x15, 0x00, 0x66,
  0xff, 0xa8, 0x00, 0x66, 0xff, 0xee, 0x00, 0x65, 0xff, 0xae, 0x00, 0x67,
  0xff, 0x25, 0x00, 0x66, 0xff, 0xde, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xfd, 0x00, 0x66, 0xff, 0xd0, 0x00, 0x65, 0xff, 0x74, 0x00, 0x69,
  0xff, 0x2e, 0x00, 0x6a, 0xff, 0x1d, 0x00, 0x6b, 0xff, 0x13, 0x00, 0x80,
  0xff, 0x02, 0x00, 0x66, 0xff, 0x05, 0x00, 0x74, 0xff, 0x0b, 0x00, 0x69,
  0xff, 0x11, 0x00, 0x66, 0xff, 0x14, 0x00, 0x66, 0xff, 0x05, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xff, 0x01, 0x00, 0x67, 0xff, 0x72, 0x00, 0x66, 0xff, 0xf9, 0x00, 0x66,
  0xff, 0xd3, 0x00, 0x5b, 0xff, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x0a, 0x00, 0x65, 0xff, 0xc9, 0x00, 0x66,
  0xff, 0xfd, 0x00, 0x65, 0xff, 0x86, 0x00, 0x66, 0xff, 0x05, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d,
  0xff, 0x07, 0x00, 0x65, 0xff, 0x4c, 0x00, 0x65, 0xff, 0x30, 0x00, 0x66,
  0xff, 0x64, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xf7, 0x00, 0x66, 0xff, 0xd5, 0x00, 0x66, 0xff, 0xa2, 0x00, 0x60,
  0xff, 0x10, 0x00, 0x65, 0xff, 0x6a, 0x00, 0x66, 0xff, 0x9e, 0x00, 0x65,
  0xff, 0x81, 0x00, 0x66, 0xff, 0x4b, 0x00, 0x66, 0xff, 0x0f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62,
  0xff, 0x0d, 0x00, 0x65, 0xff, 0xa7, 0x00, 0x66, 0xff, 0xff, 0x00, 0x65,
  0xff, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x7b, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x65, 0xff, 0xc2, 0x00, 0x68, 0xff, 0x16, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x19, 0x00, 0x66, 0xff, 0x5f, 0x00, 0x66, 0xff, 0xaa, 0x00, 0x66,
  0xff, 0xe2, 0x00, 0x66, 0xff, 0xfe, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66,
  0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67, 0xff, 0x6d, 0x00, 0x68,
  0xff, 0x1b, 0x00, 0x64, 0xff, 0x80, 0x00, 0x66, 0xff, 0x41, 0x00, 0x68,
  0xff, 0x1b, 0x00, 0x55, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64,
  0xff, 0x21, 0x00, 0x66, 0xff, 0xe2, 0x00, 0x66, 0xff, 0xff, 0x00, 0x67,
  0xff, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x19, 0x00, 0x67,
  0xff, 0xf6, 0x00, 0x66, 0xff, 0xf9, 0x00, 0x66, 0xff, 0x3c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x62, 0xff, 0x0d, 0x00, 0x65, 0xff, 0x26, 0x00, 0x67,
  0xff, 0x2f, 0x00, 0x68, 0xff, 0x1b, 0x00, 0x55, 0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x6b, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xce, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x9d, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0xaf, 0x00, 0x00,
  0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0xff, 0x0e, 0x00, 0x66,
  0xff, 0xda, 0x00, 0x66, 0xff, 0xfb, 0x00, 0x67, 0xff, 0x5c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68,
  0xff, 0x31, 0x00, 0x66, 0xff, 0xee, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x64,
  0xff, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x73, 0x00, 0x66,
  0xff, 0xfe, 0x00, 0x66, 0xff, 0xcb, 0x00, 0x68, 0xff, 0x1b, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62,
  0xff, 0x0d, 0x00, 0x66, 0xff, 0xa0, 0x00, 0x65, 0xff, 0xfe, 0x00, 0x65,
  0xff, 0xbd, 0x00, 0x66, 0xff, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x1e, 0x00, 0x65, 0xff, 0xdb, 0x00, 0x66,
  0xff, 0xfa, 0x00, 0x66, 0xff, 0x78, 0x00, 0x55, 0xff, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x67, 0xff, 0x43, 0x00, 0x66, 0xff, 0xea, 0x00, 0x66,
  0xff, 0xf1, 0x00, 0x66, 0xff, 0x5a, 0x00, 0x80, 0xff, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55,
  0xff, 0x06, 0x00, 0x66, 0xff, 0x7d, 0x00, 0x66, 0xff, 0xf8, 0x00, 0x66,
  0xff, 0xd4, 0x00, 0x62, 0xff, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x66, 0xff, 0x05, 0x00, 0x65, 0xff, 0x95, 0x00, 0x66,
  0xff, 0xfe, 0x00, 0x66, 0xff, 0xc1, 0x00, 0x68, 0xff, 0x16, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x55, 0xff, 0x06, 0x00, 0x69, 0xff, 0x2e, 0x00, 0x66,
  0xff, 0x55, 0x00, 0x66, 0xff, 0x76, 0x00, 0x64, 0xff, 0x84, 0x00, 0x67,
  0xff, 0x90, 0x00, 0x66, 0xff, 0x94, 0x00, 0x66, 0xff, 0x85, 0x00, 0x67,
  0xff, 0x7c, 0x00, 0x67, 0xff, 0x59, 0x00, 0x66, 0xff, 0x32, 0x00, 0x55,
  0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0xff, 0x0c, 0x00, 0x68,
  0xff, 0x3b, 0x00, 0x67, 0xff, 0x61, 0x00, 0x65, 0xff, 0x81, 0x00, 0x66,
  0xff, 0x8e, 0x00, 0x65, 0xff, 0x90, 0x00, 0x65, 0xff, 0x90, 0x00, 0x65,
  0xff, 0x88, 0x00, 0x65, 0xff, 0x72, 0x00, 0x64, 0xff, 0x4f, 0x00, 0x65,
  0xff, 0x26, 0x00, 0x55, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x28, 0x00, 0x66, 0xff, 0xe0, 0x00, 0x66, 0xff, 0xff, 0x00, 0x64,
  0xff, 0x5c, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xff, 0x0f, 0x00, 0x66,
  0xff, 0xdb, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xff, 0x9d, 0x00, 0x66,
  0xff, 0xb1, 0x00, 0x66, 0xff, 0xed, 0x00, 0x66, 0xff, 0xf7, 0x00, 0x66,
  0xff, 0xf1, 0x00, 0x66, 0xff, 0xec, 0x00, 0x66, 0xff, 0xe9, 0x00, 0x66,
  0xff, 0xe8, 0x00, 0x66, 0xff, 0xe9, 0x00, 0x66, 0xff, 0xeb, 0x00, 0x66,
  0xff, 0xef, 0x00, 0x66, 0xff, 0xf6, 0x00, 0x66, 0xff, 0xfd, 0x00, 0x66,
  0xff, 0xf5, 0x00, 0x66, 0xff, 0xb9, 0x00, 0x65, 0xff, 0x65, 0x00, 0x67,
  0xff, 0x77, 0x00, 0x67, 0xff, 0xc7, 0x00, 0x66, 0xff, 0xfa, 0x00, 0x66,
  0xff, 0xfc, 0x00, 0x66, 0xff, 0xf4, 0x00, 0x66, 0xff, 0xee, 0x00, 0x65,
  0xff, 0xea, 0x00, 0x66, 0xff, 0xe9, 0x00, 0x66, 0xff, 0xe8, 0x00, 0x66,
  0xff, 0xea, 0x00, 0x66, 0xff, 0xed, 0x00, 0x66, 0xff, 0xf2, 0x00, 0x66,
  0xff, 0xf8, 0x00, 0x66, 0xff, 0xe7, 0x00, 0x65, 0xff, 0xa4, 0x00, 0x66,
  0xff, 0xbc, 0x00, 0x65, 0xff, 0xfe, 0x00, 0x66, 0xff, 0xa8, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68,
  0xff, 0x47, 0x00, 0x66, 0xff, 0xe1, 0x00, 0x66, 0xff, 0xcf, 0x00, 0x66,
  0xff, 0xa5, 0x00, 0x65, 0xff, 0x83, 0x00, 0x65, 0xff, 0x68, 0x00, 0x66,
  0xff, 0x55, 0x00, 0x67, 0xff, 0x45, 0x00, 0x65, 0xff, 0x3f, 0x00, 0x66,
  0xff, 0x3c, 0x00, 0x67, 0xff, 0x3e, 0x00, 0x65, 0xff, 0x44, 0x00, 0x65,
  0xff, 0x51, 0x00, 0x66, 0xff, 0x64, 0x00, 0x65, 0xff, 0x7e, 0x00, 0x66,
  0xff, 0x9e, 0x00, 0x65, 0xff, 0xc7, 0x00, 0x66, 0xff, 0xf5, 0x00, 0x66,
  0xff, 0xec, 0x00, 0x66, 0xff, 0xbb, 0x00, 0x65, 0xff, 0x97, 0x00, 0x66,
  0xff, 0x75, 0x00, 0x66, 0xff, 0x5f, 0x00, 0x65, 0xff, 0x4e, 0x00, 0x64,
  0xff, 0x40, 0x00, 0x64, 0xff, 0x3d, 0x00, 0x66, 0xff, 0x3c, 0x00, 0x66,
  0xff, 0x41, 0x00, 0x65, 0xff, 0x49, 0x00, 0x67, 0xff, 0x59, 0x00, 0x65,
  0xff, 0x6d, 0x00, 0x66, 0xff, 0x8a, 0x00, 0x67, 0xff, 0xae, 0x00, 0x66,
  0xff, 0xda, 0x00, 0x66, 0xff, 0xcd, 0x00, 0x65, 0xff, 0x26, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
  0xff, 0x05, 0x00, 0x64, 0xff, 0x21, 0x00, 0x68, 0xff, 0x1b, 0x00, 0x62,
  0xff, 0x0d, 0x00, 0x55, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x66,
  0xff, 0x0a, 0x00, 0x6a, 0xff, 0x18, 0x00, 0x64, 0xff, 0x2e, 0x00, 0x67,
  0xff, 0x25, 0x00, 0x66, 0xff, 0x14, 0x00, 0x60, 0xff, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0xff, 0x04, 0x00, 0x60, 0xff, 0x10, 0x00, 0x66,
  0xff, 0x1e, 0x00, 0x68, 0xff, 0x1b, 0x00, 0x80, 0xff, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned int favicon_ico_len = 15406;
/*
To create this header file do this:
1. Erstelle die index.html mit allen Infos
2. Nutze xxd zum erstellen der header Datei:
   xxd -i index.html > index_html.h
3. Compilen
4. Info zu template Dateien:
   - BLANK_HTML.template > eine simple HTML Datei ohne irgendwelche ZusĆ¤tze, wird als *.html immer genommen
   - ZERO_HTML.template > eine komplett leere HTML Datei mit 0 bytes
*/

#ifndef HTML_INDEX_H
#define HTML_INDEX_H

unsigned char index_html[] = {};
unsigned int index_html_len = 0;

#endif // HTML_INDEX_H
/*
 * src/sock/socket_handler.h - Socket Handler Main Header
*/

#ifndef SOCKET_HANDLER_H
#define SOCKET_HANDLER_H

#include "../ssl/ssl_modules.h"
#include "../log/logger.h"

/* Buffer sizes */
#define DEFAULT_REPLY SEND_TXT
#define CHAR_BUF_SIZE       4095     /* initial/incremental size of msg buffer */
#define MAX_CHAR_BUF_LOTS   32       /* max msg buffer size in unit of CHAR_BUF_SIZE */
#define MAX_HTTP_POST_LEN   262143   /* max POST Content-Length before discarding */
#define MAX_HTTP_POST_RETRY 3        /* 3 times */

/* Response types enum */
typedef enum {
  FAIL_GENERAL,
  FAIL_TIMEOUT,
  FAIL_CLOSED,
  FAIL_REPLY,
  SEND_GIF,
  SEND_TXT,
  SEND_JPG,
  SEND_PNG,
  SEND_SWF,
  SEND_ICO,
  SEND_BAD,
  SEND_STATS,
  SEND_STATSTEXT,
  SEND_204,
  SEND_REDIRECT,
  SEND_NO_EXT,
  SEND_UNK_EXT,
  SEND_NO_URL,
  SEND_BAD_PATH,
  SEND_POST,
  SEND_HEAD,
  SEND_OPTIONS,
  /* New response types for extended file support */
  SEND_JSON,
  SEND_XML,
  SEND_WEBP,
  SEND_SVG,
  SEND_FONT,
  SEND_VIDEO,
  SEND_AUDIO,
  SEND_PDF,
  SEND_DOC,
  SEND_ZIP,
  SEND_BIN,
  SEND_CSS,
  SEND_HTML,
  /* ASP/Server-side script support */
  SEND_ASP,
  SEND_ASPX,
  SEND_ASHX,
  SEND_PHP,
  SEND_JSP,
  SEND_JS,
  /* Special actions */
  ACTION_LOG_VERB,
  ACTION_DEC_KCC
} response_enum;

/* Response structure */
typedef struct {
    response_enum status;
    union {
        int rx_total;
        int krq;
        logger_level verb;
    };
    double run_time;
    ssl_enum ssl;
    int ssl_ver;
} response_struct;

/* Public functions - Haupteingangspounkt */
void* conn_handler(void *ptr);

/* Enhanced functions for scalability */
void socket_handler_init(void);
void socket_handler_cleanup(void);
void socket_handler_get_metrics(char *buffer, size_t size);

/* Configuration functions */
void socket_handler_set_thread_pool(int enable);
void socket_handler_set_rate_limit(int tokens_per_sec);
void socket_handler_set_memory_pool_size(size_t size);

/* ASP/Server-side script configuration */
void socket_handler_set_asp_config(int enable_logging, int enable_mime, const char *charset);

#endif /* SOCKET_HANDLER_H */
/*
 * src/sock/socket_io.h - Socket I/O Operations Header
 */

#ifndef SOCKET_IO_H
#define SOCKET_IO_H

#include <openssl/ssl.h>
#include "../sock/socket_handler.h"

/* Socket I/O Functions */
int peek_socket(int fd, SSL *ssl);
int ssl_read(SSL *ssl, char *buf, int len);
int read_socket(int fd, char **msg, SSL *ssl, char *early_data);
int ssl_write(SSL *ssl, const char *buf, int len);
int write_socket(int fd, const char *msg, int msg_len, SSL *ssl, char **early_data);
int write_pipe(int fd, response_struct *pipedata);

#endif /* SOCKET_IO_H */
/*
 * src/comm/connection_handler.h - Connection Management Header
*/

#ifndef CONNECTION_HANDLER_H
#define CONNECTION_HANDLER_H

#include "../sock/socket_handler.h"

/* Connection Management */
void* conn_handler(void *ptr);

/* Time measurement macros */
#ifdef DEBUG
#define TIME_CHECK(x) {\
  if (do_warning) {\
    do_warning = 0;\
    double time_msec = 0.0;\
    time_msec = elapsed_time_msec(start_time);\
    if (time_msec > warning_time) {\
      log_msg(LGG_DEBUG, "Elapsed time %f msec exceeded warning_time=%d msec following operation: %s", time_msec, warning_time, x);\
    }\
  }\
}

#define ELAPSED_TIME(op) {\
    double time_msec = 0.0;\
    time_msec = elapsed_time_msec(start_time);\
    log_msg(LGG_DEBUG, "Elapsed time %f msec following operation: %s", time_msec, op);\
}
#else
#define TIME_CHECK(x,y...)
#define ELAPSED_TIME(x,y...)
#endif //DEBUG

#endif /* CONNECTION_HANDLER_H */
/*
 * src/comm/request_processor.h - HTTP Request Processing Header
*/

#ifndef REQUEST_PROCESSOR_H
#define REQUEST_PROCESSOR_H

#include "../sock/socket_handler.h"

/* Request Processing Functions */
response_enum process_get_request(char *path, char *host, char **response, int *rsize, 
                                  char **aspbuf, int allow_admin, 
                                  const char *stats_url, const char *stats_text_url,
                                  const char *pem_dir, int argc, char **argv,
                                  int do_204, int do_redirect, char *bufptr,
                                  char *cors_origin);

response_enum handle_file_extension(char *file, char **response, int *rsize);

#endif /* REQUEST_PROCESSOR_H */
/*
 * src/main/signal_handler.h
 * Location: ./src/main/signal_handler.h
 * 
 * Header file for signal handling functionality
*/

#ifndef SIGNAL_HANDLER_H
#define SIGNAL_HANDLER_H

void signal_handler(int sig);
void setup_signal_handlers(void);

#endif
/*
 * src/main/server_init.h
 * Location: ./src/main/server_init.h
 * 
 * Header file for server initialization functionality
*/

#ifndef SERVER_INIT_H
#define SERVER_INIT_H

#include <pthread.h>
#include "../ssl/ssl_modules.h"

int initialize_server(const char *tls_pem, int cert_cache_size, int max_num_threads, 
                     int do_benchmark, cert_tlstor_t *cert_tlstor, char *bm_cert, 
                     pthread_t *certgen_thread);
void cleanup_server(void);

#endif
/*
* connection_loop.h
* Location: ./src/main/connection_loop.h
* 
* Header file for main connection loop functionality
*/

#ifndef CONNECTION_LOOP_H
#define CONNECTION_LOOP_H

void run_connection_loop(char *ip_addr, int use_ip, char *ports[], int num_ports, int max_num_threads,
                        struct Global *global_config
#ifdef IF_MODE
  , char *ifname, int use_if
#endif
);

#endif
/*
 * src/util/util.h - Enhanced Configuration for High-Performance Memory Management
 * 
 * Optimized for 2-3M concurrent users with DOS client support
 */

#ifndef UTIL_H
#define UTIL_H

#define _GNU_SOURCE

// Enhanced includes for high-performance operations
#include <stddef.h>
#include <stdlib.h>
#include <stdatomic.h>      // C11 atomic operations
#include <errno.h>
#include <netdb.h>
#include <netinet/tcp.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <time.h>
#include <arpa/inet.h>
#include <sys/mman.h>       // for mmap operations

#ifdef linux
#include <linux/version.h>
#include <sys/epoll.h>
#include <numa.h>           // NUMA support (if available)
#endif

#include <openssl/ssl.h>

// =============================================================================
// PERFORMANCE CONFIGURATION
// =============================================================================

#define VERSION "1.0.0-optimized"

// High-Performance Memory Pool Settings
#define MEMORY_POOL_SLOTS           8192        // Lock-free pool slots
#define CONNECTION_POOL_SIZE        3000000     // 3M concurrent connections
#define BUFFER_POOL_SIZES           8           // Different buffer size classes
#define SSL_CONTEXT_CACHE_SIZE      10000       // SSL context cache entries

// NUMA Configuration
#define MAX_NUMA_NODES              8           // Maximum NUMA nodes
#define NUMA_AWARE_POOLS            1           // Enable NUMA-aware allocation

// Buffer Size Classes (optimized for different client types)
#define BUFFER_SIZE_TINY            512         // DOS clients, small requests
#define BUFFER_SIZE_SMALL           1024        // DOS clients, normal requests
#define BUFFER_SIZE_MEDIUM          4096        // Modern clients, normal requests
#define BUFFER_SIZE_LARGE           16384       // Modern clients, large requests
#define BUFFER_SIZE_HUGE            65536       // Modern clients, very large requests
#define BUFFER_SIZE_MASSIVE         262144      // Special cases, file uploads

// DOS Client Specific Settings
#define DOS_BUFFER_POOL_SIZE        1000        // Dedicated DOS buffer pool
#define DOS_SSL_CONTEXT_CACHE       500         // DOS-specific SSL contexts
#define DOS_CONNECTION_LIMIT        50000       // Max DOS clients simultaneously
#define DOS_DETECTION_THRESHOLD     3           // Packets to analyze for DOS detection

// Lock-free Configuration
#define ATOMIC_QUEUE_SIZE           16384       // Size of atomic queues
#define MEMORY_ALIGNMENT            64          // Cache line alignment
#define PREFETCH_DISTANCE           2           // Cache prefetch distance

// Thread Pool Optimization
#define WORKER_THREAD_COUNT         64          // Worker threads
#define WORKER_STACK_SIZE           (128*1024)  // Reduced stack size
#define THREAD_AFFINITY_ENABLED     1           // CPU affinity for threads

// =============================================================================
// MEMORY POOL STRUCTURES
// =============================================================================

// Lock-free memory pool entry
typedef struct memory_slot {
    atomic_intptr_t next;       // Next free slot (atomic pointer)
    char data[];                // Actual memory block
} memory_slot_t;

// NUMA-aware memory pool
typedef struct numa_pool {
    memory_slot_t *slots;       // Memory slots
    atomic_intptr_t free_head;  // Head of free list (lock-free)
    atomic_int free_count;      // Number of free slots
    size_t slot_size;          // Size of each slot
    int numa_node;             // NUMA node ID
    char padding[MEMORY_ALIGNMENT]; // Cache line padding
} numa_pool_t;

// Multi-size buffer pool manager
typedef struct buffer_pool_manager {
    numa_pool_t pools[MAX_NUMA_NODES][BUFFER_POOL_SIZES];
    atomic_long allocation_stats[BUFFER_POOL_SIZES];
    atomic_long deallocation_stats[BUFFER_POOL_SIZES];
    int numa_nodes;
    char padding[MEMORY_ALIGNMENT];
} buffer_pool_manager_t;

// DOS client information (enhanced)
typedef struct {
    atomic_int is_dos_client;
    atomic_int use_small_buffers;
    atomic_int legacy_ssl_mode;
    atomic_long connect_time;
    atomic_int ssl_version_detected;
    atomic_int packet_count;
    char user_agent[256];
    char padding[MEMORY_ALIGNMENT];
} dos_client_info_t;

// Enhanced connection structure with optimized memory layout
typedef struct connection_optimized {
    // Hot data (frequently accessed) - cache line 1
    int fd;
    atomic_int state;
    SSL *ssl;
    dos_client_info_t dos_info;
    
    // Medium access data - cache line 2
    char *buffer;
    atomic_size_t buffer_size;
    atomic_long last_activity;
    int numa_node;
    
    // Cold data (rarely accessed)
    struct sockaddr_storage client_addr;
    socklen_t addr_len;
    char padding[MEMORY_ALIGNMENT];
} connection_optimized_t;

// =============================================================================
// SSL CONTEXT CACHE OPTIMIZATION
// =============================================================================

// Enhanced SSL context cache entry
typedef struct ssl_context_cache_entry {
    char *cert_name;                    // Certificate name
    SSL_CTX *regular_ctx;              // Regular SSL context
    SSL_CTX *dos_ctx;                  // DOS-optimized SSL context
    atomic_long last_use;              // Last access time (atomic)
    atomic_int ref_count;              // Reference count (atomic)
    atomic_int reuse_count;            // Number of times reused
    int is_dos_optimized;              // DOS optimization flag
    time_t expires_at;                 // Certificate expiration
    char padding[MEMORY_ALIGNMENT];    // Cache line alignment
} ssl_context_cache_entry_t;

// Lock-free SSL context cache
typedef struct ssl_context_cache {
    ssl_context_cache_entry_t *entries;
    atomic_int entry_count;
    atomic_long cache_hits;
    atomic_long cache_misses;
    atomic_long dos_context_uses;
    int max_entries;
    char padding[MEMORY_ALIGNMENT];
} ssl_context_cache_t;

// =============================================================================
// STATISTICS (ATOMIC FOR THREAD SAFETY)
// =============================================================================

// Enhanced atomic statistics
extern atomic_long stat_connections_total;
extern atomic_long stat_connections_active;
extern atomic_long stat_dos_clients_active;
extern atomic_long stat_dos_clients_total;
extern atomic_long stat_buffer_allocations[BUFFER_POOL_SIZES];
extern atomic_long stat_buffer_deallocations[BUFFER_POOL_SIZES];
extern atomic_long stat_ssl_context_cache_hits;
extern atomic_long stat_ssl_context_cache_misses;
extern atomic_long stat_numa_allocations[MAX_NUMA_NODES];

// =============================================================================
// DEBUG-ONLY LOGGING MACROS
// =============================================================================

#ifdef DEBUG
#define LOG_MSG(level, fmt, ...) log_msg(level, fmt, ##__VA_ARGS__)
#else
#define LOG_MSG(level, fmt, ...) do {} while(0)
#endif

// ALL logging goes through this macro - only active in DEBUG builds
#define DEBUG_LOG(level, fmt, ...) LOG_MSG(level, fmt, ##__VA_ARGS__)

// =============================================================================
// FUNCTION DECLARATIONS
// =============================================================================

// Memory pool management
int memory_pool_init(void);
void memory_pool_cleanup(void);
void* memory_pool_alloc(size_t size, int numa_node);
void memory_pool_free(void* ptr, size_t size);

// Buffer management
int buffer_pool_init(void);
void buffer_pool_cleanup(void);
char* get_optimized_buffer(size_t size, int is_dos_client, int numa_node);
void return_optimized_buffer(char* buffer, size_t size);

// NUMA-aware allocation
int get_current_numa_node(void);
void set_thread_numa_affinity(int numa_node);

// DOS client detection and optimization
int detect_dos_client_advanced(int fd, struct sockaddr_storage *addr);
void optimize_connection_for_dos(connection_optimized_t *conn);

// SSL context cache management
int ssl_context_cache_init(void);
void ssl_context_cache_cleanup(void);
SSL_CTX* get_cached_ssl_context(const char* cert_name, int is_dos_client);
int cache_ssl_context(const char* cert_name, SSL_CTX* regular_ctx, SSL_CTX* dos_ctx);

// Performance monitoring
void print_performance_stats(void);
void reset_performance_stats(void);
double get_memory_utilization(void);

// Lock-free queue operations
typedef struct lockfree_queue {
    atomic_intptr_t head;
    atomic_intptr_t tail;
    char padding[MEMORY_ALIGNMENT];
} lockfree_queue_t;

int lockfree_queue_init(lockfree_queue_t *queue);
int lockfree_queue_enqueue(lockfree_queue_t *queue, void *data);
void* lockfree_queue_dequeue(lockfree_queue_t *queue);

// Utility functions (existing + enhanced)
void get_time(struct timespec *time);
unsigned int process_uptime(void);
char* get_version(int argc, char* argv[]);
char* get_stats(const int sta_offset, const int stt_offset);
float ema(float curr, int new, int *cnt);
double elapsed_time_msec(const struct timespec start_time);
void get_client_ip(int fd, char *client_ip, size_t client_ip_len, char *client_port, size_t client_port_len);
void log_xcs(int level, const char *client_ip, const char *host, int ssl_version, const char *request, const char *post_data, size_t post_len);

// Memory alignment helpers
#define ALIGN_UP(x, align) (((x) + (align) - 1) & ~((align) - 1))
#define CACHE_ALIGN(ptr) ALIGN_UP((uintptr_t)(ptr), MEMORY_ALIGNMENT)

// Atomic operation helpers
#define ATOMIC_LOAD_RELAXED(ptr) atomic_load_explicit(ptr, memory_order_relaxed)
#define ATOMIC_STORE_RELAXED(ptr, val) atomic_store_explicit(ptr, val, memory_order_relaxed)
#define ATOMIC_FETCH_ADD_RELAXED(ptr, val) atomic_fetch_add_explicit(ptr, val, memory_order_relaxed)

// Cache prefetch hints
#ifdef __GNUC__
#define PREFETCH_READ(addr) __builtin_prefetch(addr, 0, 3)
#define PREFETCH_WRITE(addr) __builtin_prefetch(addr, 1, 3)
#else
#define PREFETCH_READ(addr)
#define PREFETCH_WRITE(addr)
#endif

// Branch prediction hints
#ifdef __GNUC__
#define LIKELY(x) __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#define LIKELY(x) (x)
#define UNLIKELY(x) (x)
#endif

// Existing compatibility defines
#define BACKLOG SOMAXCONN
#define DEFAULT_IP "*"
#define DEFAULT_PORT "80"
#define DEFAULT_TIMEOUT 1
#define DEFAULT_KEEPALIVE (DEFAULT_TIMEOUT * 120)
#define DEFAULT_THREAD_MAX 1200
#define DEFAULT_CERT_CACHE_SIZE 500
#define SECOND_PORT "443"
#define MAX_PORTS 10
#define MAX_TLS_PORTS 9

#ifdef DROP_ROOT
#define DEFAULT_USER "nobody"
#endif

#define DEFAULT_STATS_URL "/servstats"
#define DEFAULT_STATS_TEXT_URL "/servstats.txt"

// Feature flags
#define FEAT_TFO
#ifdef linux
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0) || ENABLE_TCP_FASTOPEN
#undef FEAT_TFO
#define FEAT_TFO " tfo"
#endif
#endif

#ifdef TLS1_3_VERSION
#define FEAT_TLS1_3 " tls1_3"
#else
#define FEAT_TLS1_3 " no_tls1_3"
#endif

#define FEATURE_FLAGS " flags:" FEAT_TFO FEAT_TLS1_3 " +optimized_pools +numa_aware +lock_free"

#ifdef TEST
#define TESTPRINT printf
#else
#define TESTPRINT(x,y...)
#endif

// Cross-thread count variables (converted to atomic for thread safety)
extern atomic_long count;
extern atomic_long avg;
extern atomic_long rmx;
extern atomic_long tav;
extern atomic_long tmx;
extern atomic_long ers;
extern atomic_long tmo;
extern atomic_long cls;
extern atomic_long nou;
extern atomic_long pth;
extern atomic_long nfe;
extern atomic_long ufe;
extern atomic_long gif;
extern atomic_long bad;
extern atomic_long txt;
extern atomic_long jpg;
extern atomic_long png;
extern atomic_long swf;
extern atomic_long ico;
extern atomic_long sta;
extern atomic_long stt;
extern atomic_long noc;
extern atomic_long rdr;
extern atomic_long pst;
extern atomic_long hed;
extern atomic_long opt;
extern atomic_long cly;

extern atomic_long slh;
extern atomic_long slm;
extern atomic_long sle;
extern atomic_long slc;
extern atomic_long slu;
extern atomic_long uca;
extern atomic_long ucb;
extern atomic_long uce;
extern atomic_long ush;
extern atomic_long kcc;
extern atomic_long kmx;
extern atomic_long kct;
extern float kvg;
extern atomic_long krq;
extern atomic_long clt;
extern atomic_long v13;
extern atomic_long v12;
extern atomic_long v10;
extern atomic_long zrt;

// Global configuration structure
struct Global {
    int argc;
    char** argv;
    const time_t select_timeout;
    const time_t http_keepalive;
    const int pipefd;
    const char* const stats_url;
    const char* const stats_text_url;
    const int do_204;
    const int do_redirect;
#ifdef DEBUG
    const int warning_time;
#endif
    const char* pem_dir;
};

#define GLOBAL(p,e) ((struct Global *)p)->e

#ifndef TEMP_FAILURE_RETRY
#define TEMP_FAILURE_RETRY(expression) \
  (__extension__                                                              \
    ({ long int __result;                                                     \
       do __result = (long int) (expression);                                 \
       while (__result == -1L && errno == EINTR);                             \
       __result; }))
#endif

#if defined(__GLIBC__) && defined(BACKTRACE)
void print_trace();
#endif

#endif // UTIL_H
/*
 * debug_system.h - Einfaches Debug-System fĆ¼r SSLGateNX
 * 
 * Production: Nur "Program gestartet" - sonst NICHTS
 * Debug: VollstĆ¤ndiges Logging wie bisher
 */

#ifndef DEBUG_SYSTEM_H
#define DEBUG_SYSTEM_H

#include <stdio.h>
#include <stdarg.h>
#include <syslog.h>

/* Logger Level Definitionen */
typedef enum {    
    LGG_CRIT = 0,
    LGG_ERR,
    LGG_WARNING,
    LGG_NOTICE,
    LGG_INFO,
    LGG_DEBUG
} logger_level;

/* Legacy-KompatibilitĆ¤t fĆ¼r TLS-Konstanten */
#ifndef TLS1_3_VERSION
#define TLS1_3_VERSION 0x0304
#endif
#ifndef TLS1_2_VERSION  
#define TLS1_2_VERSION 0x0303
#endif
#ifndef TLS1_VERSION
#define TLS1_VERSION 0x0301
#endif

/* Log-Konstanten */
#define MAX_LOG_CHUNK_SIZE 8000

#ifdef DEBUG
    /* =====================================================================
     * DEBUG BUILD - VollstĆ¤ndiges Logging aktiv
     * ===================================================================== */
    
    /* Debug-Funktionen - werden implementiert */
    void debug_log_msg(logger_level level, const char *fmt, ...);
    void debug_log_xcs(logger_level level, char *client_ip, char *host, 
                       int tls, char *req, char *body, size_t body_len);
    void debug_set_verbose_level(logger_level level);
    logger_level debug_get_verbose_level(void);
    void debug_system_init(void);
    void debug_system_cleanup(void);
    
    /* Makros fĆ¼r Debug-Build */
    #define log_msg(level, fmt, ...) debug_log_msg(level, fmt, ##__VA_ARGS__)
    #define log_xcs(level, ip, host, tls, req, body, len) debug_log_xcs(level, ip, host, tls, req, body, len)
    #define log_set_verb(level) debug_set_verbose_level(level)
    #define log_get_verb() debug_get_verbose_level()
    
    /* Debug-spezifische Makros */
    #define DEBUG_PRINT(fmt, ...) printf("[DEBUG] " fmt "\n", ##__VA_ARGS__)
    #define TIME_CHECK(description) debug_time_check(description)
    #define HEX_DUMP(data, size) debug_hex_dump(data, size)
    #define TESTPRINT(fmt, ...) debug_log_msg(LGG_DEBUG, fmt, ##__VA_ARGS__)
    
    /* ZusĆ¤tzliche Debug-Funktionen */
    void debug_time_check(const char *description);
    void debug_hex_dump(void *data, int size);

#else
    /* =====================================================================
     * PRODUCTION BUILD - Ultra-minimal, nur Startup
     * ===================================================================== */
    
    /* Einzige erlaubte Funktion fĆ¼r Production */
    static inline void production_startup_message(void) {
        printf("Program gestartet\n");
        fflush(stdout);
    }
    
    /* Alle Log-Makros werden zu NICHTS - Zero-Cost in Production */
    #define log_msg(level, fmt, ...)                    /* NICHTS */
    #define log_xcs(level, ip, host, tls, req, body, len) /* NICHTS */
    #define log_set_verb(level)                         /* NICHTS */
    #define log_get_verb() 0                           /* Return 0 */
    
    /* Debug-Makros werden zu NICHTS */
    #define DEBUG_PRINT(fmt, ...)                      /* NICHTS */
    #define TIME_CHECK(description)                    /* NICHTS */
    #define HEX_DUMP(data, size)                       /* NICHTS */
    #define TESTPRINT(fmt, ...)                        /* NICHTS */
    
    /* Syslog komplett deaktiviert fĆ¼r Production */
    #define openlog(...)                               /* NICHTS */
    #define syslog(...)                                /* NICHTS */
    #define closelog()                                 /* NICHTS */
    
#endif /* DEBUG */

/* =========================================================================
 * SYSTEM STARTUP - Einziger Unterschied zwischen Debug/Production
 * ========================================================================= */

static inline void system_startup_log(void) {
#ifdef DEBUG
    debug_system_init();
    debug_log_msg(LGG_NOTICE, "SSLGateNX DEBUG build gestartet");
#else
    production_startup_message();
#endif
}

static inline void system_shutdown_log(void) {
#ifdef DEBUG
    debug_log_msg(LGG_NOTICE, "SSLGateNX DEBUG build beendet");
    debug_system_cleanup();
#endif
    /* Production: Nichts beim Shutdown */
}

#endif /* DEBUG_SYSTEM_H */
/*
 * src/log/logger.c
 *
*/

#include <stdarg.h>
#include <string.h>
#include <syslog.h>
#include <openssl/ssl.h>
#include "../log/logger.h"

#ifndef DEBUG
static logger_level _verb = LGG_ERR;
#else
static logger_level _verb = LGG_DEBUG;
#endif

static int ctrl_char(char *buf, size_t len) {
    if (strlen(buf) < len)
        return 1;
    for (size_t i=0; i<(len - 1); i++) {
        if (buf[i] >= 10 && buf[i] <= 13)
            continue;
        if (buf[i] < 32) {
            return 1;
        }
    }
    return 0;
}

void log_set_verb(logger_level verb) { _verb = verb; }
logger_level log_get_verb() { return _verb; }

void log_msg(logger_level verb, char *fmt, ...)
{
    if (verb > _verb)
        return;
      
    va_list args;
    va_start(args, fmt);
    vsyslog(LOG_CRIT + verb, fmt, args);
    va_end(args);
}

void log_xcs(logger_level verb, char *client_ip, char *host, int tls, char *req, char *body, size_t body_len)
{
    if (verb > _verb || !client_ip || !host || !req)
      return;

    const char* tls_ver;
    switch (tls) {
#ifdef TLS1_3_VERSION
        case TLS1_3_VERSION: tls_ver = "1.3"; break;
#endif
        case TLS1_2_VERSION: tls_ver = "1.2"; break;
        case TLS1_VERSION:   tls_ver = "1.0"; break;
        case 0:
        default:
            tls_ver = "none";
    }

    if (strlen(req) < MAX_LOG_CHUNK_SIZE)
        syslog(LOG_CRIT + verb, "%s %s %s tls_%s", client_ip, host, req, tls_ver);
    else {
        int num_chunks = strlen(req) / MAX_LOG_CHUNK_SIZE + 1;
        char store = req[MAX_LOG_CHUNK_SIZE];
        req[MAX_LOG_CHUNK_SIZE] = '\0';
        syslog(LOG_CRIT + verb, "%s %s %s", client_ip, host, req);
        req[MAX_LOG_CHUNK_SIZE] = store;

        int chunk = 1;
        if (num_chunks > 2)
          for (; chunk < num_chunks - 1; chunk++) {
              store = req[MAX_LOG_CHUNK_SIZE * (chunk + 1)];
              req[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = '\0';
              syslog(LOG_CRIT + verb, "%s", req + MAX_LOG_CHUNK_SIZE * chunk);
              req[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = store;
          }
        syslog(LOG_CRIT + verb, "%s tls_%s", req + MAX_LOG_CHUNK_SIZE * chunk, tls_ver);
    }

    if (body_len > 0 && body) {
      if (ctrl_char(body, body_len))
          syslog(LOG_CRIT + verb, "[%s]", "-binary POST content not dumped-");
      else if (strlen(body) < MAX_LOG_CHUNK_SIZE)
          syslog(LOG_CRIT + verb, "[%s]", body);
      else {
          int num_chunks = strlen(body) / MAX_LOG_CHUNK_SIZE + 1;
          char store = body[MAX_LOG_CHUNK_SIZE];
          body[MAX_LOG_CHUNK_SIZE] = '\0';
          syslog(LOG_CRIT + verb, "[%s", body);
          body[MAX_LOG_CHUNK_SIZE] = store;

          int chunk = 1;
          if (num_chunks > 2)
            for (; chunk < num_chunks - 1; chunk++) {
                store = body[MAX_LOG_CHUNK_SIZE * (chunk + 1)];
                body[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = '\0';
                syslog(LOG_CRIT + verb, "%s", body + MAX_LOG_CHUNK_SIZE * chunk);
                body[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = store;
            }
          syslog(LOG_CRIT + verb, "%s]", body + MAX_LOG_CHUNK_SIZE * chunk);
      }
    }
}
/*
 * src/ssl/keypool.c - Lock-Free Memory Pool and SSL Context Cache
 * 
 * High-performance memory management with NUMA awareness and DOS client optimization
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509v3.h>
#include <openssl/opensslv.h>
#include <stdatomic.h>

#ifdef NUMA_SUPPORT
#include <numa.h>
#endif

#include "../ssl/ssl_config.h"
#include "../ssl/ssl_modules.h"
#include "../log/logger.h"
#include "../util/util.h"

#if defined(__GLIBC__) && !defined(__UCLIBC__)
#include <malloc.h>
#endif

// =============================================================================
// GLOBAL STATE
// =============================================================================

// Buffer pool manager (global instance)
static buffer_pool_manager_t *g_buffer_manager = NULL;

// SSL context cache (lock-free)
static ssl_context_cache_t *g_ssl_cache = NULL;

// Connection pool (optimized for high concurrency)
static connection_optimized_t *g_connection_pool = NULL;
static atomic_intptr_t g_connection_free_head = ATOMIC_VAR_INIT(0);
static atomic_int g_connection_pool_count = ATOMIC_VAR_INIT(0);

// Lock-free queues for different operations
static lockfree_queue_t cert_generation_queue;
static lockfree_queue_t connection_cleanup_queue;

// Performance statistics (atomic)
atomic_long stat_connections_total = ATOMIC_VAR_INIT(0);
atomic_long stat_connections_active = ATOMIC_VAR_INIT(0);
atomic_long stat_dos_clients_active = ATOMIC_VAR_INIT(0);
atomic_long stat_dos_clients_total = ATOMIC_VAR_INIT(0);
atomic_long stat_buffer_allocations[BUFFER_POOL_SIZES] = {ATOMIC_VAR_INIT(0)};
atomic_long stat_buffer_deallocations[BUFFER_POOL_SIZES] = {ATOMIC_VAR_INIT(0)};
atomic_long stat_ssl_context_cache_hits = ATOMIC_VAR_INIT(0);
atomic_long stat_ssl_context_cache_misses = ATOMIC_VAR_INIT(0);
atomic_long stat_numa_allocations[MAX_NUMA_NODES] = {ATOMIC_VAR_INIT(0)};

// Worker thread shutdown flag
static atomic_bool workers_shutdown = ATOMIC_VAR_INIT(false);

// =============================================================================
// NUMA SUPPORT FUNCTIONS
// =============================================================================

int get_current_numa_node(void) {
#ifdef NUMA_SUPPORT
    if (numa_available() != -1) {
        return numa_node_of_cpu(sched_getcpu());
    }
#endif
    return 0; // Fallback to node 0
}

void set_thread_numa_affinity(int numa_node) {
#ifdef NUMA_SUPPORT
    if (numa_available() != -1 && numa_node < numa_max_node() + 1) {
        struct bitmask *mask = numa_allocate_cpumask();
        numa_node_to_cpus(numa_node, mask);
        numa_sched_setaffinity(0, mask);
        numa_free_cpumask(mask);
        LOG_MSG(LGG_DEBUG, "Thread bound to NUMA node %d", numa_node);
    }
#endif
}

// =============================================================================
// LOCK-FREE QUEUE IMPLEMENTATION
// =============================================================================

int lockfree_queue_init(lockfree_queue_t *queue) {
    if (!queue) return -1;
    
    atomic_init(&queue->head, 0);
    atomic_init(&queue->tail, 0);
    return 0;
}

int lockfree_queue_enqueue(lockfree_queue_t *queue, void *data) {
    if (!queue || !data) return -1;
    
    memory_slot_t *node = malloc(sizeof(memory_slot_t) + sizeof(void*));
    if (!node) return -1;
    
    memcpy(node->data, &data, sizeof(void*));
    atomic_store_explicit(&node->next, 0, memory_order_relaxed);
    
    intptr_t prev_tail = atomic_exchange_explicit(&queue->tail, (intptr_t)node, memory_order_release);
    
    if (prev_tail) {
        atomic_store_explicit(&((memory_slot_t*)prev_tail)->next, (intptr_t)node, memory_order_release);
    } else {
        atomic_store_explicit(&queue->head, (intptr_t)node, memory_order_release);
    }
    
    return 0;
}

void* lockfree_queue_dequeue(lockfree_queue_t *queue) {
    if (!queue) return NULL;
    
    intptr_t head = atomic_load_explicit(&queue->head, memory_order_acquire);
    if (!head) return NULL;
    
    memory_slot_t *node = (memory_slot_t*)head;
    intptr_t next = atomic_load_explicit(&node->next, memory_order_acquire);
    
    if (atomic_compare_exchange_weak_explicit(&queue->head, &head, next, 
                                            memory_order_release, memory_order_relaxed)) {
        void *data;
        memcpy(&data, node->data, sizeof(void*));
        free(node);
        return data;
    }
    
    return NULL; // Retry needed
}

// =============================================================================
// BUFFER POOL MANAGEMENT
// =============================================================================

static size_t get_buffer_size_class(size_t requested_size) {
    if (requested_size <= BUFFER_SIZE_TINY) return 0;
    if (requested_size <= BUFFER_SIZE_SMALL) return 1;
    if (requested_size <= BUFFER_SIZE_MEDIUM) return 2;
    if (requested_size <= BUFFER_SIZE_LARGE) return 3;
    if (requested_size <= BUFFER_SIZE_HUGE) return 4;
    if (requested_size <= BUFFER_SIZE_MASSIVE) return 5;
    return 6; // Special case - direct allocation
}

static size_t get_actual_buffer_size(int size_class) {
    switch (size_class) {
        case 0: return BUFFER_SIZE_TINY;
        case 1: return BUFFER_SIZE_SMALL;
        case 2: return BUFFER_SIZE_MEDIUM;
        case 3: return BUFFER_SIZE_LARGE;
        case 4: return BUFFER_SIZE_HUGE;
        case 5: return BUFFER_SIZE_MASSIVE;
        default: return 0; // Invalid
    }
}

int buffer_pool_init(void) {
    g_buffer_manager = mmap(NULL, sizeof(buffer_pool_manager_t), 
                           PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (g_buffer_manager == MAP_FAILED) {
        LOG_MSG(LGG_ERR, "Failed to allocate buffer pool manager: %m");
        return -1;
    }
    
    memset(g_buffer_manager, 0, sizeof(buffer_pool_manager_t));
    
#ifdef NUMA_SUPPORT
    g_buffer_manager->numa_nodes = (numa_available() != -1) ? numa_max_node() + 1 : 1;
#else
    g_buffer_manager->numa_nodes = 1;
#endif
    
    // Initialize buffer pools for each NUMA node and size class
    for (int numa = 0; numa < g_buffer_manager->numa_nodes; numa++) {
        for (int size_class = 0; size_class < BUFFER_POOL_SIZES; size_class++) {
            numa_pool_t *pool = &g_buffer_manager->pools[numa][size_class];
            
            pool->numa_node = numa;
            pool->slot_size = get_actual_buffer_size(size_class);
            
            if (pool->slot_size == 0) continue; // Skip invalid size classes
            
            // Allocate slots with NUMA awareness
            size_t total_size = MEMORY_POOL_SLOTS * (sizeof(memory_slot_t) + pool->slot_size);
            
#ifdef NUMA_SUPPORT
            if (g_buffer_manager->numa_nodes > 1) {
                pool->slots = numa_alloc_onnode(total_size, numa);
            } else {
                pool->slots = malloc(total_size);
            }
#else
            pool->slots = malloc(total_size);
#endif
            
            if (!pool->slots) {
                LOG_MSG(LGG_ERR, "Failed to allocate memory pool for NUMA node %d, size class %d", numa, size_class);
                return -1;
            }
            
            // Initialize free list
            atomic_init(&pool->free_head, 0);
            atomic_init(&pool->free_count, 0);
            
            // Link all slots into free list
            for (int i = 0; i < MEMORY_POOL_SLOTS; i++) {
                memory_slot_t *slot = (memory_slot_t*)((char*)pool->slots + i * (sizeof(memory_slot_t) + pool->slot_size));
                
                intptr_t old_head = atomic_load_explicit(&pool->free_head, memory_order_relaxed);
                atomic_store_explicit(&slot->next, old_head, memory_order_relaxed);
                atomic_store_explicit(&pool->free_head, (intptr_t)slot, memory_order_release);
                atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
            }
            
            LOG_MSG(LGG_INFO, "Initialized buffer pool: NUMA node %d, size class %d (%zu bytes), %d slots",
                    numa, size_class, pool->slot_size, MEMORY_POOL_SLOTS);
        }
    }
    
    LOG_MSG(LGG_INFO, "Buffer pool manager initialized with %d NUMA nodes", g_buffer_manager->numa_nodes);
    return 0;
}

char* get_optimized_buffer(size_t size, int is_dos_client, int numa_node) {
    if (!g_buffer_manager) {
        LOG_MSG(LGG_ERR, "Buffer manager not initialized");
        return NULL;
    }
    
    // For DOS clients, prefer smaller buffers
    int size_class = get_buffer_size_class(is_dos_client ? min(size, BUFFER_SIZE_SMALL) : size);
    
    // Clamp NUMA node
    if (numa_node >= g_buffer_manager->numa_nodes) {
        numa_node = 0;
    }
    
    // For very large allocations, use direct malloc
    if (size_class >= BUFFER_POOL_SIZES - 1) {
        char *ptr = malloc(size);
        if (ptr) {
            atomic_fetch_add_explicit(&stat_buffer_allocations[BUFFER_POOL_SIZES - 1], 1, memory_order_relaxed);
        }
        return ptr;
    }
    
    numa_pool_t *pool = &g_buffer_manager->pools[numa_node][size_class];
    
    // Try to get from free list (lock-free)
    while (true) {
        intptr_t head = atomic_load_explicit(&pool->free_head, memory_order_acquire);
        if (!head) break; // Pool exhausted
        
        memory_slot_t *slot = (memory_slot_t*)head;
        intptr_t next = atomic_load_explicit(&slot->next, memory_order_relaxed);
        
        if (atomic_compare_exchange_weak_explicit(&pool->free_head, &head, next,
                                                memory_order_release, memory_order_relaxed)) {
            atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
            atomic_fetch_add_explicit(&stat_buffer_allocations[size_class], 1, memory_order_relaxed);
            atomic_fetch_add_explicit(&stat_numa_allocations[numa_node], 1, memory_order_relaxed);
            
            PREFETCH_WRITE(slot->data);
            return slot->data;
        }
    }
    
    // Pool exhausted, fall back to malloc
    size_t actual_size = get_actual_buffer_size(size_class);
    char *ptr = malloc(actual_size);
    if (ptr) {
        atomic_fetch_add_explicit(&stat_buffer_allocations[size_class], 1, memory_order_relaxed);
        LOG_MSG(LGG_DEBUG, "Buffer pool exhausted for size class %d, using malloc", size_class);
    }
    
    return ptr;
}

void return_optimized_buffer(char* buffer, size_t size) {
    if (!buffer || !g_buffer_manager) return;
    
    int size_class = get_buffer_size_class(size);
    
    // For direct allocations, just free
    if (size_class >= BUFFER_POOL_SIZES - 1) {
        free(buffer);
        atomic_fetch_add_explicit(&stat_buffer_deallocations[BUFFER_POOL_SIZES - 1], 1, memory_order_relaxed);
        return;
    }
    
    // Find which pool this buffer belongs to
    memory_slot_t *slot = (memory_slot_t*)((char*)buffer - offsetof(memory_slot_t, data));
    
    // Determine NUMA node by checking which pool contains this slot
    int numa_node = -1;
    for (int numa = 0; numa < g_buffer_manager->numa_nodes; numa++) {
        numa_pool_t *pool = &g_buffer_manager->pools[numa][size_class];
        
        if ((char*)slot >= (char*)pool->slots && 
            (char*)slot < (char*)pool->slots + MEMORY_POOL_SLOTS * (sizeof(memory_slot_t) + pool->slot_size)) {
            numa_node = numa;
            break;
        }
    }
    
    if (numa_node == -1) {
        // Not from pool, was malloc'd
        free(buffer);
        atomic_fetch_add_explicit(&stat_buffer_deallocations[size_class], 1, memory_order_relaxed);
        return;
    }
    
    numa_pool_t *pool = &g_buffer_manager->pools[numa_node][size_class];
    
    // Return to free list (lock-free)
    while (true) {
        intptr_t head = atomic_load_explicit(&pool->free_head, memory_order_relaxed);
        atomic_store_explicit(&slot->next, head, memory_order_relaxed);
        
        if (atomic_compare_exchange_weak_explicit(&pool->free_head, &head, (intptr_t)slot,
                                                memory_order_release, memory_order_relaxed)) {
            atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
            atomic_fetch_add_explicit(&stat_buffer_deallocations[size_class], 1, memory_order_relaxed);
            break;
        }
    }
}

void buffer_pool_cleanup(void) {
    if (!g_buffer_manager) return;
    
    for (int numa = 0; numa < g_buffer_manager->numa_nodes; numa++) {
        for (int size_class = 0; size_class < BUFFER_POOL_SIZES; size_class++) {
            numa_pool_t *pool = &g_buffer_manager->pools[numa][size_class];
            
            if (pool->slots) {
#ifdef NUMA_SUPPORT
                if (g_buffer_manager->numa_nodes > 1) {
                    numa_free(pool->slots, MEMORY_POOL_SLOTS * (sizeof(memory_slot_t) + pool->slot_size));
                } else {
                    free(pool->slots);
                }
#else
                free(pool->slots);
#endif
            }
        }
    }
    
    munmap(g_buffer_manager, sizeof(buffer_pool_manager_t));
    g_buffer_manager = NULL;
    
    LOG_MSG(LGG_INFO, "Buffer pool cleanup completed");
}

// =============================================================================
// SSL CONTEXT CACHE (OPTIMIZED)
// =============================================================================

int ssl_context_cache_init(void) {
    g_ssl_cache = mmap(NULL, sizeof(ssl_context_cache_t), 
                      PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (g_ssl_cache == MAP_FAILED) {
        PROD_LOG_ERR("Failed to allocate SSL context cache: %m");
        return -1;
    }
    
    memset(g_ssl_cache, 0, sizeof(ssl_context_cache_t));
    g_ssl_cache->max_entries = SSL_CONTEXT_CACHE_SIZE;
    
    g_ssl_cache->entries = mmap(NULL, SSL_CONTEXT_CACHE_SIZE * sizeof(ssl_context_cache_entry_t),
                               PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (g_ssl_cache->entries == MAP_FAILED) {
        PROD_LOG_ERR("Failed to allocate SSL context cache entries: %m");
        munmap(g_ssl_cache, sizeof(ssl_context_cache_t));
        return -1;
    }
    
    memset(g_ssl_cache->entries, 0, SSL_CONTEXT_CACHE_SIZE * sizeof(ssl_context_cache_entry_t));
    
    atomic_init(&g_ssl_cache->entry_count, 0);
    atomic_init(&g_ssl_cache->cache_hits, 0);
    atomic_init(&g_ssl_cache->cache_misses, 0);
    atomic_init(&g_ssl_cache->dos_context_uses, 0);
    
    DEBUG_LOG(LGG_INFO, "SSL context cache initialized with %d entries", SSL_CONTEXT_CACHE_SIZE);
    return 0;
}

SSL_CTX* get_cached_ssl_context(const char* cert_name, int is_dos_client) {
    if (!g_ssl_cache || !cert_name) {
        atomic_fetch_add_explicit(&stat_ssl_context_cache_misses, 1, memory_order_relaxed);
        return NULL;
    }
    
    // Simple hash for cache lookup
    uint32_t hash = 0;
    for (const char *p = cert_name; *p; p++) {
        hash = hash * 31 + *p;
    }
    
    int start_idx = hash % g_ssl_cache->max_entries;
    int current_idx = start_idx;
    
    do {
        ssl_context_cache_entry_t *entry = &g_ssl_cache->entries[current_idx];
        
        if (entry->cert_name && strcmp(entry->cert_name, cert_name) == 0) {
            // Check expiration
            time_t now = time(NULL);
            if (entry->expires_at > 0 && now > entry->expires_at) {
                // Expired, treat as miss
                break;
            }
            
            // Cache hit
            atomic_fetch_add_explicit(&g_ssl_cache->cache_hits, 1, memory_order_relaxed);
            atomic_store_explicit(&entry->last_use, (long)now, memory_order_relaxed);
            atomic_fetch_add_explicit(&entry->reuse_count, 1, memory_order_relaxed);
            
            if (is_dos_client && entry->dos_ctx) {
                atomic_fetch_add_explicit(&g_ssl_cache->dos_context_uses, 1, memory_order_relaxed);
                PREFETCH_READ(entry->dos_ctx);
                return entry->dos_ctx;
            } else if (!is_dos_client && entry->regular_ctx) {
                PREFETCH_READ(entry->regular_ctx);
                return entry->regular_ctx;
            }
        }
        
        current_idx = (current_idx + 1) % g_ssl_cache->max_entries;
    } while (current_idx != start_idx);
    
    // Cache miss
    atomic_fetch_add_explicit(&g_ssl_cache->cache_misses, 1, memory_order_relaxed);
    return NULL;
}

int cache_ssl_context(const char* cert_name, SSL_CTX* regular_ctx, SSL_CTX* dos_ctx) {
    if (!g_ssl_cache || !cert_name || (!regular_ctx && !dos_ctx)) {
        return -1;
    }
    
    // Find insertion point
    uint32_t hash = 0;
    for (const char *p = cert_name; *p; p++) {
        hash = hash * 31 + *p;
    }
    
    int target_idx = hash % g_ssl_cache->max_entries;
    ssl_context_cache_entry_t *entry = &g_ssl_cache->entries[target_idx];
    
    // If slot is occupied, find LRU entry to replace
    if (entry->cert_name) {
        long oldest_use = atomic_load_explicit(&entry->last_use, memory_order_relaxed);
        int lru_idx = target_idx;
        
        for (int i = 0; i < g_ssl_cache->max_entries; i++) {
            ssl_context_cache_entry_t *candidate = &g_ssl_cache->entries[i];
            long candidate_use = atomic_load_explicit(&candidate->last_use, memory_order_relaxed);
            
            if (candidate_use < oldest_use) {
                oldest_use = candidate_use;
                lru_idx = i;
            }
        }
        
        entry = &g_ssl_cache->entries[lru_idx];
        
        // Clean up old entry
        if (entry->cert_name) {
            free(entry->cert_name);
            if (entry->regular_ctx) SSL_CTX_free(entry->regular_ctx);
            if (entry->dos_ctx) SSL_CTX_free(entry->dos_ctx);
        }
    }
    
    // Insert new entry
    entry->cert_name = strdup(cert_name);
    entry->regular_ctx = regular_ctx;
    entry->dos_ctx = dos_ctx;
    entry->is_dos_optimized = (dos_ctx != NULL);
    entry->expires_at = 0; // Will be set based on certificate
    
    atomic_store_explicit(&entry->last_use, (long)time(NULL), memory_order_relaxed);
    atomic_store_explicit(&entry->ref_count, 0, memory_order_relaxed);
    atomic_store_explicit(&entry->reuse_count, 0, memory_order_relaxed);
    
    if (atomic_load_explicit(&g_ssl_cache->entry_count, memory_order_relaxed) < g_ssl_cache->max_entries) {
        atomic_fetch_add_explicit(&g_ssl_cache->entry_count, 1, memory_order_relaxed);
    }
    
    DEBUG_LOG(LGG_DEBUG, "Cached SSL context for %s (regular: %p, dos: %p)", 
            cert_name, regular_ctx, dos_ctx);
    return 0;
}

void ssl_context_cache_cleanup(void) {
    if (!g_ssl_cache) return;
    
    for (int i = 0; i < g_ssl_cache->max_entries; i++) {
        ssl_context_cache_entry_t *entry = &g_ssl_cache->entries[i];
        
        if (entry->cert_name) {
            free(entry->cert_name);
            if (entry->regular_ctx) SSL_CTX_free(entry->regular_ctx);
            if (entry->dos_ctx) SSL_CTX_free(entry->dos_ctx);
        }
    }
    
    munmap(g_ssl_cache->entries, SSL_CONTEXT_CACHE_SIZE * sizeof(ssl_context_cache_entry_t));
    munmap(g_ssl_cache, sizeof(ssl_context_cache_t));
    g_ssl_cache = NULL;
    
    DEBUG_LOG(LGG_INFO, "SSL context cache cleanup completed");
}

// =============================================================================
// CONNECTION POOL (OPTIMIZED)
// =============================================================================

int connection_pool_init(void) {
    size_t pool_size = CONNECTION_POOL_SIZE * sizeof(connection_optimized_t);
    
    g_connection_pool = mmap(NULL, pool_size, PROT_READ | PROT_WRITE, 
                            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (g_connection_pool == MAP_FAILED) {
        PROD_LOG_ERR("Failed to allocate connection pool: %m");
        return -1;
    }
    
    memset(g_connection_pool, 0, pool_size);
    
    // Initialize free list
    for (int i = 0; i < CONNECTION_POOL_SIZE - 1; i++) {
        atomic_store_explicit((atomic_intptr_t*)&g_connection_pool[i].fd, i + 1, memory_order_relaxed);
    }
    atomic_store_explicit((atomic_intptr_t*)&g_connection_pool[CONNECTION_POOL_SIZE - 1].fd, 0, memory_order_relaxed);
    
    atomic_store_explicit(&g_connection_free_head, 1, memory_order_relaxed);
    atomic_store_explicit(&g_connection_pool_count, CONNECTION_POOL_SIZE, memory_order_relaxed);
    
    DEBUG_LOG(LGG_INFO, "Connection pool initialized with %d connections", CONNECTION_POOL_SIZE);
    return 0;
}

connection_optimized_t* acquire_connection(void) {
    while (true) {
        intptr_t head = atomic_load_explicit(&g_connection_free_head, memory_order_acquire);
        if (!head) return NULL; // Pool exhausted
        
        connection_optimized_t *conn = &g_connection_pool[head - 1];
        intptr_t next = atomic_load_explicit((atomic_intptr_t*)&conn->fd, memory_order_relaxed);
        
        if (atomic_compare_exchange_weak_explicit(&g_connection_free_head, &head, next,
                                                memory_order_release, memory_order_relaxed)) {
            // Reset connection state
            memset(conn, 0, sizeof(connection_optimized_t));
            conn->numa_node = get_current_numa_node();
            atomic_store_explicit(&conn->state, 1, memory_order_relaxed); // Active
            
            atomic_fetch_add_explicit(&stat_connections_active, 1, memory_order_relaxed);
            return conn;
        }
    }
}

void release_connection(connection_optimized_t* conn) {
    if (!conn || conn < g_connection_pool || 
        conn >= g_connection_pool + CONNECTION_POOL_SIZE) {
        return;
    }
    
    // Clean up connection resources
    if (conn->buffer) {
        return_optimized_buffer(conn->buffer, atomic_load_explicit(&conn->buffer_size, memory_order_relaxed));
        conn->buffer = NULL;
    }
    
    if (conn->ssl) {
        SSL_free(conn->ssl);
        conn->ssl = NULL;
    }
    
    if (conn->fd > 0) {
        close(conn->fd);
        conn->fd = 0;
    }
    
    atomic_store_explicit(&conn->state, 0, memory_order_relaxed); // Inactive
    
    // Return to free list
    intptr_t conn_idx = (conn - g_connection_pool) + 1;
    
    while (true) {
        intptr_t head = atomic_load_explicit(&g_connection_free_head, memory_order_relaxed);
        atomic_store_explicit((atomic_intptr_t*)&conn->fd, head, memory_order_relaxed);
        
        if (atomic_compare_exchange_weak_explicit(&g_connection_free_head, &head, conn_idx,
                                                memory_order_release, memory_order_relaxed)) {
            atomic_fetch_sub_explicit(&stat_connections_active, 1, memory_order_relaxed);
            break;
        }
    }
}

void connection_pool_cleanup(void) {
    if (!g_connection_pool) return;
    
    // Clean up active connections
    for (int i = 0; i < CONNECTION_POOL_SIZE; i++) {
        connection_optimized_t *conn = &g_connection_pool[i];
        
        if (atomic_load_explicit(&conn->state, memory_order_relaxed)) {
            release_connection(conn);
        }
    }
    
    munmap(g_connection_pool, CONNECTION_POOL_SIZE * sizeof(connection_optimized_t));
    g_connection_pool = NULL;
    
    DEBUG_LOG(LGG_INFO, "Connection pool cleanup completed");
}

// =============================================================================
// PERFORMANCE MONITORING
// =============================================================================

void print_performance_stats(void) {
    printf("\n=== High-Performance Memory Pool Statistics ===\n");
    printf("Active connections: %ld\n", atomic_load_explicit(&stat_connections_active, memory_order_relaxed));
    printf("Total connections: %ld\n", atomic_load_explicit(&stat_connections_total, memory_order_relaxed));
    printf("DOS clients active: %ld\n", atomic_load_explicit(&stat_dos_clients_active, memory_order_relaxed));
    printf("DOS clients total: %ld\n", atomic_load_explicit(&stat_dos_clients_total, memory_order_relaxed));
    
    printf("\nBuffer Pool Statistics:\n");
    const char* size_names[] = {"TINY", "SMALL", "MEDIUM", "LARGE", "HUGE", "MASSIVE", "DIRECT", "RESERVED"};
    for (int i = 0; i < BUFFER_POOL_SIZES; i++) {
        long allocs = atomic_load_explicit(&stat_buffer_allocations[i], memory_order_relaxed);
        long deallocs = atomic_load_explicit(&stat_buffer_deallocations[i], memory_order_relaxed);
        printf("  %s: %ld allocs, %ld deallocs, %ld active\n", 
               size_names[i], allocs, deallocs, allocs - deallocs);
    }
    
    printf("\nSSL Context Cache:\n");
    long hits = atomic_load_explicit(&stat_ssl_context_cache_hits, memory_order_relaxed);
    long misses = atomic_load_explicit(&stat_ssl_context_cache_misses, memory_order_relaxed);
    long dos_uses = atomic_load_explicit(&g_ssl_cache->dos_context_uses, memory_order_relaxed);
    printf("  Cache hits: %ld\n", hits);
    printf("  Cache misses: %ld\n", misses);
    printf("  Hit ratio: %.2f%%\n", hits + misses > 0 ? (100.0 * hits) / (hits + misses) : 0.0);
    printf("  DOS context uses: %ld\n", dos_uses);
    
    if (g_buffer_manager && g_buffer_manager->numa_nodes > 1) {
        printf("\nNUMA Allocation Distribution:\n");
        for (int i = 0; i < g_buffer_manager->numa_nodes; i++) {
            printf("  Node %d: %ld allocations\n", i, 
                   atomic_load_explicit(&stat_numa_allocations[i], memory_order_relaxed));
        }
    }
    
    printf("===============================================\n");
}

double get_memory_utilization(void) {
    if (!g_buffer_manager) return 0.0;
    
    long total_allocated = 0;
    long total_deallocated = 0;
    
    for (int i = 0; i < BUFFER_POOL_SIZES; i++) {
        total_allocated += atomic_load_explicit(&stat_buffer_allocations[i], memory_order_relaxed);
        total_deallocated += atomic_load_explicit(&stat_buffer_deallocations[i], memory_order_relaxed);
    }
    
    long active_buffers = total_allocated - total_deallocated;
    long max_buffers = MEMORY_POOL_SLOTS * BUFFER_POOL_SIZES * g_buffer_manager->numa_nodes;
    
    return max_buffers > 0 ? (100.0 * active_buffers) / max_buffers : 0.0;
}

void reset_performance_stats(void) {
    for (int i = 0; i < BUFFER_POOL_SIZES; i++) {
        atomic_store_explicit(&stat_buffer_allocations[i], 0, memory_order_relaxed);
        atomic_store_explicit(&stat_buffer_deallocations[i], 0, memory_order_relaxed);
    }
    
    for (int i = 0; i < MAX_NUMA_NODES; i++) {
        atomic_store_explicit(&stat_numa_allocations[i], 0, memory_order_relaxed);
    }
    
    atomic_store_explicit(&stat_ssl_context_cache_hits, 0, memory_order_relaxed);
    atomic_store_explicit(&stat_ssl_context_cache_misses, 0, memory_order_relaxed);
    
    if (g_ssl_cache) {
        atomic_store_explicit(&g_ssl_cache->cache_hits, 0, memory_order_relaxed);
        atomic_store_explicit(&g_ssl_cache->cache_misses, 0, memory_order_relaxed);
        atomic_store_explicit(&g_ssl_cache->dos_context_uses, 0, memory_order_relaxed);
    }
    
    log_msg(LGG_INFO, "Performance statistics reset");
}

// =============================================================================
// INITIALIZATION AND CLEANUP
// =============================================================================

int memory_pool_init(void) {
    DEBUG_LOG(LGG_INFO, "Initializing high-performance memory pools...");
    
    // Initialize lock-free queues
    if (lockfree_queue_init(&cert_generation_queue) != 0 ||
        lockfree_queue_init(&connection_cleanup_queue) != 0) {
        PROD_LOG_ERR("Failed to initialize lock-free queues");
        return -1;
    }
    
    // Initialize buffer pools
    if (buffer_pool_init() != 0) {
        PROD_LOG_ERR("Failed to initialize buffer pools");
        return -1;
    }
    
    // Initialize SSL context cache
    if (ssl_context_cache_init() != 0) {
        PROD_LOG_ERR("Failed to initialize SSL context cache");
        buffer_pool_cleanup();
        return -1;
    }
    
    // Initialize connection pool
    if (connection_pool_init() != 0) {
        PROD_LOG_ERR("Failed to initialize connection pool");
        ssl_context_cache_cleanup();
        buffer_pool_cleanup();
        return -1;
    }
    
    atomic_store_explicit(&workers_shutdown, false, memory_order_relaxed);
    
    DEBUG_LOG(LGG_INFO, "High-performance memory pools initialized successfully");
    return 0;
}

void memory_pool_cleanup(void) {
    DEBUG_LOG(LGG_INFO, "Shutting down memory pools...");
    
    atomic_store_explicit(&workers_shutdown, true, memory_order_relaxed);
    
    connection_pool_cleanup();
    ssl_context_cache_cleanup();
    buffer_pool_cleanup();
    
    DEBUG_LOG(LGG_INFO, "Memory pool cleanup completed");
}
/*
 * src/ssl/ssl_context.c - DOS-Optimized SSL Context Management
 * 
 * Enhanced SSL context handling with DOS client optimization and advanced caching
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509v3.h>
#include <openssl/opensslv.h>
#include <stdatomic.h>

#include "../ssl/ssl_config.h"
#include "../ssl/ssl_modules.h"
#include "../log/logger.h"
#include "../util/util.h"

// =============================================================================
// DOS CLIENT DETECTION PATTERNS
// =============================================================================

// Enhanced DOS client detection signatures
static const struct dos_signature {
    const unsigned char *pattern;
    size_t pattern_len;
    const char *description;
    int confidence;
} dos_signatures[] = {
    // SSLv2 Client Hello
    {(unsigned char[]){0x80, 0x2E, 0x01}, 3, "SSLv2 CLIENT-HELLO", 95},
    {(unsigned char[]){0x80, 0x46, 0x01}, 3, "SSLv2 CLIENT-HELLO (long)", 95},
    
    // SSLv3 patterns
    {(unsigned char[]){0x16, 0x03, 0x00}, 3, "SSLv3 handshake", 90},
    
    // TLS 1.0 (common in DOS systems)
    {(unsigned char[]){0x16, 0x03, 0x01}, 3, "TLS 1.0 handshake", 80},
    
    // Very old cipher preferences (typical in DOS environments)
    {(unsigned char[]){0x00, 0x04}, 2, "RC4-MD5 cipher", 70},
    {(unsigned char[]){0x00, 0x05}, 2, "RC4-SHA cipher", 70},
    {(unsigned char[]){0x00, 0x0A}, 2, "DES-CBC3-SHA cipher", 85},
    {(unsigned char[]){0x00, 0x16}, 2, "DES-CBC-SHA cipher", 90},
    
    // Legacy extension patterns
    {(unsigned char[]){0x00, 0x00}, 2, "Server Name Indication (basic)", 60},
    
    // Small packet indicators
    {NULL, 0, "Small initial packet", 50} // Special case for packet size analysis
};

#define NUM_DOS_SIGNATURES (sizeof(dos_signatures) / sizeof(dos_signatures[0]) - 1)

// DOS-specific cipher lists
static const char *dos_cipher_list_minimal = 
    "RC4-MD5:RC4-SHA:DES-CBC3-SHA:DES-CBC-SHA:AES128-SHA:AES256-SHA";

static const char *dos_cipher_list_extended = 
    "RC4-MD5:RC4-SHA:DES-CBC3-SHA:DES-CBC-SHA:"
    "AES128-SHA:AES256-SHA:AES128-SHA256:AES256-SHA256:"
    "DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:"
    "EDH-RSA-DES-CBC3-SHA:ECDHE-RSA-RC4-SHA:"
    "ECDHE-RSA-DES-CBC3-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA";

static const char *dos_cipher_list_legacy = 
    "NULL-MD5:NULL-SHA:RC4-MD5:RC4-SHA:RC2-CBC-MD5:DES-CBC-MD5:DES-CBC3-MD5";

// Global SSL contexts
SSL_CTX *g_regular_sslctx = NULL;
SSL_CTX *g_dos_minimal_sslctx = NULL;
SSL_CTX *g_dos_extended_sslctx = NULL;
SSL_CTX *g_dos_legacy_sslctx = NULL;

// DOS client statistics
static atomic_long dos_detection_attempts = ATOMIC_VAR_INIT(0);
static atomic_long dos_clients_detected = ATOMIC_VAR_INIT(0);
static atomic_long dos_ssl_downgrades = ATOMIC_VAR_INIT(0);
static atomic_long dos_cipher_fallbacks = ATOMIC_VAR_INIT(0);

// =============================================================================
// ENHANCED DOS CLIENT DETECTION
// =============================================================================

int detect_dos_client_advanced(int fd, struct sockaddr_storage *addr) {
    char peek_buf[512]; // Larger buffer for better analysis
    int peek_len = recv(fd, peek_buf, sizeof(peek_buf), MSG_PEEK);
    int confidence_score = 0;
    
    atomic_fetch_add_explicit(&dos_detection_attempts, 1, memory_order_relaxed);
    
    if (peek_len <= 0) {
        return 0;
    }
    
    LOG_MSG(LGG_DEBUG, "Analyzing %d bytes for DOS client detection", peek_len);
    
    // 1. Packet size analysis
    if (peek_len < 64) {
        confidence_score += 30;
        LOG_MSG(LGG_DEBUG, "Small packet detected (%d bytes) - confidence +30", peek_len);
    } else if (peek_len < 128) {
        confidence_score += 15;
        log_msg(LGG_DEBUG, "Medium packet detected (%d bytes) - confidence +15", peek_len);
    }
    
    // 2. Pattern matching
    for (int i = 0; i < NUM_DOS_SIGNATURES; i++) {
        const struct dos_signature *sig = &dos_signatures[i];
        
        if (sig->pattern && peek_len >= sig->pattern_len) {
            // Search for pattern in the first 256 bytes
            int search_len = (peek_len < 256) ? peek_len : 256;
            
            for (int pos = 0; pos <= search_len - sig->pattern_len; pos++) {
                if (memcmp(peek_buf + pos, sig->pattern, sig->pattern_len) == 0) {
                    confidence_score += sig->confidence;
                    LOG_MSG(LGG_DEBUG, "DOS signature found: %s - confidence +%d (total: %d)", 
                            sig->description, sig->confidence, confidence_score);
                    break;
                }
            }
        }
    }
    
    // 3. TLS version analysis
    if (peek_len >= 6 && peek_buf[0] == 0x16) { // TLS handshake
        int tls_major = peek_buf[1];
        int tls_minor = peek_buf[2];
        
        if (tls_major == 3) {
            if (tls_minor == 0) { // SSLv3
                confidence_score += 85;
                log_msg(LGG_DEBUG, "SSLv3 detected - confidence +85");
            } else if (tls_minor == 1) { // TLS 1.0
                confidence_score += 60;
                log_msg(LGG_DEBUG, "TLS 1.0 detected - confidence +60");
            } else if (tls_minor == 2) { // TLS 1.1
                confidence_score += 30;
                log_msg(LGG_DEBUG, "TLS 1.1 detected - confidence +30");
            }
        }
    }
    
    // 4. Client Hello analysis (if available)
    if (peek_len >= 43 && peek_buf[0] == 0x16) {
        // Look for extensions
        int has_extensions = 0;
        int extension_count = 0;
        
        // Simple heuristic: modern clients typically send many extensions
        for (int i = 43; i < peek_len - 4; i++) {
            if (peek_buf[i] == 0x00 && peek_buf[i+1] < 0x20) { // Possible extension
                extension_count++;
                has_extensions = 1;
            }
        }
        
        if (!has_extensions) {
            confidence_score += 40;
            log_msg(LGG_DEBUG, "No TLS extensions detected - confidence +40");
        } else if (extension_count < 5) {
            confidence_score += 20;
            log_msg(LGG_DEBUG, "Few TLS extensions (%d) - confidence +20", extension_count);
        }
    }
    
    // 5. Timing analysis (slow client detection)
    struct timeval tv = {0, 250000}; // 250ms timeout
    setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    
    char second_peek[64];
    int second_len = recv(fd, second_peek, sizeof(second_peek), MSG_PEEK | MSG_DONTWAIT);
    
    if (second_len == peek_len) {
        // No new data arrived quickly - possibly slow DOS client
        confidence_score += 25;
        log_msg(LGG_DEBUG, "Slow data arrival detected - confidence +25");
    }
    
    // Reset timeout
    tv.tv_sec = 30; // 30 second default
    tv.tv_usec = 0;
    setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    
    // 6. Connection source analysis
    if (addr) {
        // Check if connection comes from known DOS client IP ranges
        // This could be enhanced with IP reputation databases
        char ip_str[INET6_ADDRSTRLEN];
        
        if (addr->ss_family == AF_INET) {
            struct sockaddr_in *addr_in = (struct sockaddr_in*)addr;
            inet_ntop(AF_INET, &addr_in->sin_addr, ip_str, sizeof(ip_str));
            
            // Legacy IP ranges (example heuristics)
            if (strncmp(ip_str, "192.168.", 8) == 0 || // Local networks (often legacy systems)
                strncmp(ip_str, "10.", 3) == 0) {
                confidence_score += 10;
                log_msg(LGG_DEBUG, "Legacy IP range detected (%s) - confidence +10", ip_str);
            }
        }
    }
    
    // Final decision
    int is_dos_client = (confidence_score >= 80);
    
    if (is_dos_client) {
        atomic_fetch_add_explicit(&dos_clients_detected, 1, memory_order_relaxed);
        log_msg(LGG_INFO, "DOS client detected with confidence score %d", confidence_score);
    } else {
        log_msg(LGG_DEBUG, "Modern client detected (confidence score %d)", confidence_score);
    }
    
    return is_dos_client;
}

// =============================================================================
// DOS-OPTIMIZED SSL CONTEXT CREATION
// =============================================================================

static SSL_CTX* create_dos_ssl_context(const char *cipher_list, const char *context_name) {
    SSL_CTX *ctx;
    
    log_msg(LGG_DEBUG, "Creating DOS SSL context: %s", context_name);
    
    // Use the most compatible SSL method
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
    ctx = SSL_CTX_new(TLS_server_method());
#else
    ctx = SSL_CTX_new(SSLv23_server_method());
#endif
    
    if (!ctx) {
        log_msg(LGG_ERR, "Failed to create DOS SSL context: %s", context_name);
        return NULL;
    }
    
    // Configure for maximum DOS compatibility
    
    // 1. Enable all legacy protocols
    SSL_CTX_clear_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1);
    
    // 2. Set protocol version range for DOS clients
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
    SSL_CTX_set_min_proto_version(ctx, SSL2_VERSION);
    SSL_CTX_set_max_proto_version(ctx, TLS1_VERSION);
    SSL_CTX_set_security_level(ctx, 0); // Lowest security level for legacy compatibility
#endif
    
    // 3. DOS-specific options
    long options = SSL_OP_LEGACY_SERVER_CONNECT |
                   SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS |
                   SSL_OP_NO_COMPRESSION |
                   SSL_OP_CIPHER_SERVER_PREFERENCE |
                   SSL_OP_SINGLE_DH_USE |
                   SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION;
    
    // Enable bug workarounds for old clients
    options |= SSL_OP_ALL;
    
    SSL_CTX_set_options(ctx, options);
    
    // 4. Set DOS-compatible cipher list
    if (SSL_CTX_set_cipher_list(ctx, cipher_list) <= 0) {
        log_msg(LGG_WARNING, "Failed to set cipher list for %s: %s", context_name, cipher_list);
        // Try with an even more basic cipher list
        if (SSL_CTX_set_cipher_list(ctx, "RC4-MD5:RC4-SHA:DES-CBC3-SHA") <= 0) {
            log_msg(LGG_ERR, "Failed to set any cipher list for %s", context_name);
            SSL_CTX_free(ctx);
            return NULL;
        }
    }
    
    // 5. Configure session settings for DOS clients
    SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_SERVER | SSL_SESS_CACHE_NO_AUTO_CLEAR);
    SSL_CTX_sess_set_cache_size(ctx, DOS_SSL_CONTEXT_CACHE);
    SSL_CTX_set_timeout(ctx, 600); // 10 minutes timeout for slow DOS clients
    
    // 6. Configure for slow/unreliable connections
    SSL_CTX_set_mode(ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |
                          SSL_MODE_ENABLE_PARTIAL_WRITE |
                          SSL_MODE_AUTO_RETRY);
    
    // 7. Disable advanced features that DOS clients don't support
    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
    
    // 8. Set up DH parameters for legacy compatibility
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    // For older OpenSSL versions, manually set DH parameters
    DH *dh = DH_new();
    if (dh) {
        // Use 1024-bit DH for DOS compatibility (not secure but compatible)
        BIGNUM *p = BN_new();
        BIGNUM *g = BN_new();
        
        if (p && g) {
            BN_hex2bn(&p, "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF");
            BN_set_word(g, 2);
            
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
            DH_set0_pqg(dh, p, NULL, g);
#else
            dh->p = p;
            dh->g = g;
#endif
            SSL_CTX_set_tmp_dh(ctx, dh);
        }
        DH_free(dh);
    }
#endif
    
    // 9. Set up ECDH with conservative curves
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
    // Use only well-supported curves for DOS compatibility
    int groups[] = { NID_X9_62_prime256v1 }; // Only P-256
    SSL_CTX_set1_groups(ctx, groups, 1);
#elif OPENSSL_VERSION_NUMBER >= 0x10002000L
    SSL_CTX_set_ecdh_auto(ctx, 1);
#else
    // Manually set ECDH curve for very old OpenSSL
    EC_KEY *ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
    if (ecdh) {
        SSL_CTX_set_tmp_ecdh(ctx, ecdh);
        EC_KEY_free(ecdh);
    }
#endif
    
    log_msg(LGG_INFO, "DOS SSL context created: %s", context_name);
    return ctx;
}

int initialize_dos_ssl_contexts(const char *pem_dir) {
    log_msg(LGG_INFO, "Initializing DOS-optimized SSL contexts...");
    
    // Create regular SSL context (modern clients)
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
    g_regular_sslctx = SSL_CTX_new(TLS_server_method());
#else
    g_regular_sslctx = SSL_CTX_new(SSLv23_server_method());
#endif
    
    if (!g_regular_sslctx) {
        log_msg(LGG_ERR, "Failed to create regular SSL context");
        return -1;
    }
    
    // Configure regular context for modern clients
    long regular_options = SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION |
                          SSL_OP_CIPHER_SERVER_PREFERENCE | SSL_OP_SINGLE_DH_USE;
    
#ifdef SSL_OP_NO_TLSv1_1
    regular_options |= SSL_OP_NO_TLSv1_1;
#endif
    
    SSL_CTX_set_options(g_regular_sslctx, regular_options);
    SSL_CTX_set_cipher_list(g_regular_sslctx, 
        "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:"
        "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:"
        "ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:"
        "DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256");
    
    // Create DOS-specific contexts with different compatibility levels
    
    // 1. Minimal DOS context (most restrictive)
    g_dos_minimal_sslctx = create_dos_ssl_context(dos_cipher_list_minimal, "DOS-Minimal");
    if (!g_dos_minimal_sslctx) {
        log_msg(LGG_ERR, "Failed to create DOS minimal SSL context");
        goto cleanup_error;
    }
    
    // 2. Extended DOS context (more ciphers)
    g_dos_extended_sslctx = create_dos_ssl_context(dos_cipher_list_extended, "DOS-Extended");
    if (!g_dos_extended_sslctx) {
        log_msg(LGG_ERR, "Failed to create DOS extended SSL context");
        goto cleanup_error;
    }
    
    // 3. Legacy DOS context (maximum compatibility, including NULL ciphers)
    g_dos_legacy_sslctx = create_dos_ssl_context(dos_cipher_list_legacy, "DOS-Legacy");
    if (!g_dos_legacy_sslctx) {
        log_msg(LGG_WARNING, "Failed to create DOS legacy SSL context (may not be critical)");
        // This is optional, continue without it
    }
    
    log_msg(LGG_INFO, "DOS-optimized SSL contexts initialized successfully");
    return 0;
    
cleanup_error:
    if (g_regular_sslctx) {
        SSL_CTX_free(g_regular_sslctx);
        g_regular_sslctx = NULL;
    }
    if (g_dos_minimal_sslctx) {
        SSL_CTX_free(g_dos_minimal_sslctx);
        g_dos_minimal_sslctx = NULL;
    }
    if (g_dos_extended_sslctx) {
        SSL_CTX_free(g_dos_extended_sslctx);
        g_dos_extended_sslctx = NULL;
    }
    return -1;
}

// =============================================================================
// ADAPTIVE SSL CONTEXT SELECTION
// =============================================================================

SSL_CTX* get_optimal_ssl_context(const char* cert_name, dos_client_info_t *dos_info, 
                                 int *context_switched) {
    if (context_switched) *context_switched = 0;
    
    // For regular clients, always use the regular context
    if (!dos_info || !atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        return g_regular_sslctx;
    }
    
    // For DOS clients, select context based on detected capabilities
    SSL_CTX *selected_ctx = NULL;
    const char *context_name = NULL;
    
    int ssl_version = atomic_load_explicit(&dos_info->ssl_version_detected, memory_order_relaxed);
    int legacy_mode = atomic_load_explicit(&dos_info->legacy_ssl_mode, memory_order_relaxed);
    
    if (ssl_version == SSL2_VERSION || legacy_mode > 2) {
        // Very old client - use legacy context if available
        if (g_dos_legacy_sslctx) {
            selected_ctx = g_dos_legacy_sslctx;
            context_name = "DOS-Legacy";
        } else {
            selected_ctx = g_dos_minimal_sslctx;
            context_name = "DOS-Minimal (fallback)";
        }
    } else if (ssl_version == SSL3_VERSION || ssl_version == TLS1_VERSION || legacy_mode > 0) {
        // Moderately old client - use extended context
        selected_ctx = g_dos_extended_sslctx;
        context_name = "DOS-Extended";
    } else {
        // Default DOS client - use minimal context
        selected_ctx = g_dos_minimal_sslctx;
        context_name = "DOS-Minimal";
    }
    
    log_msg(LGG_DEBUG, "Selected SSL context for DOS client: %s (SSL version: %d, legacy mode: %d)",
            context_name, ssl_version, legacy_mode);
    
    return selected_ctx;
}

// =============================================================================
// SSL HANDSHAKE OPTIMIZATION FOR DOS CLIENTS
// =============================================================================

int perform_dos_ssl_handshake(SSL *ssl, dos_client_info_t *dos_info, int *handshake_retries) {
    if (!ssl || !dos_info) return -1;
    
    int max_retries = atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? 10 : 3;
    int retry_count = 0;
    int handshake_result;
    
    log_msg(LGG_DEBUG, "Starting DOS-optimized SSL handshake (max retries: %d)", max_retries);
    
    while (retry_count < max_retries) {
        ERR_clear_error();
        handshake_result = SSL_accept(ssl);
        
        if (handshake_result == 1) {
            // Handshake successful
            int actual_version = SSL_version(ssl);
            atomic_store_explicit(&dos_info->ssl_version_detected, actual_version, memory_order_relaxed);
            
            if (handshake_retries) *handshake_retries = retry_count;
            
            log_msg(LGG_DEBUG, "DOS SSL handshake successful after %d retries (version: %s)",
                    retry_count, SSL_get_version(ssl));
            return 1;
        }
        
        int ssl_error = SSL_get_error(ssl, handshake_result);
        
        switch (ssl_error) {
            case SSL_ERROR_WANT_READ:
            case SSL_ERROR_WANT_WRITE:
                // DOS clients may be slow - give them more time
                if (atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
                    usleep(100000); // 100ms delay for DOS clients
                } else {
                    usleep(10000);  // 10ms delay for regular clients
                }
                retry_count++;
                continue;
                
            case SSL_ERROR_SSL:
                // Check if we can downgrade the SSL context
                if (atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
                    int current_legacy_mode = atomic_load_explicit(&dos_info->legacy_ssl_mode, memory_order_relaxed);
                    
                    if (current_legacy_mode < 3) {
                        atomic_store_explicit(&dos_info->legacy_ssl_mode, current_legacy_mode + 1, memory_order_relaxed);
                        atomic_fetch_add_explicit(&dos_ssl_downgrades, 1, memory_order_relaxed);
                        
                        log_msg(LGG_INFO, "SSL error for DOS client, attempting downgrade (mode: %d -> %d)",
                                current_legacy_mode, current_legacy_mode + 1);
                        
                        // Try to switch to a more compatible context
                        SSL_CTX *new_ctx = get_optimal_ssl_context(NULL, dos_info, NULL);
                        if (new_ctx && new_ctx != SSL_get_SSL_CTX(ssl)) {
                            SSL_set_SSL_CTX(ssl, new_ctx);
                            retry_count++;
                            continue;
                        }
                    }
                }
                
                // Log specific SSL error
                unsigned long err = ERR_get_error();
                char err_buf[256];
                ERR_error_string_n(err, err_buf, sizeof(err_buf));
                log_msg(LGG_WARNING, "SSL handshake error for %s client: %s",
                        atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular",
                        err_buf);
                return 0;
                
            case SSL_ERROR_SYSCALL:
                if (errno == 0) {
                    log_msg(LGG_DEBUG, "DOS client closed connection during handshake");
                } else {
                    log_msg(LGG_DEBUG, "DOS SSL handshake syscall error: %m");
                }
                return 0;
                
            default:
                log_msg(LGG_WARNING, "Unexpected SSL error %d during DOS handshake", ssl_error);
                return 0;
        }
        
        retry_count++;
    }
    
    log_msg(LGG_WARNING, "DOS SSL handshake failed after %d retries", max_retries);
    if (handshake_retries) *handshake_retries = retry_count;
    return 0;
}

// =============================================================================
// SSL CONTEXT OPTIMIZATION FUNCTIONS
// =============================================================================

void optimize_ssl_for_dos_client(SSL *ssl, dos_client_info_t *dos_info) {
    if (!ssl || !dos_info || !atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        return;
    }
    
    log_msg(LGG_DEBUG, "Optimizing SSL connection for DOS client");
    
    // Set connection-specific options for DOS clients
    SSL_set_options(ssl, SSL_OP_LEGACY_SERVER_CONNECT);
    SSL_set_options(ssl, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
    
    // Configure for slow/unreliable connections
    SSL_set_mode(ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
    SSL_set_mode(ssl, SSL_MODE_ENABLE_PARTIAL_WRITE);
    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
    
    // Set longer timeout for slow DOS clients
    SSL_set_timeout(ssl, 600); // 10 minutes
    
    // Set smaller MTU for fragmented networks (common in DOS environments)
    SSL_set_mtu(ssl, 512);
    
    // Disable session tickets for DOS clients (they often don't support them)
    SSL_set_options(ssl, SSL_OP_NO_TICKET);
    
    // Configure read/write buffer sizes for DOS clients
    if (atomic_load_explicit(&dos_info->use_small_buffers, memory_order_relaxed)) {
        SSL_set_default_read_buffer_len(ssl, 1024);
    }
    
    log_msg(LGG_DEBUG, "SSL optimization for DOS client completed");
}

// =============================================================================
// CIPHER FALLBACK MECHANISM
// =============================================================================

int attempt_cipher_fallback(SSL *ssl, dos_client_info_t *dos_info) {
    if (!ssl || !dos_info || !atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        return 0;
    }
    
    SSL_CTX *ctx = SSL_get_SSL_CTX(ssl);
    if (!ctx) return 0;
    
    atomic_fetch_add_explicit(&dos_cipher_fallbacks, 1, memory_order_relaxed);
    
    // Try progressively more permissive cipher lists
    const char *fallback_ciphers[] = {
        dos_cipher_list_minimal,
        dos_cipher_list_extended,
        "RC4-MD5:RC4-SHA:DES-CBC-SHA:DES-CBC3-SHA", // Very basic
        "RC4-MD5:DES-CBC-SHA",                      // Minimal
        "RC4-MD5",                                  // Last resort
        NULL
    };
    
    for (int i = 0; fallback_ciphers[i]; i++) {
        log_msg(LGG_DEBUG, "Attempting cipher fallback %d: %s", i + 1, fallback_ciphers[i]);
        
        if (SSL_CTX_set_cipher_list(ctx, fallback_ciphers[i]) > 0) {
            log_msg(LGG_INFO, "Cipher fallback successful: %s", fallback_ciphers[i]);
            return 1;
        }
    }
    
    log_msg(LGG_WARNING, "All cipher fallback attempts failed for DOS client");
    return 0;
}

// =============================================================================
// STATISTICS AND MONITORING
// =============================================================================

void print_dos_ssl_statistics(void) {
    printf("\n=== DOS SSL Context Statistics ===\n");
    printf("DOS detection attempts: %ld\n", atomic_load_explicit(&dos_detection_attempts, memory_order_relaxed));
    printf("DOS clients detected: %ld\n", atomic_load_explicit(&dos_clients_detected, memory_order_relaxed));
    printf("DOS SSL downgrades: %ld\n", atomic_load_explicit(&dos_ssl_downgrades, memory_order_relaxed));
    printf("DOS cipher fallbacks: %ld\n", atomic_load_explicit(&dos_cipher_fallbacks, memory_order_relaxed));
    
    long total_attempts = atomic_load_explicit(&dos_detection_attempts, memory_order_relaxed);
    long detected = atomic_load_explicit(&dos_clients_detected, memory_order_relaxed);
    
    if (total_attempts > 0) {
        printf("DOS detection rate: %.2f%%\n", (100.0 * detected) / total_attempts);
    }
    
    printf("===================================\n");
}

void reset_dos_ssl_statistics(void) {
    atomic_store_explicit(&dos_detection_attempts, 0, memory_order_relaxed);
    atomic_store_explicit(&dos_clients_detected, 0, memory_order_relaxed);
    atomic_store_explicit(&dos_ssl_downgrades, 0, memory_order_relaxed);
    atomic_store_explicit(&dos_cipher_fallbacks, 0, memory_order_relaxed);
    
    log_msg(LGG_INFO, "DOS SSL statistics reset");
}

// =============================================================================
// CLEANUP FUNCTIONS
// =============================================================================

void cleanup_dos_ssl_contexts(void) {
    log_msg(LGG_INFO, "Cleaning up DOS SSL contexts...");
    
    if (g_regular_sslctx) {
        SSL_CTX_free(g_regular_sslctx);
        g_regular_sslctx = NULL;
    }
    
    if (g_dos_minimal_sslctx) {
        SSL_CTX_free(g_dos_minimal_sslctx);
        g_dos_minimal_sslctx = NULL;
    }
    
    if (g_dos_extended_sslctx) {
        SSL_CTX_free(g_dos_extended_sslctx);
        g_dos_extended_sslctx = NULL;
    }
    
    if (g_dos_legacy_sslctx) {
        SSL_CTX_free(g_dos_legacy_sslctx);
        g_dos_legacy_sslctx = NULL;
    }
    
    log_msg(LGG_INFO, "DOS SSL context cleanup completed");
}
/*
 * src/ssl/ssl_init.c - SSL Context Management and TLS Callbacks
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509v3.h>
#include <openssl/opensslv.h>
#include "../ssl/ssl_config.h"
#include "../ssl/ssl_modules.h"
#include "../log/logger.h"
#include "../util/util.h"

SSL_CTX *g_sslctx;

#if defined(__GLIBC__) && !defined(__UCLIBC__)
#  include <malloc.h>
#endif

/* Legacy threading support for older OpenSSL versions */
#if !OPENSSL_API_1_1
static pthread_mutex_t *locks;
#endif

/* WILDCARD IP FUNCTIONS */
/* Enhanced IP detection */
int is_ip_address(const char *addr) {
    struct sockaddr_in sa4;
    struct sockaddr_in6 sa6;
    
    if (inet_pton(AF_INET, addr, &(sa4.sin_addr)) == 1) return 4;
    if (inet_pton(AF_INET6, addr, &(sa6.sin6_addr)) == 1) return 6;
    return 0;
}

/* Generate universal catch-all certificate for all IPs */
void generate_universal_ip_cert(const char *pem_dir,
                                      X509_NAME *issuer,
                                      EVP_PKEY *privkey,
                                      const STACK_OF(X509_INFO) *cachain)
{
    char fname[SSLGATENX_MAX_PATH];
    EVP_PKEY *key = NULL;
    X509 *x509 = NULL;
    X509_EXTENSION *ext = NULL;
    EVP_MD_CTX *p_ctx = NULL;
    
    /* Mega SAN for all common IPs */
    char mega_san[2048];
    strcpy(mega_san, 
        "IP:127.0.0.1,IP:127.0.0.254,"           /* localhost */
        "IP:10.0.0.1,IP:10.255.255.254,"         /* 10.x.x.x */
        "IP:192.168.0.1,IP:192.168.255.254,"     /* 192.168.x.x */
        "IP:172.16.0.1,IP:172.31.255.254,"       /* 172.16-31.x.x */
        "IP:192.168.1.1,IP:192.168.0.1,IP:10.0.0.1," /* common routers */
        "DNS:localhost,DNS:*.local,DNS:*.lan"
    );

#if OPENSSL_API_1_1
    p_ctx = EVP_MD_CTX_new();
#else
    p_ctx = EVP_MD_CTX_create();
#endif
    if (!p_ctx || EVP_DigestSignInit(p_ctx, NULL, EVP_sha256(), NULL, privkey) != 1) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to init sign context", __FUNCTION__);
#endif
        goto free_all;
    }

    /* Generate key pair */
#if OPENSSL_VERSION_NUMBER >= 0x30000000L
    /* OpenSSL 3.0+ */
    key = EVP_RSA_gen(2048);
    if (!key) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to generate RSA key", __FUNCTION__);
#endif
        goto free_all;
    }
#elif OPENSSL_API_1_1
    /* OpenSSL 1.1.x */
    key = EVP_PKEY_new();
    if (!key) goto free_all;
    
    EVP_PKEY_CTX *pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    if (!pkey_ctx) goto free_all;
    
    if (EVP_PKEY_keygen_init(pkey_ctx) <= 0 ||
        EVP_PKEY_CTX_set_rsa_keygen_bits(pkey_ctx, 2048) <= 0 ||
        EVP_PKEY_keygen(pkey_ctx, &key) <= 0) {
        EVP_PKEY_CTX_free(pkey_ctx);
        goto free_all;
    }
    EVP_PKEY_CTX_free(pkey_ctx);
#else
    /* Legacy OpenSSL */
    BIGNUM *e = BN_new();
    if (!e) goto free_all;
    BN_set_word(e, RSA_F4);
    
    RSA *rsa = RSA_new();
    if (!rsa || RSA_generate_key_ex(rsa, 2048, e, NULL) < 0) {
        BN_free(e);
        RSA_free(rsa);
        goto free_all;
    }
    BN_free(e);
    
    key = EVP_PKEY_new();
    if (!key || !EVP_PKEY_assign_RSA(key, rsa)) {
        RSA_free(rsa);
        goto free_all;
    }
#endif

    /* Create certificate */
    x509 = X509_new();
    if (!x509) goto free_all;
    
    ASN1_INTEGER_set(X509_get_serialNumber(x509), rand());
    X509_set_version(x509, 2); /* X509 v3 */
    
    /* Random NotBefore date between -864000 and -172800 seconds */
    int offset = -(rand() % (864000 - 172800 + 1) + 172800);
    X509_gmtime_adj(X509_get_notBefore(x509), offset);
    X509_gmtime_adj(X509_get_notAfter(x509), 3600*24*390L); /* 390 days */
    
    X509_set_issuer_name(x509, issuer);
    X509_NAME *name = X509_get_subject_name(x509);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, (unsigned char *)"*.universal.ip", -1, -1, 0);

    /* Add the mega SAN extension */
    ext = X509V3_EXT_conf_nid(NULL, NULL, NID_subject_alt_name, mega_san);
    if (!ext) goto free_all;
    X509_add_ext(x509, ext, -1);
    X509_EXTENSION_free(ext);
    ext = NULL;
    
    ext = X509V3_EXT_conf_nid(NULL, NULL, NID_ext_key_usage, "TLS Web Server Authentication");
    if (!ext) goto free_all;
    X509_add_ext(x509, ext, -1);
    
    X509_set_pubkey(x509, key);
    X509_sign_ctx(x509, p_ctx);

    /* Save certificate to file */
    snprintf(fname, SSLGATENX_MAX_PATH, "%s/universal_ips.pem", pem_dir);
    
    FILE *fp = fopen(fname, "wb");
    if (!fp) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to open file for write: %s", __FUNCTION__, fname);
#endif
        goto free_all;
    }

    /* Write certificate */
    PEM_write_X509(fp, x509);

    /* Write CA chain */
    if (cachain) {
        for (int i = 0; i < sk_X509_INFO_num(cachain); i++) {
            X509_INFO *xi = sk_X509_INFO_value(cachain, i);
            if (xi && xi->x509) {
                PEM_write_X509(fp, xi->x509);
            }
        }
    }

    /* Write private key */
    PEM_write_PrivateKey(fp, key, NULL, NULL, 0, NULL, NULL);
    fclose(fp);
    
#ifdef DEBUG
    log_msg(LGG_NOTICE, "š”’ Universal IP certificate generated: %s", fname);
#endif

free_all:
    EVP_PKEY_free(key);
    X509_EXTENSION_free(ext);
    X509_free(x509);
    if (p_ctx) {
#if OPENSSL_API_1_1
        EVP_MD_CTX_free(p_ctx);
#else
        EVP_MD_CTX_destroy(p_ctx);
#endif
    }
}

/* Certificate worker thread */
void *cert_worker(void *arg) {
    cert_tlstor_t *ct = (cert_tlstor_t *)arg;
    
    while (!cert_workers_shutdown) {
        pthread_mutex_lock(&cert_q_lock);
        while (!cert_q_head && !cert_workers_shutdown) {
            pthread_cond_wait(&cert_q_cond, &cert_q_lock);
        }
        
        if (cert_workers_shutdown) {
            pthread_mutex_unlock(&cert_q_lock);
            break;
        }
        
        cert_job_t *job = cert_q_head;
        cert_q_head = job->next;
        if (!cert_q_head) cert_q_tail = NULL;
        pthread_mutex_unlock(&cert_q_lock);

        /* Generate certificate */
        generate_cert(job->cert_name, ct->pem_dir, ct->issuer, ct->privkey, ct->cachain);
        
        free(job);
    }
    return NULL;
}

/* OpenSSL threading functions - only for legacy versions */
#if !OPENSSL_API_1_1
static void ssl_lock_cb(int mode, int type, const char *file, int line)
{
    if (mode & CRYPTO_LOCK)
        pthread_mutex_lock(&(locks[type]));
    else
        pthread_mutex_unlock(&(locks[type]));
}

static void ssl_thread_id(CRYPTO_THREADID *id)
{
    CRYPTO_THREADID_set_numeric(id, (unsigned long) pthread_self());
}
#endif

void ssl_init_locks()
{
#if !OPENSSL_API_1_1
    int num_locks = CRYPTO_num_locks();
#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: CRYPTO_num_locks = %d", __FUNCTION__, num_locks);
#endif
    locks = OPENSSL_malloc(num_locks * sizeof(pthread_mutex_t));
    if (!locks) {
#ifdef DEBUG
        log_msg(LGG_ERR, "Failed to allocate SSL locks");
#endif
        return;
    }
    
    for (int i = 0; i < num_locks; i++) {
        pthread_mutex_init(&(locks[i]), NULL);
    }

    CRYPTO_THREADID_set_callback(ssl_thread_id);
    CRYPTO_set_locking_callback(ssl_lock_cb);
#else
    /* OpenSSL 1.1.0+ handles threading automatically */
#ifdef DEBUG
    log_msg(LGG_DEBUG, "Using OpenSSL 1.1.0+ automatic threading");
#endif
#endif
}

void ssl_free_locks()
{
#if !OPENSSL_API_1_1
    if (!locks) return;
    
    CRYPTO_set_locking_callback(NULL);
    int num_locks = CRYPTO_num_locks();
    for (int i = 0; i < num_locks; i++) {
        pthread_mutex_destroy(&(locks[i]));
    }
    OPENSSL_free(locks);
    locks = NULL;
#endif
}

void generate_cert(const char* cert_name,
                          const char *pem_dir,
                          X509_NAME *issuer,
                          EVP_PKEY *privkey,
                          const STACK_OF(X509_INFO) *cachain)
{
    char fname[SSLGATENX_MAX_PATH];
    EVP_PKEY *key = NULL;
    X509 *x509 = NULL;
    X509_EXTENSION *ext = NULL;
    char san_str[SSLGATENX_MAX_SERVER_NAME + 4];
    EVP_MD_CTX *p_ctx = NULL;
    char *pem_fn = NULL;
    
    /* Make a copy since we might modify it */
    pem_fn = strdup(cert_name);
    if (!pem_fn) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to allocate memory for cert name", __FUNCTION__);
#endif
        return;
    }

#if OPENSSL_API_1_1
    p_ctx = EVP_MD_CTX_new();
#else
    p_ctx = EVP_MD_CTX_create();
#endif
    if (!p_ctx || EVP_DigestSignInit(p_ctx, NULL, EVP_sha256(), NULL, privkey) != 1) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to init sign context", __FUNCTION__);
#endif
        goto free_all;
    }

    if (pem_fn[0] == '_') pem_fn[0] = '*';

    /* Generate key pair */
#if OPENSSL_VERSION_NUMBER >= 0x30000000L
    /* OpenSSL 3.0+ */
    key = EVP_RSA_gen(2048);
    if (!key) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to generate RSA key", __FUNCTION__);
#endif
        goto free_all;
    }
#elif OPENSSL_API_1_1
    /* OpenSSL 1.1.x */
    key = EVP_PKEY_new();
    if (!key) goto free_all;
    
    EVP_PKEY_CTX *pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    if (!pkey_ctx) goto free_all;
    
    if (EVP_PKEY_keygen_init(pkey_ctx) <= 0 ||
        EVP_PKEY_CTX_set_rsa_keygen_bits(pkey_ctx, 2048) <= 0 ||
        EVP_PKEY_keygen(pkey_ctx, &key) <= 0) {
        EVP_PKEY_CTX_free(pkey_ctx);
        goto free_all;
    }
    EVP_PKEY_CTX_free(pkey_ctx);
#else
    /* Legacy OpenSSL */
    BIGNUM *e = BN_new();
    if (!e) goto free_all;
    BN_set_word(e, RSA_F4);
    
    RSA *rsa = RSA_new();
    if (!rsa || RSA_generate_key_ex(rsa, 2048, e, NULL) < 0) {
        BN_free(e);
        RSA_free(rsa);
        goto free_all;
    }
    BN_free(e);
    
    key = EVP_PKEY_new();
    if (!key || !EVP_PKEY_assign_RSA(key, rsa)) {
        RSA_free(rsa);
        goto free_all;
    }
#endif

#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: RSA key generated for [%s]", __FUNCTION__, pem_fn);
#endif

    /* Create certificate */
    x509 = X509_new();
    if (!x509) goto free_all;
    
    ASN1_INTEGER_set(X509_get_serialNumber(x509), rand());
    X509_set_version(x509, 2); /* X509 v3 */
    
    /* Random NotBefore date between -864000 and -172800 seconds */
    int offset = -(rand() % (864000 - 172800 + 1) + 172800);
    X509_gmtime_adj(X509_get_notBefore(x509), offset);
    X509_gmtime_adj(X509_get_notAfter(x509), 3600*24*390L); /* 390 days */
    
    X509_set_issuer_name(x509, issuer);
    X509_NAME *name = X509_get_subject_name(x509);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, (unsigned char *)pem_fn, -1, -1, 0);

    /* Enhanced IP detection instead of the dot counting logic */
    int ip_version = is_ip_address(pem_fn);
    if (ip_version > 0) {
        snprintf(san_str, sizeof(san_str), "IP:%s", pem_fn);
#ifdef DEBUG
        log_msg(LGG_DEBUG, "Detected IPv%d address: %s", ip_version, pem_fn);
#endif
    } else {
        snprintf(san_str, sizeof(san_str), "DNS:%s", pem_fn);
#ifdef DEBUG
        log_msg(LGG_DEBUG, "Detected domain name: %s", pem_fn);
#endif
    }
    
    ext = X509V3_EXT_conf_nid(NULL, NULL, NID_subject_alt_name, san_str);
    if (!ext) goto free_all;
    X509_add_ext(x509, ext, -1);
    X509_EXTENSION_free(ext);
    ext = NULL;
    
    ext = X509V3_EXT_conf_nid(NULL, NULL, NID_ext_key_usage, "TLS Web Server Authentication");
    if (!ext) goto free_all;
    X509_add_ext(x509, ext, -1);
    
    X509_set_pubkey(x509, key);
    X509_sign_ctx(x509, p_ctx);

#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: X509 cert created", __FUNCTION__);
#endif

    /* Save certificate to file */
    if (pem_fn[0] == '*') pem_fn[0] = '_';
    snprintf(fname, SSLGATENX_MAX_PATH, "%s/%s", pem_dir, pem_fn);
    
    FILE *fp = fopen(fname, "wb");
    if (!fp) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to open file for write: %s", __FUNCTION__, fname);
#endif
        goto free_all;
    }

    /* Write certificate */
    PEM_write_X509(fp, x509);

    /* Write CA chain */
    if (cachain) {
        for (int i = 0; i < sk_X509_INFO_num(cachain); i++) {
            X509_INFO *xi = sk_X509_INFO_value(cachain, i);
            if (xi && xi->x509) {
                PEM_write_X509(fp, xi->x509);
            }
        }
    }

    /* Write private key */
    PEM_write_PrivateKey(fp, key, NULL, NULL, 0, NULL, NULL);
    fclose(fp);
    
#ifdef DEBUG
    log_msg(LGG_NOTICE, "cert generated to disk: %s", pem_fn);
#endif

free_all:
    free(pem_fn);
    EVP_PKEY_free(key);
    X509_EXTENSION_free(ext);
    X509_free(x509);
    if (p_ctx) {
#if OPENSSL_API_1_1
        EVP_MD_CTX_free(p_ctx);
#else
        EVP_MD_CTX_destroy(p_ctx);
#endif
    }
}

int pem_passwd_cb(char *buf, int size, int rwflag, void *u) {
    int rv = 0, fp;
    char *fname = NULL;
    
    if (asprintf(&fname, "%s/rootCA/ca.key.passphrase", (char*)u) < 0)
        goto quit_cb;

    if ((fp = open(fname, O_RDONLY)) < 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to open ca.key.passphrase", __FUNCTION__);
#endif
    } else {
        rv = read(fp, buf, size - 1);
        close(fp);
        if (rv > 0 && buf[rv-1] == '\n') {
            rv--; /* trim newline */
        }
        if (rv > 0) buf[rv] = '\0';
#ifdef DEBUG
        log_msg(LGG_DEBUG, "%s: passphrase length %d", __FUNCTION__, rv);
#endif
    }

quit_cb:
    free(fname);
    return rv;
}

void cert_tlstor_init(const char *pem_dir, cert_tlstor_t *ct)
{
    FILE *fp = NULL;
    char cert_file[SSLGATENX_MAX_PATH];
    X509 *x509 = NULL;

    memset(ct, 0, sizeof(cert_tlstor_t));
    
    /* Load CA certificate */
    snprintf(cert_file, SSLGATENX_MAX_PATH, "%s/rootCA/ca.crt", pem_dir);
    fp = fopen(cert_file, "r");
    x509 = X509_new();

    if (!fp || !x509 || !PEM_read_X509(fp, &x509, NULL, NULL)) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to load ca.crt", __FUNCTION__);
#endif
        goto cleanup_ca;
    }

    /* Read entire CA file for chain */
    char *cafile = NULL;
    long fsz;
    
    if (fseek(fp, 0L, SEEK_END) < 0 || (fsz = ftell(fp)) < 0 || fseek(fp, 0L, SEEK_SET) < 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to seek ca.crt", __FUNCTION__);
#endif
        goto cleanup_ca;
    }

    cafile = malloc(fsz + 1);
    if (!cafile || fread(cafile, 1, fsz, fp) != (size_t)fsz) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to read ca.crt", __FUNCTION__);
#endif
        free(cafile);
        goto cleanup_ca;
    }

    BIO *bioin = BIO_new_mem_buf(cafile, fsz);
    if (!bioin) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to create BIO mem buffer", __FUNCTION__);
#endif
        free(cafile);
        goto cleanup_ca;
    }

    ct->pem_dir = pem_dir;
    ct->cachain = PEM_X509_INFO_read_bio(bioin, NULL, NULL, NULL);
    ct->issuer = X509_NAME_dup(X509_get_subject_name(x509));

    if (!ct->cachain) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to read CA chains", __FUNCTION__);
#endif
    }

    BIO_free(bioin);
    free(cafile);

cleanup_ca:
    if (fp) fclose(fp);
    X509_free(x509);

    /* Load CA private key */
    snprintf(cert_file, SSLGATENX_MAX_PATH, "%s/rootCA/ca.key", pem_dir);
    fp = fopen(cert_file, "r");
    if (!fp || !PEM_read_PrivateKey(fp, &ct->privkey, pem_passwd_cb, (void*)pem_dir)) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to load ca.key", __FUNCTION__);
#endif
    }
    if (fp) fclose(fp);

    /* Generate universal IP certificate on startup */
    char universal_ip_file[SSLGATENX_MAX_PATH];
    snprintf(universal_ip_file, sizeof(universal_ip_file), "%s/universal_ips.pem", pem_dir);
    struct stat st;
    if (stat(universal_ip_file, &st) != 0 && ct->privkey && ct->issuer) {
        generate_universal_ip_cert(pem_dir, ct->issuer, ct->privkey, ct->cachain);
    }

    /* Start worker threads for certificate generation */
    cert_workers_shutdown = 0;
    for (int i = 0; i < 4; i++) {
        pthread_t tid;
        if (pthread_create(&tid, NULL, cert_worker, ct) == 0) {
            pthread_detach(tid);
        } else {
#ifdef DEBUG
            log_msg(LGG_ERR, "cert_worker: pthread_create failed");
#endif
        }
    }
}

void cert_tlstor_cleanup(cert_tlstor_t *c)
{
    if (!c) return;
    
    shutdown_cert_workers();
    
    sk_X509_INFO_pop_free(c->cachain, X509_INFO_free);
    X509_NAME_free(c->issuer);
    EVP_PKEY_free(c->privkey);
    
    memset(c, 0, sizeof(*c));
}

void *cert_generator(void *ptr) {
#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: thread up and running", __FUNCTION__);
#endif
    int idle = 0;
    cert_tlstor_t *ct = (cert_tlstor_t *) ptr;

    char buf[SSLGATENX_MAX_SERVER_NAME * 4 + 1];
    char *half_token = buf + SSLGATENX_MAX_SERVER_NAME * 4;
    buf[SSLGATENX_MAX_SERVER_NAME * 4] = '\0';

    int fd = open(ssl_gate_pipe, O_RDONLY | O_NONBLOCK);
    srand((unsigned int)time(NULL));

    while (!cert_workers_shutdown) {
        if (fd == -1) {
#ifdef DEBUG
            log_msg(LGG_ERR, "%s: failed to open %s: %s", __FUNCTION__, ssl_gate_pipe, strerror(errno));
#endif
            sleep(1);
            fd = open(ssl_gate_pipe, O_RDONLY | O_NONBLOCK);
            continue;
        }
        
        strcpy(buf, half_token);
        struct pollfd pfd = { fd, POLLIN, 0 };
        int ret = poll(&pfd, 1, 1000 * SSLGATE_SSL_SESS_TIMEOUT / 4);
        
        if (ret <= 0) {
            /* timeout */
            sslctx_tbl_check_and_flush();
            if (kcc == 0) {
                if (++idle >= (3600 / (SSLGATE_SSL_SESS_TIMEOUT / 4))) {
                    conn_stor_flush();
                    idle = 0;
                }
#if defined(__GLIBC__) && !defined(__UCLIBC__)
                malloc_trim(0);
#endif
            }
            continue;
        }
        
        ssize_t cnt = read(fd, buf + strlen(half_token), SSLGATENX_MAX_SERVER_NAME * 4 - strlen(half_token));
        if (cnt == 0) {
#ifdef DEBUG
            log_msg(LGG_DEBUG, "%s: pipe EOF", __FUNCTION__);
#endif
            close(fd);
            fd = open(ssl_gate_pipe, O_RDONLY | O_NONBLOCK);
            continue;
        }
        
        if (cnt < 0) continue;
        
        if ((size_t)cnt < SSLGATENX_MAX_SERVER_NAME * 4 - strlen(half_token)) {
            buf[cnt + strlen(half_token)] = '\0';
            half_token = buf + SSLGATENX_MAX_SERVER_NAME * 4;
        } else {
            size_t i = 1;
            for (i = 1; buf[SSLGATENX_MAX_SERVER_NAME * 4 - i] != ':' && i < strlen(buf); i++);
            half_token = buf + SSLGATENX_MAX_SERVER_NAME * 4 - i + 1;
            buf[SSLGATENX_MAX_SERVER_NAME * 4 - i + 1] = '\0';
        }
        
        if (!ct->privkey || !ct->issuer) continue;
        
        char *p_buf, *p_buf_sav = NULL;
        p_buf = strtok_r(buf, ":", &p_buf_sav);
        while (p_buf != NULL) {
            char cert_file[SSLGATENX_MAX_PATH];
            struct stat st;
            snprintf(cert_file, SSLGATENX_MAX_PATH, "%s/%s", ct->pem_dir, p_buf);
            
            if (stat(cert_file, &st) != 0) { /* doesn't exist */
                enqueue_cert_job(p_buf);
            }
            p_buf = strtok_r(NULL, ":", &p_buf_sav);
        }
        
        sslctx_tbl_check_and_flush();
    }
    
    if (fd >= 0) close(fd);
    return NULL;
}
/*
 * src/http/http_responses.c - HTTP Response Templates
 * 
 * Alle statischen HTTP-Response-Templates und Konstanten
*/

#include "../http/http_responses.h"

// private data for socket_handler() use
const char httpcors_headers[] =
  "Access-Control-Allow-Origin: %s\r\n"
  "Access-Control-Allow-Credentials: true\r\n"
  "Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, documentReferer\r\n";

const char httpnulltext[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-Type: text/html; charset=UTF-8\r\n"
  "Connection: keep-alive\r\n"
  "Content-Length: 0\r\n"
  "%s" /* optional CORS */
  "\r\n";

// HTTP 204 No Content for Google generate_204 URLs
const char http204[] =
  "HTTP/1.1 204 No Content\r\n"
  "Content-Length: 0\r\n"
  "Content-Type: text/html; charset=UTF-8\r\n"
  "\r\n";

// HTML stats response pieces
const char httpstats1[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html\r\n"
  "Content-length: ";
// total content length goes between these two strings
const char httpstats2[] =
  "\r\n"
  "Connection: keep-alive\r\n"
  "\r\n";
// split here because we care about the length of what follows
const char httpstats3[] =
  "<!DOCTYPE html><html><head><link rel='icon' href='/favicon.ico' type='image/x-icon'/><meta name='viewport' content='width=device-width'><title>SSLGateNX statistics</title><style>body {font-family:monospace;} table {min-width: 75%; border-collapse: collapse;} th { height:18px; } td {border: 1px solid #e0e0e0; background-color: #f9f9f9;} td:first-child {width: 7%;} td:nth-child(2) {width: 15%; background-color: #ebebeb; border: 1px solid #f9f9f9;}</style></head><body>";
// stats text goes between these two strings
const char httpstats4[] =
  "</body></html>\r\n";

// note: the -2 is to avoid counting the last line ending characters
const unsigned int statsbaselen = sizeof httpstats3 + sizeof httpstats4 - 2;

// TXT stats response pieces
const char txtstats1[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/plain\r\n"
  "Content-length: ";
// total content length goes between these two strings
const char txtstats2[] =
  "\r\n"
  "Connection: keep-alive\r\n"
  "\r\n";
// split here because we care about the length of what follows
const char txtstats3[] =
  "\r\n";

const char httpredirect[] =
  "HTTP/1.1 307 Temporary Redirect\r\n"
  "Location: %s\r\n"
  "Content-type: text/plain\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "%s" /* optional CORS */
  "\r\n";

const char httpnullpixel[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: image/gif\r\n"
  "Content-length: 42\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "GIF89a" // header
  "\1\0\1\0"  // little endian width, height
  "\x80"    // Global Colour Table flag
  "\0"    // background colour
  "\0"    // default pixel aspect ratio
  "\1\1\1"  // RGB
  "\0\0\0"  // RBG black
  "!\xf9"  // Graphical Control Extension
  "\4"  // 4 byte GCD data follow
  "\1"  // there is transparent background color
  "\0\0"  // delay for animation
  "\0"  // transparent colour
  "\0"  // end of GCE block
  ","  // image descriptor
  "\0\0\0\0"  // NW corner
  "\1\0\1\0"  // height * width
  "\0"  // no local color table
  "\2"  // start of image LZW size
  "\1"  // 1 byte of LZW encoded image data
  "D"    // image data
  "\0"  // end of image data
  ";";  // GIF file terminator

const char http501[] =
  "HTTP/1.1 501 Method Not Implemented\r\n"
  "Connection: keep-alive\r\n"
  "\r\n";

const char httpnull_png[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: image/png\r\n"
  "Content-length: 67\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "\x89"
  "PNG"
  "\r\n"
  "\x1a\n"  // EOF
  "\0\0\0\x0d" // 13 bytes length
  "IHDR"
  "\0\0\0\1\0\0\0\1"  // width x height
  "\x08"  // bit depth
  "\x06"  // Truecolour with alpha
  "\0\0\0"  // compression, filter, interlace
  "\x1f\x15\xc4\x89"  // CRC
  "\0\0\0\x0a"  // 10 bytes length
  "IDAT"
  "\x78\x9c\x63\0\1\0\0\5\0\1"
  "\x0d\x0a\x2d\xb4"  // CRC
  "\0\0\0\0"  // 0 length
  "IEND"
  "\xae\x42\x60\x82";  // CRC

const char httpnull_jpg[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: image/jpeg\r\n"
  "Content-length: 159\r\n"
  "Connection: close\r\n"
  "\r\n"
  "\xff\xd8"  // SOI, Start Of Image
  "\xff\xe0"  // APP0
  "\x00\x10"  // length of section 16
  "JFIF\0"
  "\x01\x01"  // version 1.1
  "\x01"      // pixel per inch
  "\x00\x48"  // horizontal density 72
  "\x00\x48"  // vertical density 72
  "\x00\x00"  // size of thumbnail 0 x 0
  "\xff\xdb"  // DQT
  "\x00\x43"  // length of section 3+64
  "\x00"      // 0 QT 8 bit
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xc0"  // SOF
  "\x00\x0b"  // length 11
  "\x08\x00\x01\x00\x01\x01\x01\x11\x00"
  "\xff\xc4"  // DHT Define Huffman Table
  "\x00\x14"  // length 20
  "\x00\x01"  // DC table 1
  "\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00\x00\x00\x00\x03"
  "\xff\xc4"  // DHT
  "\x00\x14"  // length 20
  "\x10\x01"  // AC table 1
  "\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00\x00\x00\x00\x00"
  "\xff\xda"  // SOS, Start of Scan
  "\x00\x08"  // length 8
  "\x01"    // 1 component
  "\x01\x00"
  "\x00\x3f\x00"  // Ss 0, Se 63, AhAl 0
  "\x37" // image
  "\xff\xd9";  // EOI, End Of image

const char httpnull_swf[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: application/x-shockwave-flash\r\n"
  "Content-length: 25\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "FWS"
  "\x05"  // File version
  "\x19\x00\x00\x00"  // litle endian size 16+9=25
  "\x30\x0A\x00\xA0"  // Frame size 1 x 1
  "\x00\x01"  // frame rate 1 fps
  "\x01\x00"  // 1 frame
  "\x43\x02"  // tag type is 9 = SetBackgroundColor block 3 bytes long
  "\x00\x00\x00"  // black
  "\x40\x00"  // tag type 1 = show frame
  "\x00\x00";  // tag type 0 - end file

const char httpnull_ico[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: image/x-icon\r\n"
  "Cache-Control: max-age=2592000\r\n"
  "Content-length: 70\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "\x00\x00" // reserved 0
  "\x01\x00" // ico
  "\x01\x00" // 1 image
  "\x01\x01\x00" // 1 x 1 x >8bpp colour
  "\x00" // reserved 0
  "\x01\x00" // 1 colour plane
  "\x20\x00" // 32 bits per pixel
  "\x30\x00\x00\x00" // size 48 bytes
  "\x16\x00\x00\x00" // start of image 22 bytes in
  "\x28\x00\x00\x00" // size of DIB header 40 bytes
  "\x01\x00\x00\x00" // width
  "\x02\x00\x00\x00" // height
  "\x01\x00" // colour planes
  "\x20\x00" // bits per pixel
  "\x00\x00\x00\x00" // no compression
  "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00" // end of header
  "\x00\x00\x00\x00" // Colour table
  "\x00\x00\x00\x00" // XOR B G R
  "\x80\xF8\x9C\x41"; // AND ?

// === NEUE ASP/SERVER-SIDE SCRIPT RESPONSES ===

// ASP Classic Response
const char httpnull_asp[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "\r\n";

// ASPX Response  
const char httpnull_aspx[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "X-AspNet-Version: 4.0.30319\r\n"
  "\r\n";

// ASHX Response (Generic Handler)
const char httpnull_ashx[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: application/octet-stream\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "\r\n";

// PHP Response
const char httpnull_php[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "X-Powered-By: PHP/7.4.0\r\n"
  "\r\n";

// JSP Response
const char httpnull_jsp[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "\r\n";

// JavaScript Response
const char httpnull_js[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: application/javascript; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "\r\n";

const char httpoptions[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html\r\n"
  "Content-length: 11\r\n"
  "Allow: GET,OPTIONS\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "GET,OPTIONS";

const char httpcacert[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-Type: application/x-x509-ca-cert\r\n"
  "Accept-Ranges: bytes\r\n"
  "Content-Length: ";
const char httpcacert2[] =
  "\r\n"
  "\r\n";
/*
 * src/http/http_utils.c - HTTP Utility Functions
 * 
 * String-Manipulationen, URL-Dekodierung und Hilfsfunktionen
 * NUR Debug-Features und basis Utilities - KEIN normales Logging!
*/

#include "../util/util.h" // _GNU_SOURCE

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>

#include "../http/http_utils.h"

#ifdef DEBUG
#include "../log/logger.h"  // Nur fĆ¼r Debug-Features
#endif

#ifdef HEX_DUMP
// from http://sws.dett.de/mini/hexdump-c/
void hex_dump(void *data, int size)
{
  /* dumps size bytes of *data to stdout. Looks like:
   * [0000] 75 6E 6B 6E 6F 77 6E 20   30 FF 00 00 00 00 39 00 unknown 0.....9.
   * (in a single line of course)
   */

  if (!data || size <= 0) return;

  char *p = data;
  char c;
  int n;
  char bytestr[4] = {0};
  char addrstr[10] = {0};
  char hexstr[16*3 + 5] = {0};
  char charstr[16*1 + 5] = {0};
  
  // High-Load Fix: Thread-safe logging mit flockfile()
  flockfile(stdout);
  
  for (n = 1; n <= size; n++) {
    if (n%16 == 1) {
      // store address for this line - Fix: sichere Pointer-Arithmetik
      snprintf(addrstr, sizeof addrstr, "%.4x",
         (unsigned int)((uintptr_t)p - (uintptr_t)data) );
    }

    c = *p;
    if (isprint(c) == 0) {
      c = '.';
    }

    // store hex str (for left side)
    snprintf(bytestr, sizeof bytestr, "%02X ", (unsigned char)*p);
    strncat(hexstr, bytestr, sizeof hexstr - strlen(hexstr) - 1);

    // store char str (for right side)
    snprintf(bytestr, sizeof bytestr, "%c", c);
    strncat(charstr, bytestr, sizeof charstr - strlen(charstr) - 1);

    if (n%16 == 0) {
      // line completed
      printf("[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
      hexstr[0] = 0;
      charstr[0] = 0;
    } else if (n%8 == 0) {
      // half line: add whitespaces
      strncat(hexstr, "  ", sizeof hexstr - strlen(hexstr) - 1);
      strncat(charstr, " ", sizeof charstr - strlen(charstr) - 1);
    }

    p++; // next byte
  }

  if (strlen(hexstr) > 0) {
    // print rest of buffer if not empty
    printf("[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
  }
  
  funlockfile(stdout);
}
#endif // HEX_DUMP

// redirect utility functions
char* strstr_last(const char* const str1, const char* const str2) {
  char *strp;
  int len1, len2;
  len2 = strlen(str2);
  if (len2==0) {
    return (char *) str1;
  }
  len1 = strlen(str1);
  if (len1 - len2 <= 0) {
    return 0;
  }
  strp = (char *)(str1 + len1 - len2);
  while (strp != str1) {
    if (*strp == *str2 && strncmp(strp, str2, len2) == 0) {
      return strp;
    }
    strp--;
  }
  return 0;
}

/* strstr behavior undefined if one or more parameter is null.
   Not portable as MacOS default to crash. */
char* strstr_first(const char* const str1, const char* const str2) {
  if (!str1) return NULL;
  if (!str2) return (char*)str1;
  return strstr(str1, str2);
}

char from_hex(const char ch) {
  return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;
}

void urldecode(char* const decoded, char* const encoded) {
  char* pstr = encoded;
  char* pbuf = decoded;

  while (*pstr) {
    if (*pstr == '%') {
      if (pstr[1] && pstr[2]) {
        *pbuf++ = from_hex(pstr[1]) << 4 | from_hex(pstr[2]);
        pstr += 2;
      }
    } else {
      *pbuf++ = *pstr;
    }
    pstr++;
  }
  *pbuf = '\0';
}

void get_client_ip(int socket_fd, char *ip, int ip_len, char *port, int port_len)
{
  struct sockaddr_storage sin_addr;
  socklen_t sin_addr_len = sizeof(sin_addr);

  if (ip == NULL || ip_len <= 0 || (socket_fd < 0 && (ip[0] = '\0') == '\0'))
    return;

  if (getpeername(socket_fd, (struct sockaddr*)&sin_addr, &sin_addr_len) != 0 ||
      getnameinfo((struct sockaddr *)&sin_addr, sin_addr_len,
               ip, ip_len, port, port_len, NI_NUMERICHOST | NI_NUMERICSERV ) != 0) {
    ip[0] = '\0';
    // Kein Logging hier - wird in den aufrufenden Modulen gemacht
  }
}

#ifdef DEBUG
void child_signal_handler(int sig)
{
  if (sig != SIGTERM
   && sig != SIGUSR2) {
    log_msg(LGG_DEBUG, "Thread or child process ignoring unsupported signal number: %d", sig);
    return;
  }

  if (sig == SIGTERM) {
    // Ignore this signal while we are quitting
    signal(SIGTERM, SIG_IGN);
  }

  log_msg(LGG_DEBUG, "Thread or child process caught signal %d file %s", sig, __FILE__);

  if (sig == SIGTERM) {
    // exit program on SIGTERM
    log_msg(LGG_DEBUG, "Thread or child process exit on SIGTERM");
    exit(EXIT_SUCCESS);
  }

  return;
}
#endif
/*
 * src/sock/socket_handler.c - Socket Handler Koordination und Konfiguration
 * 
 * Nur noch Initialisierung, Konfiguration und ASP-Settings
 * Hauptlogik ist in connection_handler.c
*/

#include "../util/util.h" // _GNU_SOURCE

#include <string.h>

#include "../sock/socket_handler.h"
#include "../log/logger.h"

// =============================================================================
// ASP-KONFIGURATIONSFUNKTIONEN
// =============================================================================

// ASP-Handler Konfiguration
typedef struct {
    int enable_asp_logging;
    int enable_mime_detection;
    int cache_responses;
    char default_charset[32];
} asp_config_t;

// Globale ASP-Konfiguration (Thread-safe)
static asp_config_t asp_config = {
    .enable_asp_logging = 1,
    .enable_mime_detection = 1,
    .cache_responses = 0,
    .default_charset = "UTF-8"
};

// ASP-Handler Konfiguration setzen
void socket_handler_set_asp_config(int enable_logging, int enable_mime, const char *charset) {
    asp_config.enable_asp_logging = enable_logging;
    asp_config.enable_mime_detection = enable_mime;
    
    if (charset && strlen(charset) < sizeof(asp_config.default_charset)) {
        strncpy(asp_config.default_charset, charset, sizeof(asp_config.default_charset) - 1);
        asp_config.default_charset[sizeof(asp_config.default_charset) - 1] = '\0';
    }
}

// =============================================================================
// ERWEITERTE FUNKTIONEN FĆR SKALIERBARKEIT UND MONITORING
// =============================================================================

// Socket Handler Initialisierung
void socket_handler_init(void) {
    // Initialisierung der ASP-Konfiguration
    asp_config.enable_asp_logging = 1;
    asp_config.enable_mime_detection = 1;
    asp_config.cache_responses = 0;
    strncpy(asp_config.default_charset, "UTF-8", sizeof(asp_config.default_charset) - 1);
    asp_config.default_charset[sizeof(asp_config.default_charset) - 1] = '\0';
    
    log_msg(LGG_INFO, "Socket handler initialized with ASP support");
}

// Socket Handler Cleanup
void socket_handler_cleanup(void) {
    // Cleanup-Operationen falls erforderlich
    log_msg(LGG_INFO, "Socket handler cleanup completed");
}

// Metriken abrufen
void socket_handler_get_metrics(char *buffer, size_t size) {
    if (!buffer || size == 0) return;
    
    snprintf(buffer, size, 
        "ASP Support: %s\n"
        "MIME Detection: %s\n"
        "Default Charset: %s\n"
        "Cache Responses: %s\n",
        asp_config.enable_asp_logging ? "Enabled" : "Disabled",
        asp_config.enable_mime_detection ? "Enabled" : "Disabled",
        asp_config.default_charset,
        asp_config.cache_responses ? "Enabled" : "Disabled"
    );
}

// Thread Pool Konfiguration (Placeholder fĆ¼r zukĆ¼nftige Erweiterungen)
void socket_handler_set_thread_pool(int enable) {
    log_msg(LGG_DEBUG, "Thread pool %s", enable ? "enabled" : "disabled");
}

// Rate Limiting Konfiguration (Placeholder fĆ¼r zukĆ¼nftige Erweiterungen)
void socket_handler_set_rate_limit(int tokens_per_sec) {
    log_msg(LGG_DEBUG, "Rate limit set to %d tokens per second", tokens_per_sec);
}

// Memory Pool GrĆ¶Će (Placeholder fĆ¼r zukĆ¼nftige Erweiterungen)
void socket_handler_set_memory_pool_size(size_t size) {
    log_msg(LGG_DEBUG, "Memory pool size set to %zu bytes", size);
}
/*
 * src/sock/socket_io.c - Socket I/O Operations
 * 
 * Alle Low-Level Socket-Operationen und SSL-Funktionen
 */

#include "../util/util.h" // _GNU_SOURCE

#include <sys/socket.h>
#include <poll.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <errno.h>
#include <unistd.h>

#include "../sock/socket_io.h"
#include "../log/logger.h"

#ifdef TLS1_3_VERSION
// TLS 1.3 Early Data Support verfĆ¼gbar
#endif

int peek_socket(int fd, SSL *ssl) {
  char buf[10];
  int rv = -1;

  if (!ssl)
    rv = recv(fd, buf, 10, MSG_PEEK);
  else
    rv = SSL_peek(ssl, buf, 10);
  TESTPRINT("%s rv:%d\n", __FUNCTION__, rv);
  return rv;
}

int ssl_read(SSL *ssl, char *buf, int len) {
  int ssl_attempt = 1, ret;

redo_ssl_read:

  ERR_clear_error();
  ret = SSL_read(ssl, (char *)buf, len);
  if (ret <= 0) {
    int sslerr = SSL_get_error(ssl, ret);
    //log_msg(LGG_CRIT, "%s: ret:%d ssl error:%d", __FUNCTION__, ret, sslerr);
    switch(sslerr) {
      case SSL_ERROR_WANT_READ:
        ssl_attempt--;
        if (ssl_attempt > 0) goto redo_ssl_read;
        break;
      case SSL_ERROR_SSL:
        //log_msg(LGG_CRIT, "%s: ssl error %d", __FUNCTION__, ERR_peek_last_error());
        break;
      case SSL_ERROR_SYSCALL:
        //log_msg(LGG_CRIT, "%s: errno:%d", __FUNCTION__, errno);
      default:
        ;
    }
  }
  return ret;
}

int read_socket(int fd, char **msg, SSL *ssl, char *early_data)
{
  if (early_data) {
    log_msg(LGG_DEBUG, "%s: early data\n", __FUNCTION__);
    *msg = early_data;
    return strlen(early_data);
  }

  *msg = realloc(*msg, CHAR_BUF_SIZE + 1);
  if (!(*msg)) {
    log_msg(LGG_ERR, "Out of memory. Cannot malloc receiver buffer.");
    return -1;
  }

  int i, rv, msg_len = 0;
  char *bufptr = *msg;
  for (i=1; i<=MAX_CHAR_BUF_LOTS;) { /* 128K max with CHAR_BUF_SIZE == 4K */
    if (!ssl)
      rv = recv(fd, bufptr, CHAR_BUF_SIZE, 0);
    else
      rv = ssl_read(ssl, (char *)bufptr, CHAR_BUF_SIZE);
    
    if (rv <= 0) break;
    
    msg_len += rv;
    if (rv < CHAR_BUF_SIZE)
      break;
    else {
      ++i;
      // Fix: Memory-Leak bei realloc-Fehler vermeiden
      char *new_msg = realloc(*msg, CHAR_BUF_SIZE * i + 1);
      if (!new_msg) {
          log_msg(LGG_ERR, "Out of memory. Cannot realloc receiver buffer. Size: %d", CHAR_BUF_SIZE * i);
          return msg_len; /* start processing with whatever we received already */
      }
      *msg = new_msg;
      log_msg(LGG_DEBUG, "Realloc receiver buffer. Size: %d", CHAR_BUF_SIZE * i);
      bufptr = *msg + CHAR_BUF_SIZE * (i - 1);
    }
  }
  TESTPRINT("%s: fd:%d msg_len:%d ssl:%p\n", __FUNCTION__, fd, msg_len, ssl);
  return msg_len;
}

int ssl_write(SSL *ssl, const char *buf, int len) {
  int ssl_attempt = 1, ret;
redo_ssl_write:
  ERR_clear_error();
  ret = SSL_write(ssl, (char *)buf, len);
  if (ret <= 0) {
    int sslerr = SSL_get_error(ssl, ret);
    //log_msg(LGG_CRIT, "%s: ret:%d ssl error:%d", __FUNCTION__, ret, sslerr);
    switch(sslerr) {
      case SSL_ERROR_WANT_WRITE:
        ssl_attempt--;
        if (ssl_attempt > 0) goto redo_ssl_write;
        break;
      case SSL_ERROR_SSL:
        //log_msg(LGG_CRIT, "%s: ssl error %d", __FUNCTION__, ERR_peek_last_error());
        break;
      case SSL_ERROR_SYSCALL:
        //log_msg(LGG_CRIT, "%s: errno:%d", __FUNCTION__, errno);
      default:
        ;
    }
  }
  return ret;
}

int write_socket(int fd, const char *msg, int msg_len, SSL *ssl, char **early_data)
{
  int rv;
  if (ssl) {
#ifdef TLS1_3_VERSION
    if (*early_data) {
      log_msg(LGG_DEBUG, "%s: early data\n", __FUNCTION__);
      // Fix: SSL_write_early_data RĆ¼ckgabewert prĆ¼fen
      int early_rv = SSL_write_early_data(ssl, msg, msg_len, (size_t*)&rv);
      if (early_rv <= 0) {
        log_msg(LGG_ERR, "SSL_write_early_data failed: %d", early_rv);
        return -1;
      }

      /* finish the handshake. assume it'll simply succeed */
      if (SSL_accept(ssl) <= 0) {
        log_msg(LGG_ERR, "SSL_accept after early data failed");
        return -1;
      }

      /* job done. reset to NULL.
         memory freed when 'buf' in conn_hanlder freed */
      *early_data = NULL;

    } else
#endif
      rv = ssl_write(ssl, msg, msg_len);
  } else {
    /* a blocking call, so zero should not be returned */
    rv = send(fd, msg, msg_len, 0);
  }
  return rv;
}

int write_pipe(int fd, response_struct *pipedata) {
  // High-Load Fix: Atomarer write() mit Retry-Mechanismus
  // note that the parent must not perform a blocking pipe read without checking
  // for available data, or else it may deadlock when we don't write anything
  
  int attempts = 3;
  while (attempts--) {
    int rv = write(fd, pipedata, sizeof(*pipedata));
    
    if (rv == sizeof(*pipedata)) {
      return rv; // Erfolg
    }
    
    if (rv < 0) {
      if (errno == EINTR || errno == EAGAIN) {
        // Retry bei temporĆ¤ren Fehlern
        continue;
      }
      log_msg(LGG_ERR, "write() to pipe reported error: %m");
      return rv;
    } else if (rv == 0) {
      log_msg(LGG_ERR, "write() to pipe reported no data written and no error");
      return rv;
    } else {
      log_msg(LGG_ERR, "write() to pipe reported writing only %d bytes of expected %u (attempt %d)",
          rv, (unsigned int)sizeof(*pipedata), 3-attempts);
      // Partial write - retry
      continue;
    }
  }
  
  log_msg(LGG_ERR, "write_pipe failed after 3 attempts");
  return -1;
}
/*
 * src/comm/connection_handler.c - Optimized Buffer Management and Connection Handling
 * 
 * Enhanced connection lifecycle management with adaptive buffer allocation,
 * DOS client optimization, and high-performance memory management
 */

#include "../util/util.h"

#include <pthread.h>
#include <poll.h>
#include <sys/stat.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#include <signal.h>
#include <stdatomic.h>
#include <sys/mman.h>

#include "../comm/connection_handler.h"
#include "../sock/socket_io.h"
#include "../http/http_responses.h"
#include "../http/http_utils.h"
#include "../comm/request_processor.h"
#include "../log/logger.h"
#include "../addon/favicon.h"

extern struct Global *g;

// =============================================================================
// ADAPTIVE BUFFER MANAGEMENT
// =============================================================================

// Buffer allocation strategies
typedef enum {
    BUFFER_STRATEGY_STATIC,     // Fixed size buffers
    BUFFER_STRATEGY_ADAPTIVE,   // Size based on client type and history
    BUFFER_STRATEGY_ZERO_COPY,  // Memory-mapped buffers for large responses
    BUFFER_STRATEGY_POOLED      // Pre-allocated pool buffers
} buffer_strategy_t;

// Connection buffer context
typedef struct connection_buffer_ctx {
    char *primary_buffer;           // Main I/O buffer
    char *secondary_buffer;         // Overflow/temporary buffer
    char *response_buffer;          // Response construction buffer
    size_t primary_size;            // Size of primary buffer
    size_t secondary_size;          // Size of secondary buffer
    size_t response_size;           // Size of response buffer
    buffer_strategy_t strategy;     // Current allocation strategy
    int realloc_count;             // Number of reallocations
    atomic_size_t total_bytes_read; // Total bytes read in this connection
    atomic_size_t total_bytes_written; // Total bytes written
    int numa_node;                 // NUMA node for allocation
    char *mmap_region;             // Memory-mapped region for large responses
    size_t mmap_size;              // Size of mmap region
} connection_buffer_ctx_t;

// Buffer performance statistics
static atomic_long stat_buffer_reallocs = ATOMIC_VAR_INIT(0);
static atomic_long stat_buffer_overflows = ATOMIC_VAR_INIT(0);
static atomic_long stat_zero_copy_uses = ATOMIC_VAR_INIT(0);
static atomic_long stat_mmap_allocations = ATOMIC_VAR_INIT(0);
static atomic_long stat_adaptive_upgrades = ATOMIC_VAR_INIT(0);
static atomic_long stat_adaptive_downgrades = ATOMIC_VAR_INIT(0);

// Thread-local buffer cache (to reduce allocation overhead)
static __thread char *tls_buffer_cache[8] = {NULL};
static __thread size_t tls_buffer_sizes[8] = {0};
static __thread int tls_cache_initialized = 0;

// =============================================================================
// THREAD-LOCAL BUFFER CACHE
// =============================================================================

static void init_tls_buffer_cache(void) {
    if (tls_cache_initialized) return;
    
    // Pre-allocate common buffer sizes
    const size_t common_sizes[] = {
        BUFFER_SIZE_TINY, BUFFER_SIZE_SMALL, BUFFER_SIZE_MEDIUM, 
        BUFFER_SIZE_LARGE, BUFFER_SIZE_HUGE, BUFFER_SIZE_MASSIVE,
        8192, 32768 // Additional common sizes
    };
    
    for (int i = 0; i < 8; i++) {
        tls_buffer_cache[i] = malloc(common_sizes[i]);
        tls_buffer_sizes[i] = common_sizes[i];
        
        if (!tls_buffer_cache[i]) {
            log_msg(LGG_WARNING, "Failed to allocate TLS buffer cache entry %d", i);
            tls_buffer_sizes[i] = 0;
        }
    }
    
    tls_cache_initialized = 1;
    LOG_MSG(LGG_DEBUG, "TLS buffer cache initialized for thread %lu", pthread_self());
}

static char* get_tls_cached_buffer(size_t size) {
    if (!tls_cache_initialized) {
        init_tls_buffer_cache();
    }
    
    // Find best-fit buffer from cache
    for (int i = 0; i < 8; i++) {
        if (tls_buffer_sizes[i] >= size && tls_buffer_cache[i]) {
            char *buffer = tls_buffer_cache[i];
            tls_buffer_cache[i] = NULL; // Mark as in use
            return buffer;
        }
    }
    
    return NULL; // No suitable cached buffer
}

static void return_tls_cached_buffer(char *buffer, size_t size) {
    if (!buffer || !tls_cache_initialized) return;
    
    // Find empty slot to cache this buffer
    for (int i = 0; i < 8; i++) {
        if (!tls_buffer_cache[i] && tls_buffer_sizes[i] == size) {
            tls_buffer_cache[i] = buffer;
            return;
        }
    }
    
    // No matching slot, just free it
    free(buffer);
}

// =============================================================================
// ADAPTIVE BUFFER ALLOCATION
// =============================================================================

static size_t calculate_optimal_buffer_size(dos_client_info_t *dos_info, 
                                           connection_buffer_ctx_t *buf_ctx,
                                           size_t requested_size) {
    size_t base_size;
    
    // Determine base size based on client type
    if (dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        // DOS clients prefer smaller buffers
        if (requested_size <= BUFFER_SIZE_TINY) {
            base_size = BUFFER_SIZE_TINY;
        } else if (requested_size <= BUFFER_SIZE_SMALL) {
            base_size = BUFFER_SIZE_SMALL;
        } else {
            base_size = BUFFER_SIZE_MEDIUM; // Cap DOS client buffers
        }
    } else {
        // Modern clients can handle larger buffers
        if (requested_size <= BUFFER_SIZE_SMALL) {
            base_size = BUFFER_SIZE_MEDIUM; // Start bigger for modern clients
        } else if (requested_size <= BUFFER_SIZE_MEDIUM) {
            base_size = BUFFER_SIZE_LARGE;
        } else if (requested_size <= BUFFER_SIZE_LARGE) {
            base_size = BUFFER_SIZE_HUGE;
        } else {
            base_size = BUFFER_SIZE_MASSIVE;
        }
    }
    
    // Adaptive sizing based on connection history
    if (buf_ctx) {
        size_t avg_read = atomic_load_explicit(&buf_ctx->total_bytes_read, memory_order_relaxed);
        size_t avg_written = atomic_load_explicit(&buf_ctx->total_bytes_written, memory_order_relaxed);
        
        if (avg_read > base_size * 2 || avg_written > base_size * 2) {
            // Connection tends to use large amounts of data
            base_size = min(base_size * 2, BUFFER_SIZE_MASSIVE);
            atomic_fetch_add_explicit(&stat_adaptive_upgrades, 1, memory_order_relaxed);
        } else if (avg_read < base_size / 4 && avg_written < base_size / 4 && buf_ctx->realloc_count == 0) {
            // Connection uses small amounts of data consistently
            base_size = max(base_size / 2, BUFFER_SIZE_TINY);
            atomic_fetch_add_explicit(&stat_adaptive_downgrades, 1, memory_order_relaxed);
        }
    }
    
    return base_size;
}

static char* allocate_adaptive_buffer(size_t size, dos_client_info_t *dos_info, 
                                     connection_buffer_ctx_t *buf_ctx) {
    // Try thread-local cache first
    char *buffer = get_tls_cached_buffer(size);
    if (buffer) {
        log_msg(LGG_DEBUG, "Using TLS cached buffer (%zu bytes)", size);
        return buffer;
    }
    
    // Determine NUMA node
    int numa_node = (buf_ctx && buf_ctx->numa_node >= 0) ? buf_ctx->numa_node : get_current_numa_node();
    
    // Use optimized buffer pool
    buffer = get_optimized_buffer(size, 
                                 dos_info ? atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) : 0,
                                 numa_node);
    
    if (buffer) {
        log_msg(LGG_DEBUG, "Allocated adaptive buffer: %zu bytes, NUMA node %d, DOS client: %s",
                size, numa_node, 
                (dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) ? "yes" : "no");
        return buffer;
    }
    
    // Fallback to regular malloc
    buffer = malloc(size);
    if (!buffer) {
        log_msg(LGG_ERR, "Failed to allocate buffer: %zu bytes", size);
    }
    
    return buffer;
}

static void free_adaptive_buffer(char *buffer, size_t size, connection_buffer_ctx_t *buf_ctx) {
    if (!buffer) return;
    
    // Try to return to thread-local cache
    if (size <= BUFFER_SIZE_MASSIVE) {
        return_tls_cached_buffer(buffer, size);
        return;
    }
    
    // Return to optimized buffer pool
    return_optimized_buffer(buffer, size);
}

// =============================================================================
// ZERO-COPY BUFFER OPERATIONS
// =============================================================================

static int setup_zero_copy_buffer(connection_buffer_ctx_t *buf_ctx, size_t min_size) {
    if (buf_ctx->mmap_region) {
        // Already have mmap region
        if (buf_ctx->mmap_size >= min_size) {
            return 0; // Existing region is sufficient
        }
        
        // Need to resize - unmap old region
        munmap(buf_ctx->mmap_region, buf_ctx->mmap_size);
        buf_ctx->mmap_region = NULL;
        buf_ctx->mmap_size = 0;
    }
    
    // Calculate optimal mmap size (page-aligned)
    size_t page_size = getpagesize();
    size_t mmap_size = ALIGN_UP(max(min_size, 1024 * 1024), page_size); // Minimum 1MB
    
    // Create memory-mapped region
    buf_ctx->mmap_region = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE,
                               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    if (buf_ctx->mmap_region == MAP_FAILED) {
        buf_ctx->mmap_region = NULL;
        buf_ctx->mmap_size = 0;
        log_msg(LGG_WARNING, "Failed to create zero-copy buffer: %zu bytes", mmap_size);
        return -1;
    }
    
    buf_ctx->mmap_size = mmap_size;
    atomic_fetch_add_explicit(&stat_mmap_allocations, 1, memory_order_relaxed);
    
    log_msg(LGG_DEBUG, "Created zero-copy buffer: %zu bytes", mmap_size);
    return 0;
}

static char* get_zero_copy_buffer(connection_buffer_ctx_t *buf_ctx, size_t size) {
    if (!buf_ctx) return NULL;
    
    // Use zero-copy for large responses
    if (size >= 64 * 1024) { // 64KB threshold
        if (setup_zero_copy_buffer(buf_ctx, size) == 0) {
            atomic_fetch_add_explicit(&stat_zero_copy_uses, 1, memory_order_relaxed);
            return buf_ctx->mmap_region;
        }
    }
    
    return NULL;
}

// =============================================================================
// ENHANCED SOCKET I/O WITH ADAPTIVE BUFFERS
// =============================================================================

static int read_socket_adaptive(int fd, char **msg, SSL *ssl, char *early_data,
                               dos_client_info_t *dos_info, connection_buffer_ctx_t *buf_ctx) {
    if (early_data) {
        log_msg(LGG_DEBUG, "Using early data for %s client",
                dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular");
        *msg = early_data;
        return strlen(early_data);
    }
    
    // Calculate optimal initial buffer size
    size_t initial_size = calculate_optimal_buffer_size(dos_info, buf_ctx, BUFFER_SIZE_MEDIUM);
    
    // Allocate initial buffer
    *msg = allocate_adaptive_buffer(initial_size, dos_info, buf_ctx);
    if (!*msg) {
        log_msg(LGG_ERR, "Failed to allocate initial read buffer");
        return -1;
    }
    
    buf_ctx->primary_buffer = *msg;
    buf_ctx->primary_size = initial_size;
    
    int total_read = 0;
    char *current_pos = *msg;
    size_t remaining_space = initial_size;
    int consecutive_small_reads = 0;
    
    // Adaptive read loop
    for (int iteration = 0; iteration < 32; iteration++) { // Limit iterations
        int bytes_read;
        
        if (!ssl) {
            bytes_read = recv(fd, current_pos, remaining_space, 0);
        } else {
            bytes_read = ssl_read(ssl, current_pos, remaining_space);
        }
        
        if (bytes_read <= 0) {
            break; // End of data or error
        }
        
        total_read += bytes_read;
        atomic_fetch_add_explicit(&buf_ctx->total_bytes_read, bytes_read, memory_order_relaxed);
        
        // Check for DOS client patterns
        if (dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
            if (bytes_read < remaining_space / 4) {
                consecutive_small_reads++;
                if (consecutive_small_reads >= 3) {
                    log_msg(LGG_DEBUG, "DOS client sending small packets, ending read early");
                    break;
                }
            }
        }
        
        // If we filled the buffer, we might need more space
        if (bytes_read == remaining_space) {
            // Calculate new size based on read pattern
            size_t new_size = buf_ctx->primary_size;
            
            if (dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
                // Conservative expansion for DOS clients
                new_size = min(new_size + BUFFER_SIZE_SMALL, BUFFER_SIZE_MEDIUM);
            } else {
                // Aggressive expansion for modern clients
                new_size = min(new_size * 2, BUFFER_SIZE_MASSIVE);
            }
            
            // Try to expand buffer
            char *expanded = allocate_adaptive_buffer(new_size, dos_info, buf_ctx);
            if (expanded) {
                memcpy(expanded, *msg, total_read);
                free_adaptive_buffer(*msg, buf_ctx->primary_size, buf_ctx);
                
                *msg = expanded;
                buf_ctx->primary_buffer = expanded;
                buf_ctx->primary_size = new_size;
                current_pos = expanded + total_read;
                remaining_space = new_size - total_read;
                
                buf_ctx->realloc_count++;
                atomic_fetch_add_explicit(&stat_buffer_reallocs, 1, memory_order_relaxed);
                
                log_msg(LGG_DEBUG, "Expanded read buffer: %zu -> %zu bytes (realloc #%d)",
                        buf_ctx->primary_size / 2, new_size, buf_ctx->realloc_count);
            } else {
                log_msg(LGG_WARNING, "Failed to expand read buffer, stopping at %d bytes", total_read);
                atomic_fetch_add_explicit(&stat_buffer_overflows, 1, memory_order_relaxed);
                break;
            }
        } else {
            // Partial read, update pointers
            current_pos += bytes_read;
            remaining_space -= bytes_read;
            consecutive_small_reads = 0;
        }
        
        // For small reads, don't continue trying to read more
        if (bytes_read < remaining_space / 2) {
            break;
        }
    }
    
    log_msg(LGG_DEBUG, "Adaptive read completed: %d bytes, %d reallocations, %s client",
            total_read, buf_ctx->realloc_count,
            dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular");
    
    return total_read;
}

static int write_socket_adaptive(int fd, const char *msg, int msg_len, SSL *ssl, 
                                char **early_data, dos_client_info_t *dos_info,
                                connection_buffer_ctx_t *buf_ctx) {
    if (!msg || msg_len <= 0) return 0;
    
    atomic_fetch_add_explicit(&buf_ctx->total_bytes_written, msg_len, memory_order_relaxed);
    
    // Handle TLS 1.3 early data
    if (ssl && *early_data) {
#ifdef TLS1_3_VERSION
        log_msg(LGG_DEBUG, "Writing early data for %s client",
                dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular");
        
        size_t written;
        int early_rv = SSL_write_early_data(ssl, msg, msg_len, &written);
        if (early_rv <= 0) {
            log_msg(LGG_ERR, "SSL_write_early_data failed: %d", early_rv);
            return -1;
        }
        
        if (SSL_accept(ssl) <= 0) {
            log_msg(LGG_ERR, "SSL_accept after early data failed");
            return -1;
        }
        
        *early_data = NULL;
        return written;
#endif
    }
    
    // Adaptive writing for DOS clients
    if (dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        // DOS clients may have small receive buffers, send in chunks
        if (msg_len > BUFFER_SIZE_SMALL) {
            log_msg(LGG_DEBUG, "Chunked write for DOS client: %d bytes", msg_len);
            
            int total_sent = 0;
            int chunk_size = BUFFER_SIZE_TINY; // Small chunks for DOS
            
            while (total_sent < msg_len) {
                int remaining = msg_len - total_sent;
                int send_size = min(remaining, chunk_size);
                
                int sent;
                if (ssl) {
                    sent = ssl_write(ssl, msg + total_sent, send_size);
                } else {
                    sent = send(fd, msg + total_sent, send_size, 0);
                }
                
                if (sent <= 0) {
                    log_msg(LGG_WARNING, "DOS client write failed at chunk %d/%d", total_sent, msg_len);
                    return sent;
                }
                
                total_sent += sent;
                
                // Small delay between chunks for DOS clients
                if (total_sent < msg_len) {
                    usleep(5000); // 5ms delay
                }
            }
            
            return total_sent;
        }
    }
    
    // Regular write for modern clients or small messages
    int result;
    if (ssl) {
        result = ssl_write(ssl, msg, msg_len);
    } else {
        result = send(fd, msg, msg_len, 0);
    }
    
    return result;
}

// =============================================================================
// CONNECTION BUFFER CONTEXT MANAGEMENT
// =============================================================================

static connection_buffer_ctx_t* create_buffer_context(dos_client_info_t *dos_info) {
    connection_buffer_ctx_t *ctx = calloc(1, sizeof(connection_buffer_ctx_t));
    if (!ctx) {
        log_msg(LGG_ERR, "Failed to allocate buffer context");
        return NULL;
    }
    
    // Initialize atomic variables
    atomic_init(&ctx->total_bytes_read, 0);
    atomic_init(&ctx->total_bytes_written, 0);
    
    // Set strategy based on client type
    if (dos_info && atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        ctx->strategy = BUFFER_STRATEGY_STATIC; // DOS clients prefer predictable behavior
    } else {
        ctx->strategy = BUFFER_STRATEGY_ADAPTIVE; // Modern clients can handle adaptive sizing
    }
    
    ctx->numa_node = get_current_numa_node();
    
    log_msg(LGG_DEBUG, "Created buffer context: strategy=%d, NUMA node=%d",
            ctx->strategy, ctx->numa_node);
    
    return ctx;
}

static void cleanup_buffer_context(connection_buffer_ctx_t *ctx) {
    if (!ctx) return;
    
    // Free all allocated buffers
    if (ctx->primary_buffer) {
        free_adaptive_buffer(ctx->primary_buffer, ctx->primary_size, ctx);
    }
    
    if (ctx->secondary_buffer) {
        free_adaptive_buffer(ctx->secondary_buffer, ctx->secondary_size, ctx);
    }
    
    if (ctx->response_buffer) {
        // Check if it's a zero-copy buffer
        if (ctx->mmap_region && ctx->response_buffer == ctx->mmap_region) {
            // Don't free - will be unmapped below
        } else {
            free_adaptive_buffer(ctx->response_buffer, ctx->response_size, ctx);
        }
    }
    
    // Unmap zero-copy region
    if (ctx->mmap_region) {
        munmap(ctx->mmap_region, ctx->mmap_size);
    }
    
    size_t total_read = atomic_load_explicit(&ctx->total_bytes_read, memory_order_relaxed);
    size_t total_written = atomic_load_explicit(&ctx->total_bytes_written, memory_order_relaxed);
    
    log_msg(LGG_DEBUG, "Buffer context cleanup: read=%zu bytes, written=%zu bytes, reallocations=%d",
            total_read, total_written, ctx->realloc_count);
    
    free(ctx);
}

// =============================================================================
// ENHANCED CONNECTION HANDLER
// =============================================================================

void* conn_handler_optimized(void *ptr) {
    connection_optimized_t *conn = (connection_optimized_t*)ptr;
    if (!conn) {
        log_msg(LGG_ERR, "NULL connection pointer passed to handler");
        return NULL;
    }
    
    // Create buffer context
    connection_buffer_ctx_t *buf_ctx = create_buffer_context(&conn->dos_info);
    if (!buf_ctx) {
        log_msg(LGG_ERR, "Failed to create buffer context");
        release_connection(conn);
        return NULL;
    }
    
    // Initialize thread-local cache if needed
    if (!tls_cache_initialized) {
        init_tls_buffer_cache();
    }
    
    // Set thread NUMA affinity
    set_thread_numa_affinity(conn->numa_node);
    
    int fd = conn->fd;
    SSL *ssl = conn->ssl;
    dos_client_info_t *dos_info = &conn->dos_info;
    
    // Configure socket timeouts based on client type
    struct timeval timeout;
    if (atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        timeout.tv_sec = 30; // Longer timeout for DOS clients
        timeout.tv_usec = 0;
    } else {
        timeout.tv_sec = 5;  // Shorter timeout for modern clients
        timeout.tv_usec = 0;
    }
    
    setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
    setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
    
    // Additional socket optimizations for DOS clients
    if (atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        int bufsize = BUFFER_SIZE_SMALL;
        setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize));
        setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(bufsize));
        
        // Enable Nagle's algorithm for DOS clients (reduce packet overhead)
        int nodelay = 0;
        setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &nodelay, sizeof(nodelay));
    }
    
    char *recv_buffer = NULL;
    int requests_processed = 0;
    
    log_msg(LGG_DEBUG, "Starting optimized connection handler for %s client (fd=%d, NUMA=%d)",
            atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular",
            fd, conn->numa_node);
    
    // Main request processing loop
    while (1) {
        // Wait for data with adaptive polling
        struct pollfd pfd = {fd, POLLIN, 0};
        int poll_timeout = atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? 30000 : 5000;
        
        int poll_result = poll(&pfd, 1, poll_timeout);
        if (poll_result <= 0) {
            if (poll_result == 0) {
                log_msg(LGG_DEBUG, "Connection timeout for %s client after %d requests",
                        atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular",
                        requests_processed);
            } else {
                log_msg(LGG_DEBUG, "Poll error for %s client: %m",
                        atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular");
            }
            break;
        }
        
        // Read request with adaptive buffering
        int bytes_read = read_socket_adaptive(fd, &recv_buffer, ssl, NULL, dos_info, buf_ctx);
        if (bytes_read <= 0) {
            if (bytes_read < 0) {
                log_msg(LGG_DEBUG, "Read error for %s client: %m",
                        atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular");
            } else {
                log_msg(LGG_DEBUG, "%s client closed connection",
                        atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular");
            }
            break;
        }
        
        // Null-terminate the received data
        recv_buffer[bytes_read] = '\0';
        
        // Process request (simplified for this example)
        char *response = NULL;
        int response_size = 0;
        
        // Determine response size and allocate appropriate buffer
        if (strstr(recv_buffer, "GET /favicon.ico") != NULL) {
            // Small response
            response_size = 1024;
        } else if (strstr(recv_buffer, "GET /") != NULL) {
            // Medium response
            response_size = BUFFER_SIZE_MEDIUM;
        } else {
            // Default response
            response_size = BUFFER_SIZE_SMALL;
        }
        
        // Try zero-copy allocation for large responses
        response = get_zero_copy_buffer(buf_ctx, response_size);
        if (!response) {
            response = allocate_adaptive_buffer(response_size, dos_info, buf_ctx);
        }
        
        if (response) {
            // Generate simple response
            response_size = snprintf(response, response_size,
                "HTTP/1.1 200 OK\r\n"
                "Content-Type: text/html\r\n"
                "Content-Length: 0\r\n"
                "Connection: keep-alive\r\n"
                "\r\n");
            
            buf_ctx->response_buffer = response;
            buf_ctx->response_size = response_size;
            
            // Send response with adaptive writing
            int bytes_sent = write_socket_adaptive(fd, response, response_size, ssl, NULL, dos_info, buf_ctx);
            if (bytes_sent != response_size) {
                log_msg(LGG_WARNING, "Incomplete write for %s client: %d/%d bytes",
                        atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular",
                        bytes_sent, response_size);
                break;
            }
            
            // Clean up response buffer
            if (response != buf_ctx->mmap_region) {
                free_adaptive_buffer(response, buf_ctx->response_size, buf_ctx);
            }
            buf_ctx->response_buffer = NULL;
            buf_ctx->response_size = 0;
        }
        
        requests_processed++;
        
        // DOS clients might want to close connection after each request
        if (atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
            if (strstr(recv_buffer, "Connection: close") != NULL) {
                log_msg(LGG_DEBUG, "DOS client requested connection close");
                break;
            }
        }
        
        // Limit requests per connection to prevent resource exhaustion
        if (requests_processed >= 1000) {
            log_msg(LGG_INFO, "Connection processed maximum requests (%d), closing", requests_processed);
            break;
        }
    }
    
    // Connection cleanup
    log_msg(LGG_DEBUG, "Closing optimized connection for %s client (fd=%d, requests=%d)",
            atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed) ? "DOS" : "regular",
            fd, requests_processed);
    
    // Update DOS client statistics
    if (atomic_load_explicit(&dos_info->is_dos_client, memory_order_relaxed)) {
        atomic_fetch_sub_explicit(&stat_dos_clients_active, 1, memory_order_relaxed);
    }
    
    // Cleanup resources
    cleanup_buffer_context(buf_ctx);
    release_connection(conn);
    
    return NULL;
}

// =============================================================================
// BUFFER MANAGEMENT STATISTICS
// =============================================================================

void print_buffer_management_stats(void) {
    printf("\n=== Buffer Management Statistics ===\n");
    printf("Buffer reallocations: %ld\n", atomic_load_explicit(&stat_buffer_reallocs, memory_order_relaxed));
    printf("Buffer overflows: %ld\n", atomic_load_explicit(&stat_buffer_overflows, memory_order_relaxed));
    printf("Zero-copy buffer uses: %ld\n", atomic_load_explicit(&stat_zero_copy_uses, memory_order_relaxed));
    printf("Memory-mapped allocations: %ld\n", atomic_load_explicit(&stat_mmap_allocations, memory_order_relaxed));
    printf("Adaptive upgrades: %ld\n", atomic_load_explicit(&stat_adaptive_upgrades, memory_order_relaxed));
    printf("Adaptive downgrades: %ld\n", atomic_load_explicit(&stat_adaptive_downgrades, memory_order_relaxed));
    
    // Thread-local cache statistics
    if (tls_cache_initialized) {
        int cached_buffers = 0;
        for (int i = 0; i < 8; i++) {
            if (tls_buffer_cache[i]) cached_buffers++;
        }
        printf("TLS cached buffers: %d/8\n", cached_buffers);
    }
    
    printf("====================================\n");
}

void reset_buffer_management_stats(void) {
    atomic_store_explicit(&stat_buffer_reallocs, 0, memory_order_relaxed);
    atomic_store_explicit(&stat_buffer_overflows, 0, memory_order_relaxed);
    atomic_store_explicit(&stat_zero_copy_uses, 0, memory_order_relaxed);
    atomic_store_explicit(&stat_mmap_allocations, 0, memory_order_relaxed);
    atomic_store_explicit(&stat_adaptive_upgrades, 0, memory_order_relaxed);
    atomic_store_explicit(&stat_adaptive_downgrades, 0, memory_order_relaxed);
    
    log_msg(LGG_INFO, "Buffer management statistics reset");
}

// =============================================================================
// CLEANUP FUNCTIONS
// =============================================================================

void cleanup_tls_buffer_cache(void) {
    if (!tls_cache_initialized) return;
    
    for (int i = 0; i < 8; i++) {
        if (tls_buffer_cache[i]) {
            free(tls_buffer_cache[i]);
            tls_buffer_cache[i] = NULL;
            tls_buffer_sizes[i] = 0;
        }
    }
    
    tls_cache_initialized = 0;
    log_msg(LGG_DEBUG, "TLS buffer cache cleanup completed for thread %lu", pthread_self());
}
/*
 * src/comm/request_processor.c - HTTP Request Processing
 * 
 * Verarbeitung von GET-Requests und File-Extension-Handling
 * HIER WERDEN DIE 290+ EXTENSIONS HINZUGEFĆGT
*/

#include "../util/util.h" // _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "request_processor.h"
#include "../http/http_responses.h"
#include "../http/http_utils.h"
#include "../log/logger.h"

// Externe Favicon-Definitionen (in connection_handler.c definiert)
extern unsigned char favicon_ico[];
extern unsigned int favicon_ico_len;

// Externe Funktionen die wir brauchen
extern char* get_version(int argc, char **argv);
extern char* get_stats(int html, int text);

response_enum process_get_request(char *path, char *host, char **response, int *rsize, 
                                  char **aspbuf, int allow_admin, 
                                  const char *stats_url, const char *stats_text_url,
                                  const char *pem_dir, int argc, char **argv,
                                  int do_204, int do_redirect, char *bufptr,
                                  char *cors_origin)
{
    char *version_string = NULL;
    char *stat_string = NULL;
    char *url = NULL;
    
    if (!strncmp(path, "/favicon.ico", 12)) {
        // favicon aus eingebettetem Header ausliefern
        size_t favicon_len = favicon_ico_len;
        // HTTPā€‘Header
        char hdr[128];
        int hdrlen = snprintf(hdr, sizeof hdr,
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: image/x-icon\r\n"
            "Content-Length: %zu\r\n"
            "Connection: keep-alive\r\n"
            "\r\n",
            favicon_len);
        
        // Hier mĆ¼sste write_socket aufgerufen werden, aber das ist nicht in diesem Modul
        // Das wird in connection_handler.c gemacht
        (void)hdrlen; // Suppress unused warning
        return SEND_ICO;
        
    } else if (!strncmp(path, "/log=", 5) && allow_admin) {
        // Fix: Input-Validierung fĆ¼r log-Level
        if (strlen(path) <= 5) {
            return SEND_BAD;
        } else {
            int v = atoi(path + strlen("/log="));
            if (v > LGG_DEBUG || v < 0)
                return SEND_BAD;
            else {
                return ACTION_LOG_VERB;
            }
        }
    } else if (!strncmp(path, "/ca.crt", 7)) {
        FILE *fp;
        char *ca_file = NULL;
        // Fix: KEINE 404! Immer erfolgreiche Response
        *response = (char*)httpnulltext;
        *rsize = strlen(httpnulltext);

        // Fix: asprintf RĆ¼ckgabewert korrekt prĆ¼fen (-1 = Fehler)
        if (asprintf(&ca_file, "%s%s", pem_dir, "/ca.crt") != -1 &&
           NULL != (fp = fopen(ca_file, "r")))
        {
            fseek(fp, 0L, SEEK_END);
            long file_sz = ftell(fp);
            rewind(fp);
            *rsize = asprintf(aspbuf, "%s%ld%s", httpcacert, file_sz, httpcacert2);
            if (*rsize != -1 && (*aspbuf = (char*)realloc(*aspbuf, *rsize + file_sz + 16)) != NULL &&
                   fread(*aspbuf + *rsize, 1, file_sz, fp) == (size_t)file_sz) {
                                                            // should be fairly safe to cast here
              *response = *aspbuf;
              *rsize += file_sz;
            }
            fclose(fp);
        }
        if (ca_file) free(ca_file);
        return SEND_TXT;
        
    } else if (!strcmp(path, stats_url) && allow_admin) {
        version_string = get_version(argc, argv);
        stat_string = get_stats(1, 0);
        if (version_string && stat_string) {
            *rsize = asprintf(aspbuf,
                           "%s%u%s%s%s<br>%s%s",
                           httpstats1,
                           (unsigned int)(statsbaselen + strlen(version_string) + 4 + strlen(stat_string)),
                           httpstats2,
                           httpstats3,
                           version_string,
                           stat_string,
                           httpstats4);
            // Fix: asprintf Fehler-Check hinzufĆ¼gen - ABER KEINE 404!
            if (*rsize == -1) {
                log_msg(LGG_ERR, "asprintf failed for stats response");
                // Fallback: leere HTML statt 404
                *response = (char*)httpnulltext;
                *rsize = strlen(httpnulltext);
            } else {
                *response = *aspbuf;
            }
        }
        // Memory-Leak Fix: Sofort freigeben
        if (version_string) {
            free(version_string);
            version_string = NULL;
        }
        if (stat_string) {
            free(stat_string);
            stat_string = NULL;
        }
        return SEND_STATS;
        
    } else if (!strcmp(path, stats_text_url) && allow_admin) {
        version_string = get_version(argc, argv);
        stat_string = get_stats(0, 1);
        if (version_string && stat_string) {
            *rsize = asprintf(aspbuf,
                           "%s%u%s%s\n%s%s",
                           txtstats1,
                           (unsigned int)(strlen(version_string) + 1 + strlen(stat_string) + 2),
                           txtstats2,
                           version_string,
                           stat_string,
                           txtstats3);
            // Fix: asprintf Fehler-Check hinzufĆ¼gen - ABER KEINE 404!
            if (*rsize == -1) {
                log_msg(LGG_ERR, "asprintf failed for text stats response");
                // Fallback: leere HTML statt 404
                *response = (char*)httpnulltext;
                *rsize = strlen(httpnulltext);
            } else {
                *response = *aspbuf;
            }
        }
        // Memory-Leak Fix: Sofort freigeben
        if (version_string) {
            free(version_string);
            version_string = NULL;
        }
        if (stat_string) {
            free(stat_string);
            stat_string = NULL;
        }
        return SEND_STATSTEXT;
        
    } else if (do_204 && (!strcasecmp(path, "/generate_204") || !strcasecmp(path, "/gen_204"))) {
        *response = (char*)http204;
        *rsize = strlen(http204);
        return SEND_204;
        
    } else if (!strncasecmp(path, "/pagead/imgad?", 14) ||
               !strncasecmp(path, "/pagead/conversion/", 19 ) ||
               !strncasecmp(path, "/pcs/view?xai=AKAOj", 19 ) ||
               !strncasecmp(path, "/daca_images/simgad/", 20)) {
        *response = (char*)httpnullpixel;
        *rsize = strlen(httpnullpixel);
        return SEND_GIF;
        
    } else {
        // pick out encoded urls (usually advert redirects)
        if (do_redirect && strcasestr(path, "=http")) {
            char *decoded = malloc(strlen(path)+1);
            if (decoded) {
                urldecode(decoded, path);

                // double decode
                urldecode(path, decoded);
                free(decoded);
                url = strstr_last(path, "http://");
                if (url == NULL) {
                    url = strstr_last(path, "https://");
                }
                // WORKAROUND: google analytics block - request bomb on pages with conversion callbacks (see in chrome)
                if (url) {
                    char *tok = NULL;
                    for (tok = strtok_r(NULL, "\r\n", &bufptr); tok; tok = strtok_r(NULL, "\r\n", &bufptr)) {
                        char *hkey = strtok(tok, ":");
                        char *hvalue = strtok(NULL, "\r\n");
                        if (strstr_first(hkey, "Referer") && strstr_first(hvalue, url)) {
                            url = NULL;
                            TESTPRINT("Not redirecting likely callback URL: %s:%s\n", hkey, hvalue);
                            break;
                        }
                    }
                }
            }
        }
        if (do_redirect && url) {
            if (!cors_origin) {
                *rsize = asprintf(aspbuf, httpredirect, url, "");
            } else {
                char *tmpcors = NULL;
                int ret = asprintf(&tmpcors, httpcors_headers, cors_origin);
                if (ret != -1) {
                    *rsize = asprintf(aspbuf, httpredirect, url, tmpcors);
                    free(tmpcors);
                }
            }
            // Fix: asprintf Fehler-Check fĆ¼r Redirect - ABER KEINE 404!
            if (*rsize == -1) {
                log_msg(LGG_ERR, "asprintf failed for redirect response");
                // Fallback: leere HTML statt 404
                *response = (char*)httpnulltext;
                *rsize = strlen(httpnulltext);
                return SEND_TXT;
            } else {
                *response = *aspbuf;
                return SEND_REDIRECT;
            }
            url = NULL;
            TESTPRINT("Sending redirect: %s\n", url);
        } else {
            char *file = strrchr(strtok(path, "?#;="), '/');
            if (file == NULL) {
                // Fix: KEINE 404! Ad-Blocker soll immer "erfolgreich" sein
                *response = (char*)httpnulltext;
                *rsize = strlen(httpnulltext);
                log_msg(LGG_DEBUG, "URL contains invalid file path %s - sending empty HTML", path);
                return SEND_TXT;
            } else {
                TESTPRINT("file: '%s'\n", file);
                return handle_file_extension(file, response, rsize);
            }
        }
    }
    
    return DEFAULT_REPLY;
}

response_enum handle_file_extension(char *file, char **response, int *rsize)
{
    char *ext = strrchr(file, '.');
    if (ext == NULL) {
        // Fix: KEINE 404! Unbekannte URLs als leere HTML behandeln
        *response = (char*)httpnulltext;
        *rsize = strlen(httpnulltext);
        log_msg(LGG_DEBUG, "no file extension %s - sending empty HTML", file);
        return SEND_TXT;
    } else {
        TESTPRINT("ext: '%s'\n", ext);
        
        // === ERWEITERTE EXTENSION-BEHANDLUNG MIT ASP-UNTERSTĆTZUNG ===
        // HIER WERDEN DIE 290+ EXTENSIONS HINZUGEFĆGT
        const char *norm_ext = (ext[0] == '.') ? ext + 1 : ext;
        
        if (!strcasecmp(norm_ext, "gif")) {
            TESTPRINT("Sending gif response\n");
            *response = (char*)httpnullpixel;
            *rsize = strlen(httpnullpixel);
            return SEND_GIF;
        } else if (!strcasecmp(norm_ext, "png")) {
            TESTPRINT("Sending png response\n");
            *response = (char*)httpnull_png;
            *rsize = strlen(httpnull_png);
            return SEND_PNG;
        } else if (!strncasecmp(norm_ext, "jp", 2)) { // jpg, jpeg
            TESTPRINT("Sending jpg response\n");
            *response = (char*)httpnull_jpg;
            *rsize = strlen(httpnull_jpg);
            return SEND_JPG;
        } else if (!strcasecmp(norm_ext, "swf")) {
            TESTPRINT("Sending swf response\n");
            *response = (char*)httpnull_swf;
            *rsize = strlen(httpnull_swf);
            return SEND_SWF;
        } else if (!strcasecmp(norm_ext, "ico")) {
            TESTPRINT("Sending ico response\n");
            *response = (char*)httpnull_ico;
            *rsize = strlen(httpnull_ico);
            return SEND_ICO;
        }
        // === NEUE ASP-UNTERSTĆTZUNG ===
        else if (!strcasecmp(norm_ext, "asp")) {
            TESTPRINT("Sending ASP response\n");
            *response = (char*)httpnull_asp;
            *rsize = strlen(httpnull_asp);
            return SEND_ASP;
        } else if (!strcasecmp(norm_ext, "aspx")) {
            TESTPRINT("Sending ASPX response\n");
            *response = (char*)httpnull_aspx;
            *rsize = strlen(httpnull_aspx);
            return SEND_ASPX;
        } else if (!strcasecmp(norm_ext, "ashx")) {
            TESTPRINT("Sending ASHX response\n");
            *response = (char*)httpnull_ashx;
            *rsize = strlen(httpnull_ashx);
            return SEND_ASHX;
        }
        // === WEITERE SERVER-SKRIPTE ===
        else if (!strcasecmp(norm_ext, "php")) {
            TESTPRINT("Sending PHP response\n");
            *response = (char*)httpnull_php;
            *rsize = strlen(httpnull_php);
            return SEND_PHP;
        } else if (!strcasecmp(norm_ext, "jsp")) {
            TESTPRINT("Sending JSP response\n");
            *response = (char*)httpnull_jsp;
            *rsize = strlen(httpnull_jsp);
            return SEND_JSP;
        } else if (!strncasecmp(norm_ext, "js", 2)) {  // .js, .jsx
            TESTPRINT("Sending JavaScript response\n");
            *response = (char*)httpnull_js;
            *rsize = strlen(httpnull_js);
            return SEND_JS;
        }
        // === WEB-STANDARDS ===
        else if (!strcasecmp(norm_ext, "css")) {
            TESTPRINT("Sending CSS response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_CSS;
        } else if (!strcasecmp(norm_ext, "html") || !strcasecmp(norm_ext, "htm")) {
            TESTPRINT("Sending HTML response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_HTML;
        }
        // === DATENFORMATE ===
        else if (!strcasecmp(norm_ext, "xml") || !strcasecmp(norm_ext, "rss")) {
            TESTPRINT("Sending XML response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_XML;
        } else if (!strcasecmp(norm_ext, "json")) {
            TESTPRINT("Sending JSON response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_JSON;
        }
        // === CGI UND ANDERE SERVER-SKRIPTE ===
        else if (!strcasecmp(norm_ext, "cgi") || !strcasecmp(norm_ext, "pl") || 
                 !strcasecmp(norm_ext, "fcgi")) {
            TESTPRINT("Sending CGI/Perl response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_TXT;
        }
        // === JAVA SERVER-TECHNOLOGIEN ===
        else if (!strcasecmp(norm_ext, "do") || !strcasecmp(norm_ext, "action")) {
            TESTPRINT("Sending Java Action response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_TXT;
        }
        // === .NET WEB SERVICES ===
        else if (!strcasecmp(norm_ext, "asmx") || !strcasecmp(norm_ext, "svc")) {
            TESTPRINT("Sending .NET Web Service response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_TXT;
        }
        // === COLDFUSION ===
        else if (!strcasecmp(norm_ext, "cfm")) {
            TESTPRINT("Sending ColdFusion response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_TXT;
        }
        
        // === HIER KOMMEN DIE 290+ WEITEREN EXTENSIONS DAZU ===
        
        // === FALLBACK FĆR ALLE ANDEREN EXTENSIONS ===
        else {
            // Fix: Automatische Behandlung aller anderen Extensions
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            
            // Detailliertes Logging mit Extension-Info fĆ¼r bessere Diagnostik
            log_msg(LGG_DEBUG, "Auto-handling extension '%s' from file '%s' - sending empty HTML", 
                    norm_ext, file);
            TESTPRINT("Sending auto-response for extension '%s'\n", norm_ext);
            return SEND_TXT;
        }
    }
}
/*
 * src/main/signal_handler.c
 * Location: ./src/main/signal_handler.c
 * 
 * Signal handling functionality for SSLGateNX
*/

#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/wait.h>

#if defined(__GLIBC__) && !defined(__UCLIBC__)
#  include <malloc.h>
#endif

#include "../ssl/ssl_modules.h"
#include "../sock/socket_handler.h"
#include "../log/logger.h"
#include "../util/util.h"
#include "signal_handler.h"

extern char ssl_gate_pipe[];
extern const char *tls_pem;

/* Signal handler with improved cleanup */
void signal_handler(int sig)
{
  if (sig != SIGTERM
   && sig != SIGUSR1
#ifdef DEBUG
   && sig != SIGUSR2
#endif
  ) {
    log_msg(LGG_WARNING, "Ignoring unsupported signal number: %d", sig);
    return;
  }

#ifdef DEBUG
  if (sig == SIGUSR2) {
    log_msg(LGG_INFO, "Main process caught signal %d file %s", sig, __FILE__);
  } else {
#endif
    if (sig == SIGTERM) {
      signal(SIGTERM, SIG_IGN);
    }

    /* Cleanup connection storage */
    conn_stor_flush();
    
    /* Remove certificate pipe */
    if (unlink(ssl_gate_pipe) == 0) {
        log_msg(LGG_NOTICE, "Removed cert pipe: %s", ssl_gate_pipe);
    } else {
        log_msg(LGG_WARNING, "Could not remove cert pipe %s: %s", ssl_gate_pipe, strerror(errno));
    }

#if defined(__GLIBC__) && !defined(__UCLIBC__)
    malloc_trim(0);
#endif

    /* Log final statistics */
    char* stats_string = get_stats(0, 0);
    if (stats_string) {
        log_msg(LGG_CRIT, "%s", stats_string);
        free(stats_string);
    }

    /* Save SSL context table */
    sslctx_tbl_save(tls_pem);

    if (sig == SIGTERM) {
      log_msg(LGG_NOTICE, "exit on SIGTERM");
      exit(EXIT_SUCCESS);
    }
#ifdef DEBUG
  }
#endif
}

void setup_signal_handlers(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = signal_handler;
  sigemptyset(&sa.sa_mask);
  
  if (sigaction(SIGTERM, &sa, NULL)) {
    log_msg(LGG_ERR, "SIGTERM %m");
    exit(EXIT_FAILURE);
  }
  
  if (signal(SIGCHLD, SIG_IGN) == SIG_ERR) {
    log_msg(LGG_WARNING, "SIGCHLD %m");
  }
  
  sa.sa_flags = SA_RESTART;
  if (sigaction(SIGUSR1, &sa, NULL)) {
    log_msg(LGG_ERR, "SIGUSR1 %m");
    exit(EXIT_FAILURE);
  }

#if defined(__GLIBC__) && defined(BACKTRACE)
  sa.sa_handler = print_trace;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGABRT, &sa, NULL);
  sigaction(SIGILL, &sa, NULL);
  sigaction(SIGFPE, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
#endif

#ifdef DEBUG
  sa.sa_flags = SA_RESTART;
  if (sigaction(SIGUSR2, &sa, NULL)) {
    log_msg(LGG_ERR, "SIGUSR2 %m");
    exit(EXIT_FAILURE);
  }
#endif

  signal(SIGPIPE, SIG_IGN);
}
/*
* server_init.c
* Location: ./src/main/server_init.c
* 
* Server initialization and SSL setup for SSLGateNX
*/

#include <pthread.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#ifdef DROP_ROOT
#include <pwd.h>
#endif

#include <openssl/ssl.h>

#include "../ssl/ssl_modules.h"
#include "../sock/socket_handler.h"
#include "../log/logger.h"
#include "../util/util.h"
#include "server_init.h"

#define PAGE_SIZE 4096
#define THREAD_STACK_SIZE  9*PAGE_SIZE

extern char ssl_gate_pipe[];
extern cert_tlstor_t cert_tlstor;

int initialize_server(const char *tls_pem, int cert_cache_size, int max_num_threads, 
                     int do_benchmark, cert_tlstor_t *cert_tlstor, char *bm_cert, 
                     pthread_t *certgen_thread)
{
  /* Generate random pipe path */
  generate_random_pipe_path(ssl_gate_pipe, sizeof(ssl_gate_pipe));
  if (mkfifo(ssl_gate_pipe, 0600) < 0 && errno != EEXIST) {
    log_msg(LGG_ERR, "Failed to create cert pipe: %s", strerror(errno));
    return -1;
  }

  /* Initialize SSL and certificate handling */
  ssl_init_locks();
  cert_tlstor_init(tls_pem, cert_tlstor);
  sslctx_tbl_init(cert_cache_size);
  conn_stor_init(max_num_threads);

  /* Load existing certificates */
  sslctx_tbl_load(tls_pem, cert_tlstor->cachain);
  SSL_CTX *sslctx = create_default_sslctx(tls_pem);
  if (!sslctx) {
    log_msg(LGG_ERR, "Failed to create default SSL context");
    return -1;
  }

  if (do_benchmark) {
    run_benchmark(cert_tlstor, bm_cert);
    return 0;
  } else {
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, THREAD_STACK_SIZE);
    if (pthread_create(certgen_thread, &attr, cert_generator, (void*)cert_tlstor) != 0) {
      log_msg(LGG_ERR, "Failed to create certificate generator thread");
      pthread_attr_destroy(&attr);
      return -1;
    }
    pthread_attr_destroy(&attr);
  }

  return 0;
}

void cleanup_server(void)
{
  conn_stor_flush();
  sslctx_tbl_cleanup();
  cert_tlstor_cleanup(&cert_tlstor);
  ssl_free_locks();
}
/*
* connection_loop.c - Enhanced main connection loop with epoll and DOS client support
* Location: ./src/main/connection_loop.c
* 
* High-performance connection handling for 2-3M users with MS-DOS client compatibility
*/

#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
#include <sys/resource.h>

#ifdef __linux__
#include <sys/epoll.h>
#include <linux/version.h>
#define USE_EPOLL 1
#define MAX_EPOLL_EVENTS 1000
#else
#define USE_EPOLL 0
#endif

#include <openssl/ssl.h>
#include <openssl/err.h>

#include "../ssl/ssl_modules.h"
#include "../sock/socket_handler.h"
#include "../log/logger.h"
#include "../util/util.h"
#include "connection_loop.h"

#ifndef SO_BINDTODEVICE
#  define SO_BINDTODEVICE IP_RECVIF
#endif

#define PAGE_SIZE 4096
#define THREAD_STACK_SIZE  9*PAGE_SIZE
#define TCP_FASTOPEN_QLEN  25

/* Enhanced buffer sizes for different client types */
#define REGULAR_BUFFER_SIZE 4096
#define DOS_BUFFER_SIZE 1024
#define HIGH_LOAD_BUFFER_SIZE 8192

extern const char *tls_pem;
extern int tls_ports[];
extern int num_tls_ports;
extern int admin_port;
extern struct Global *g;
extern cert_tlstor_t cert_tlstor;

/* DOS client statistics */
volatile sig_atomic_t dos_client_count = 0;
volatile sig_atomic_t dos_ssl_downgrades = 0;
volatile sig_atomic_t dos_legacy_handshakes = 0;

/* High-performance connection pool */
typedef struct connection_pool {
    conn_tlstor_struct *connections;
    int *free_list;
    int free_count;
    int total_count;
    pthread_mutex_t mutex;
} connection_pool_t;

static connection_pool_t conn_pool = {0};

/* Initialize connection pool for high performance */
static int init_connection_pool(int max_connections) {
    conn_pool.connections = calloc(max_connections, sizeof(conn_tlstor_struct));
    conn_pool.free_list = malloc(max_connections * sizeof(int));
    
    if (!conn_pool.connections || !conn_pool.free_list) {
        log_msg(LGG_ERR, "Failed to allocate connection pool");
        return -1;
    }
    
    /* Initialize free list */
    for (int i = 0; i < max_connections; i++) {
        conn_pool.free_list[i] = i;
        conn_pool.connections[i].tlsext_cb_arg = &conn_pool.connections[i].v;
    }
    
    conn_pool.free_count = max_connections;
    conn_pool.total_count = max_connections;
    pthread_mutex_init(&conn_pool.mutex, NULL);
    
    log_msg(LGG_INFO, "Initialized connection pool with %d slots", max_connections);
    return 0;
}

/* Fast connection acquisition from pool */
static conn_tlstor_struct* acquire_connection_fast(void) {
    pthread_mutex_lock(&conn_pool.mutex);
    
    if (conn_pool.free_count == 0) {
        pthread_mutex_unlock(&conn_pool.mutex);
        return NULL;
    }
    
    int idx = conn_pool.free_list[--conn_pool.free_count];
    conn_tlstor_struct *conn = &conn_pool.connections[idx];
    
    pthread_mutex_unlock(&conn_pool.mutex);
    
    /* Reset connection state */
    memset(conn, 0, sizeof(conn_tlstor_struct));
    conn->tlsext_cb_arg = &conn->v;
    
    return conn;
}

/* Fast connection release to pool */
static void release_connection_fast(conn_tlstor_struct *conn) {
    if (!conn || conn < conn_pool.connections || 
        conn >= conn_pool.connections + conn_pool.total_count) {
        return;
    }
    
    int idx = conn - conn_pool.connections;
    
    pthread_mutex_lock(&conn_pool.mutex);
    if (conn_pool.free_count < conn_pool.total_count) {
        conn_pool.free_list[conn_pool.free_count++] = idx;
    }
    pthread_mutex_unlock(&conn_pool.mutex);
}

/* Create optimized listening socket */
int create_listening_socket(const char *ip_addr, const char *port, int use_ip) {
    struct addrinfo hints, *servinfo = NULL;
    int sockfd, rv;
    
    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    if (!use_ip) {
        hints.ai_flags = AI_PASSIVE;
    }
    
    rv = getaddrinfo(use_ip ? ip_addr : NULL, port, &hints, &servinfo);
    if (rv) {
        log_msg(LGG_ERR, "getaddrinfo: %s", gai_strerror(rv));
        return -1;
    }
    
    sockfd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
    if (sockfd < 1) {
        log_msg(LGG_CRIT, "socket() failed: %m");
        freeaddrinfo(servinfo);
        return -1;
    }
    
    /* Configure socket for high performance */
    configure_socket_for_high_load(sockfd);
    
    /* Set socket options */
    int off = 0;
    if (servinfo->ai_family == AF_INET6 && 
        setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &off, sizeof(off)) < 0) {
        log_msg(LGG_WARNING, "Failed to set IPV6_V6ONLY: %m");
    }
    
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof(int)) < 0 ||
        setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &(int){ 1 }, sizeof(int)) < 0) {
        log_msg(LGG_ERR, "Failed to set socket options: %m");
        close(sockfd);
        freeaddrinfo(servinfo);
        return -1;
    }
    
    /* Enable TCP Fast Open for modern clients */
#ifdef linux
#  if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0) || defined(TCP_FASTOPEN)
    if (setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN, &(int){ TCP_FASTOPEN_QLEN }, sizeof(int)) < 0) {
        log_msg(LGG_DEBUG, "TCP_FASTOPEN not supported: %m");
    }
#  endif
#endif
    
    if (bind(sockfd, servinfo->ai_addr, servinfo->ai_addrlen) < 0 ||
        listen(sockfd, BACKLOG) < 0) {
        log_msg(LGG_CRIT, "bind/listen failed: %m - %s:%s", ip_addr ? ip_addr : "*", port);
        close(sockfd);
        freeaddrinfo(servinfo);
        return -1;
    }
    
    /* Set non-blocking mode for listening socket */
    if (fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL) | O_NONBLOCK) < 0) {
        log_msg(LGG_WARNING, "Failed to set non-blocking mode: %m");
    }
    
    freeaddrinfo(servinfo);
    return sockfd;
}

/* Configure socket for high-load scenarios */
void configure_socket_for_high_load(int sockfd) {
    /* Increase socket buffer sizes */
    int bufsize = 64 * 1024;  /* 64KB */
    setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize));
    setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(bufsize));
    
    /* Enable socket reuse */
    int reuse = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
    
#ifdef SO_REUSEPORT
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &reuse, sizeof(reuse));
#endif
    
    /* Optimize for low latency */
    int nodelay = 1;
    setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &nodelay, sizeof(nodelay));
    
    /* Set keep-alive for connection health */
    int keepalive = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &keepalive, sizeof(keepalive));
}

/* DOS client detection based on connection patterns */
static int detect_dos_client_advanced(int fd, struct sockaddr_storage *addr) {
    char peek_buf[32];
    int peek_len = recv(fd, peek_buf, sizeof(peek_buf), MSG_PEEK);
    
    if (peek_len <= 0) return 0;
    
    /* Multiple heuristics for DOS client detection */
    
    /* 1. Very small initial packets (DOS clients often send < 16 bytes initially) */
    if (peek_len < 16) {
        log_msg(LGG_DEBUG, "Potential DOS client: small initial packet (%d bytes)", peek_len);
        return 1;
    }
    
    /* 2. SSLv2 CLIENT-HELLO detection */
    if (peek_len >= 3 && (unsigned char)peek_buf[0] == 0x80) {
        log_msg(LGG_INFO, "DOS client detected: SSLv2 handshake");
        dos_legacy_handshakes++;
        return 1;
    }
    
    /* 3. Very old TLS versions (TLS 1.0 and earlier) */
    if (peek_len >= 3 && peek_buf[0] == 0x16 && peek_buf[1] == 0x03 && peek_buf[2] <= 0x01) {
        log_msg(LGG_INFO, "DOS client detected: TLS 1.0 or earlier");
        return 1;
    }
    
    /* 4. Check for specific legacy cipher patterns */
    if (peek_len >= 10) {
        /* Look for RC4 or DES cipher requests in client hello */
        for (int i = 0; i < peek_len - 4; i++) {
            if ((peek_buf[i] == 0x00 && peek_buf[i+1] == 0x04) ||  /* RC4-MD5 */
                (peek_buf[i] == 0x00 && peek_buf[i+1] == 0x05) ||  /* RC4-SHA */
                (peek_buf[i] == 0x00 && peek_buf[i+1] == 0x0A)) {  /* DES-CBC3-SHA */
                log_msg(LGG_INFO, "DOS client detected: legacy cipher preference");
                return 1;
            }
        }
    }
    
    /* 5. Slow connection pattern (multiple small packets) */
    struct timeval tv = {0, 100000};  /* 100ms timeout */
    setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    
    char second_peek[16];
    int second_len = recv(fd, second_peek, sizeof(second_peek), MSG_PEEK | MSG_DONTWAIT);
    
    if (second_len == peek_len) {
        /* No new data arrived quickly - might be slow DOS client */
        log_msg(LGG_DEBUG, "Potential DOS client: slow data arrival");
        return 1;
    }
    
    return 0;
}

/* Enhanced SSL configuration for DOS clients */
static void configure_ssl_for_dos_client(SSL_CTX *ctx, SSL *ssl, dos_client_info_t *dos_info) {
    if (!dos_info || !dos_info->is_dos_client) return;
    
    log_msg(LGG_INFO, "Configuring SSL for DOS client compatibility");
    
    /* Enable all legacy protocols */
    SSL_CTX_clear_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1);
    SSL_set_options(ssl, SSL_OP_LEGACY_SERVER_CONNECT);
    
    /* Set DOS-compatible cipher list */
    SSL_set_cipher_list(ssl, SSLGATENX_CIPHER_LIST_DOS);
    
    /* Configure for slow/limited clients */
    SSL_set_mode(ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
    SSL_set_mode(ssl, SSL_MODE_ENABLE_PARTIAL_WRITE);
    
    /* Increase timeouts significantly */
    SSL_set_timeout(ssl, 600);  /* 10 minutes for very slow DOS clients */
    
    /* Reduce session cache requirements */
    SSL_set_session_cache_mode(ssl, SSL_SESS_CACHE_OFF);
    
    dos_info->legacy_ssl_mode = 1;
    dos_ssl_downgrades++;
}

/* Enhanced connection loop with epoll support */
void run_connection_loop(char *ip_addr, int use_ip, char *ports[], int num_ports, int max_num_threads, 
                        struct Global *global_config
#ifdef IF_MODE
  , char *ifname, int use_if
#endif
)
{
    int sockfds[MAX_PORTS] = {0};
    int num_listening_sockets = 0;
    response_struct pipedata = { 0 };
    int pipefd[2];
    
#if USE_EPOLL
    int epfd = -1;
    struct epoll_event events[MAX_EPOLL_EVENTS];
    log_msg(LGG_INFO, "Using epoll for high-performance I/O multiplexing");
#else
    fd_set readfds, selectfds;
    int nfds = 0;
    FD_ZERO(&readfds);
    log_msg(LGG_INFO, "Using select for I/O multiplexing (epoll not available)");
#endif
    
    /* Set default ports if none specified */
    if ((!admin_port && !num_ports) || (admin_port && num_ports == 1)) {
        tls_ports[num_tls_ports++] = atoi(SECOND_PORT);
        ports[num_ports++] = SECOND_PORT;
        ports[num_ports++] = DEFAULT_PORT;
    } else if ((!admin_port && !num_tls_ports) || (admin_port && num_tls_ports == 1)) {
        tls_ports[num_tls_ports++] = atoi(SECOND_PORT);
        ports[num_ports++] = SECOND_PORT;
    } else if (num_ports == num_tls_ports) {
        ports[num_ports++] = DEFAULT_PORT;
    }
    
    /* Initialize high-performance connection pool */
    if (init_connection_pool(max_num_threads * 2) != 0) {
        log_msg(LGG_ERR, "Failed to initialize connection pool");
        exit(EXIT_FAILURE);
    }
    
    /* Create epoll instance for high-load scenarios */
#if USE_EPOLL
    epfd = epoll_create1(EPOLL_CLOEXEC);
    if (epfd == -1) {
        log_msg(LGG_ERR, "Failed to create epoll instance: %m");
        exit(EXIT_FAILURE);
    }
#endif
    
    /* Create listening sockets */
    for (int i = 0; i < num_ports; i++) {
        int sockfd = create_listening_socket(ip_addr, ports[i], use_ip);
        if (sockfd < 0) {
            log_msg(LGG_ERR, "Failed to create listening socket for port %s", ports[i]);
            continue;
        }
        
        sockfds[num_listening_sockets] = sockfd;
        
#if USE_EPOLL
        struct epoll_event ev;
        ev.events = EPOLLIN | EPOLLET;  /* Edge-triggered for better performance */
        ev.data.fd = sockfd;
        if (epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev) == -1) {
            log_msg(LGG_ERR, "Failed to add socket to epoll: %m");
            close(sockfd);
            continue;
        }
#else
        FD_SET(sockfd, &readfds);
        if (sockfd > nfds) nfds = sockfd;
#endif
        
        num_listening_sockets++;
        log_msg(LGG_INFO, "Enhanced listening on %s:%s (socket %d)", 
                ip_addr ? ip_addr : "*", ports[i], sockfd);
    }
    
    if (num_listening_sockets == 0) {
        log_msg(LGG_ERR, "No listening sockets created");
        exit(EXIT_FAILURE);
    }
    
    /* Set up inter-process communication pipe */
    if (pipe(pipefd) == -1) {
        log_msg(LGG_ERR, "pipe() error: %m");
        exit(EXIT_FAILURE);
    }
    
    if (fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) | O_NONBLOCK) == -1) {
        log_msg(LGG_ERR, "fcntl() error setting O_NONBLOCK on pipe: %m");
        exit(EXIT_FAILURE);
    }
    
#if USE_EPOLL
    /* Add pipe to epoll for statistics */
    struct epoll_event pipe_ev;
    pipe_ev.events = EPOLLIN;
    pipe_ev.data.fd = pipefd[0];
    epoll_ctl(epfd, EPOLL_CTL_ADD, pipefd[0], &pipe_ev);
#else
    FD_SET(pipefd[0], &readfds);
    if (pipefd[0] > nfds) nfds = pipefd[0];
    nfds++;
#endif
    
    /* Set global pointer */
    g = global_config;
    
    log_msg(LGG_INFO, "Starting enhanced connection loop with %d sockets", num_listening_sockets);
    
    /* Main enhanced event loop */
    while(1) {
        int ready_count;
        
#if USE_EPOLL
        ready_count = epoll_wait(epfd, events, MAX_EPOLL_EVENTS, -1);
        if (ready_count == -1) {
            if (errno == EINTR) continue;
            log_msg(LGG_ERR, "epoll_wait error: %m");
            break;
        }
#else
        selectfds = readfds;
        ready_count = select(nfds, &selectfds, NULL, NULL, NULL);
        if (ready_count < 0) {
            if (errno == EINTR) continue;
            log_msg(LGG_ERR, "select error: %m");
            break;
        }
#endif
        
        /* Process ready file descriptors */
#if USE_EPOLL
        for (int i = 0; i < ready_count; i++) {
            int fd = events[i].data.fd;
            uint32_t events_mask = events[i].events;
            
            if (fd == pipefd[0]) {
                /* Handle pipe statistics - same as original */
                /* ... pipe handling code ... */
                continue;
            }
            
            /* Check if it's a listening socket */
            int is_listening_socket = 0;
            for (int j = 0; j < num_listening_sockets; j++) {
                if (fd == sockfds[j]) {
                    is_listening_socket = 1;
                    break;
                }
            }
            
            if (!is_listening_socket) continue;
            
            /* Accept connections in a loop for edge-triggered epoll */
            while (1) {
#else
        for (int i = 0; i < num_listening_sockets; i++) {
            int sockfd = sockfds[i];
            if (!FD_ISSET(sockfd, &selectfds)) continue;
            
            int fd = sockfd;
#endif
                struct sockaddr_storage their_addr;
                socklen_t sin_size = sizeof(their_addr);
                struct timespec init_time = {0, 0};
                
                get_time(&init_time);
                int new_fd = accept(fd, (struct sockaddr *) &their_addr, &sin_size);
                
                if (new_fd < 0) {
                    if (errno == EAGAIN || errno == EWOULDBLOCK) {
#if USE_EPOLL
                        break;  /* No more connections to accept */
#else
                        continue;
#endif
                    }
                    log_msg(LGG_DEBUG, "accept: %m");
#if USE_EPOLL
                    break;
#else
                    continue;
#endif
                }
                
                /* Check connection limits */
                if (kcc >= max_num_threads) {
                    clt++;
                    shutdown(new_fd, SHUT_RDWR);
                    close(new_fd);
#if USE_EPOLL
                    continue;
#else
                    continue;
#endif
                }
                
                /* Acquire connection from pool */
                conn_tlstor_struct *conn_tlstor = acquire_connection_fast();
                if (conn_tlstor == NULL) {
                    log_msg(LGG_WARNING, "Connection pool exhausted");
                    shutdown(new_fd, SHUT_RDWR);
                    close(new_fd);
#if USE_EPOLL
                    continue;
#else
                    continue;
#endif
                }
                
                /* Detect DOS client early */
                dos_client_info_t dos_info = {0};
                dos_info.is_dos_client = detect_dos_client_advanced(new_fd, &their_addr);
                dos_info.connect_time = time(NULL);
                
                if (dos_info.is_dos_client) {
                    dos_client_count++;
                    log_msg(LGG_INFO, "DOS client detected and configured");
                }
                
                /* Configure socket based on client type */
                if (dos_info.is_dos_client) {
                    /* Smaller buffers and longer timeouts for DOS clients */
                    struct timeval timeout = {10, 0};  /* 10 seconds */
                    setsockopt(new_fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
                    setsockopt(new_fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
                } else {
                    /* Optimized settings for modern clients */
                    struct timeval timeout = {2, 0};   /* 2 seconds */
                    setsockopt(new_fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
                    setsockopt(new_fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
                }
                
                /* Set to blocking mode for SSL handshake */
                int flags;
                if ((flags = fcntl(new_fd, F_GETFL, 0)) < 0 || 
                    fcntl(new_fd, F_SETFL, flags & (~O_NONBLOCK)) < 0) {
                    log_msg(LGG_WARNING, "Failed to set blocking mode: %m");
                }
                
                /* Configure connection structure */
                conn_tlstor->new_fd = new_fd;
                conn_tlstor->ssl = NULL;
                conn_tlstor->allow_admin = (!admin_port) ? 1 : 0;
                conn_tlstor->dos_client_info = dos_info;
                
                /* Determine buffer size based on client type */
                conn_tlstor->buffer_size = dos_info.is_dos_client ? DOS_BUFFER_SIZE : REGULAR_BUFFER_SIZE;
                
                char *server_ip = conn_tlstor->tlsext_cb_arg->server_ip;
                int ssl_port = is_ssl_conn(new_fd, server_ip, INET6_ADDRSTRLEN, tls_ports, num_tls_ports);
                
                if (ssl_port) {
                    /* SSL/TLS connection handling with DOS support */
                    int ssl_attempt = 5;
                    int sslerr = SSL_ERROR_NONE;
                    char ip_buf[NI_MAXHOST], port_buf[NI_MAXSERV];
                    
                    tlsext_cb_arg_struct *t = conn_tlstor->tlsext_cb_arg;
                    SSL *ssl = NULL;
                    SSL_CTX *sslctx;
                    
                    /* Choose appropriate SSL context based on client type */
                    if (dos_info.is_dos_client) {
                        sslctx = create_dos_compatible_sslctx(tls_pem);
                        log_msg(LGG_DEBUG, "Using DOS-compatible SSL context");
                    } else {
                        sslctx = create_default_sslctx(tls_pem);
                    }
                    
                    t->tls_pem = (char*)tls_pem;
                    t->cachain = cert_tlstor.cachain;
                    t->status = SSL_UNKNOWN;
                    t->sslctx_idx = -1;
                    t->dos_info = &conn_tlstor->dos_client_info;
                    
                    ssl = SSL_new(sslctx);
                    if (!ssl) {
                        log_msg(LGG_ERR, "SSL_new() failed");
                        goto cleanup_connection;
                    }
                    
                    SSL_set_fd(ssl, new_fd);
                    conn_tlstor->ssl = ssl;
                    
                    /* Configure SSL for DOS client if needed */
                    if (dos_info.is_dos_client) {
                        configure_ssl_for_dos_client(sslctx, ssl, &dos_info);
                    }
                    
                    if (ssl_port == admin_port)
                        conn_tlstor->allow_admin = 1;
                    
                    /* Handle early data for TLS 1.3 (not for DOS clients) */
#ifdef TLS1_3_VERSION
                    if (!dos_info.is_dos_client) {
                        SSL_CTX_set_client_hello_cb(sslctx, tls_clienthello_cb, t);
                        conn_tlstor->early_data = read_tls_early_data(ssl, &sslerr);
                        if (conn_tlstor->early_data) {
                            conn_tlstor->init_time = elapsed_time_msec(init_time);
                            goto start_service_thread;
                        }
                        
                        if (sslerr != SSL_ERROR_NONE)
                            goto skip_ssl_accept;
                    } else {
                        /* DOS clients use traditional callbacks */
                        SSL_CTX_set_tlsext_servername_arg(sslctx, t);
                        conn_tlstor->early_data = NULL;
                    }
#else
                    SSL_CTX_set_tlsext_servername_arg(sslctx, t);
                    conn_tlstor->early_data = NULL;
#endif
                    
                    conn_tlstor->init_time = elapsed_time_msec(init_time);
                    
redo_ssl_accept:
                    errno = 0;
                    ERR_clear_error();
                    int sslret = SSL_accept(ssl);
                    if (sslret == 1) {
                        if (dos_info.is_dos_client) {
                            t->status = SSL_DOS_LEGACY;
                        }
                        goto start_service_thread;
                    }
                    sslerr = SSL_get_error(ssl, sslret);
                    
#ifdef TLS1_3_VERSION
skip_ssl_accept:
#endif
                    
                    /* Enhanced error handling for DOS clients */
                    if (log_get_verb() >= LGG_WARNING && 
                        getnameinfo((struct sockaddr *)&their_addr, sin_size,
                                   ip_buf, sizeof ip_buf, port_buf, sizeof port_buf, 
                                   NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
                        ip_buf[0] = '\0';
                        port_buf[0] = '\0';
                    }
                    
                    switch(sslerr) {
                        case SSL_ERROR_WANT_READ:
                            ssl_attempt--;
                            if (ssl_attempt > 0) {
                                if (dos_info.is_dos_client) {
                                    /* Give DOS clients more time */
                                    usleep(100000);  /* 100ms */
                                }
                                get_time(&init_time);
                                goto redo_ssl_accept;
                            }
                            log_msg(LGG_WARNING, "SSL handshake timeout %s client %s:%s server %s",
                                dos_info.is_dos_client ? "(DOS)" : "", ip_buf, port_buf, t->servername);
                            break;
                            
                        case SSL_ERROR_SSL:
                            /* Try downgrade for DOS clients */
                            if (dos_info.is_dos_client && !dos_info.legacy_ssl_mode) {
                                log_msg(LGG_INFO, "Attempting SSL downgrade for DOS client");
                                /* Implement SSL version downgrade */
                                dos_info.legacy_ssl_mode = 1;
                                configure_ssl_for_dos_client(sslctx, ssl, &dos_info);
                                ssl_attempt = 3;  /* Give it another try */
                                goto redo_ssl_accept;
                            }
                            
                            switch(ERR_GET_REASON(ERR_peek_last_error())) {
                                case SSL_R_SSLV3_ALERT_BAD_CERTIFICATE:
                                    ucb++;
                                    log_msg(LGG_WARNING, "handshake failed: bad cert. %s client %s:%s server %s",
                                        dos_info.is_dos_client ? "DOS" : "", ip_buf, port_buf, t->servername);
                                    break;
                                case SSL_R_TLSV1_ALERT_UNKNOWN_CA:
                                    uca++;
                                    log_msg(LGG_WARNING, "handshake failed: unknown CA. %s client %s:%s server %s",
                                        dos_info.is_dos_client ? "DOS" : "", ip_buf, port_buf, t->servername);
                                    break;
                                case SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN:
                                    uce++;
                                    log_msg(LGG_WARNING, "handshake failed: unknown cert. %s client %s:%s server %s",
                                        dos_info.is_dos_client ? "DOS" : "", ip_buf, port_buf, t->servername);
                                    break;
                                default:
                                    log_msg(LGG_WARNING, "handshake failed: %s client %s:%s server %s. Lib(%d) Reason(%d)",
                                        dos_info.is_dos_client ? "DOS" : "", ip_buf, port_buf, t->servername,
                                        ERR_GET_LIB(ERR_peek_last_error()), 
                                        ERR_GET_REASON(ERR_peek_last_error()));
                            }
                            break;
                            
                        case SSL_ERROR_SYSCALL:
                            if (t->status == SSL_MISS || t->status == SSL_DOS_LEGACY)
                                break;
                                
                            if (errno == 0 || errno == 104) {
                                char m[2];
                                int rv = recv(new_fd, m, 2, MSG_PEEK);
                                if (rv == 0) {
                                    ush++;
                                    log_msg(LGG_WARNING, "handshake failed: shutdown after ServerHello. %s client %s:%s server %s",
                                        dos_info.is_dos_client ? "DOS" : "", ip_buf, port_buf, t->servername);
                                    break;
                                }
                            }
                            log_msg(LGG_WARNING, "handshake failed: socket I/O error. %s client %s:%s server %s. errno: %d",
                                dos_info.is_dos_client ? "DOS" : "", ip_buf, port_buf, t->servername, errno);
                            break;
                            
                        default:
                            log_msg(LGG_WARNING, "handshake failed: unknown error %d. %s client %s:%s server %s",
                                sslerr, dos_info.is_dos_client ? "DOS" : "", ip_buf, port_buf, t->servername);
                    }
                    
                    count++;
                    switch(t->status) {
                        case SSL_ERR:        ++sle; break;
                        case SSL_MISS:       ++slm; break;
                        case SSL_DOS_LEGACY: ++dos_legacy_handshakes; break;
                        case SSL_HIT:
                        case SSL_UNKNOWN:    ++slu; break;
                        default:             ;
                    }

cleanup_connection:
                    if (ssl) {
                        SSL_set_shutdown(ssl, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
                        SSL_free(ssl);
                    }
                    shutdown(new_fd, SHUT_RDWR);
                    close(new_fd);
                    release_connection_fast(conn_tlstor);
#if USE_EPOLL
                    continue;
#else
                    continue;
#endif
                }

start_service_thread:
                conn_tlstor->init_time += elapsed_time_msec(init_time);
                
                /* Create service thread with appropriate stack size */
                pthread_t conn_thread;
                pthread_attr_t attr;
                pthread_attr_init(&attr);
                pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
                
                /* Use smaller stack for DOS clients to save memory */
                size_t stack_size = dos_info.is_dos_client ? THREAD_STACK_SIZE / 2 : THREAD_STACK_SIZE;
                pthread_attr_setstacksize(&attr, stack_size);
                
                int err = pthread_create(&conn_thread, &attr, conn_handler, (void*)conn_tlstor);
                if (err) {
                    log_msg(LGG_ERR, "Failed to create conn_handler thread. err: %d", err);
                    if (conn_tlstor->ssl) {
                        SSL_set_shutdown(conn_tlstor->ssl, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
                        SSL_free(conn_tlstor->ssl);
                    }
                    shutdown(new_fd, SHUT_RDWR);
                    close(new_fd);
                    release_connection_fast(conn_tlstor);
#if USE_EPOLL
                    continue;
#else
                    continue;
#endif
                }
                pthread_attr_destroy(&attr);
                
                if (++kcc > kmx)
                    kmx = kcc;
                    
#if USE_EPOLL
            } /* end while loop for edge-triggered epoll */
        } /* end for loop for epoll events */
#else
        } /* end for loop for select sockets */
#endif
        
        /* Handle pipe I/O for statistics */
        if (
#if USE_EPOLL
            0  /* Pipe handling moved to events loop above */
#else
            FD_ISSET(pipefd[0], &selectfds)
#endif
        ) {
            int rv = read(pipefd[0], &pipedata, sizeof(pipedata));
            if (rv < 0) {
                log_msg(LGG_WARNING, "error reading from pipe: %m");
            } else if (rv == 0) {
                log_msg(LGG_WARNING, "pipe read() returned zero");
            } else if (rv != sizeof(pipedata)) {
                log_msg(LGG_WARNING, "pipe read() got %d bytes, but %u bytes were expected - discarding",
                    rv, (unsigned int)sizeof(pipedata));
            } else {
                /* Process response statistics */
                switch (pipedata.status) {
                    case FAIL_GENERAL:   ++ers; break;
                    case FAIL_TIMEOUT:   ++tmo; break;
                    case FAIL_CLOSED:    ++cls; break;
                    case FAIL_REPLY:     ++cly; break;
                    case SEND_GIF:       ++gif; break;
                    case SEND_TXT:       ++txt; break;
                    case SEND_JPG:       ++jpg; break;
                    case SEND_PNG:       ++png; break;
                    case SEND_SWF:       ++swf; break;
                    case SEND_ICO:       ++ico; break;
                    case SEND_BAD:       ++bad; break;
                    case SEND_STATS:     ++sta; break;
                    case SEND_STATSTEXT: ++stt; break;
                    case SEND_204:       ++noc; break;
                    case SEND_REDIRECT:  ++rdr; break;
                    case SEND_NO_EXT:    ++nfe; break;
                    case SEND_UNK_EXT:   ++ufe; break;
                    case SEND_NO_URL:    ++nou; break;
                    case SEND_BAD_PATH:  ++pth; break;
                    case SEND_POST:      ++pst; break;
                    case SEND_HEAD:      ++hed; break;
                    case SEND_OPTIONS:   ++opt; break;
                    case ACTION_LOG_VERB:  log_set_verb(pipedata.verb); break;
                    case ACTION_DEC_KCC: --kcc; break;
                    default:
                        log_msg(LGG_DEBUG, "conn_handler reported unknown response value: %d", pipedata.status);
                }
                
                switch (pipedata.ssl) {
                    case SSL_HIT_RTT0:   ++zrt; /* fall through */
                    case SSL_HIT:        
                    case SSL_DOS_LEGACY: ++slh; break;
                    case SSL_HIT_CLS:    ++slc; break;
                    default:             ;
                }
                
                if (pipedata.ssl == SSL_HIT ||
                    pipedata.ssl == SSL_HIT_RTT0 ||
                    pipedata.ssl == SSL_HIT_CLS ||
                    pipedata.ssl == SSL_DOS_LEGACY) {
                    switch (pipedata.ssl_ver) {
#ifdef TLS1_3_VERSION
                        case TLS1_3_VERSION: ++v13; break;
#endif
                        case TLS1_2_VERSION: ++v12; break;
                        case TLS1_VERSION:   ++v10; break;
                        case SSL2_VERSION:   /* DOS clients might use SSLv2 */
                        case SSL3_VERSION:   ++dos_legacy_handshakes; break;
                        default:             ;
                    }
                }
                
                if (pipedata.status < ACTION_LOG_VERB) {
                    count++;
                    if (pipedata.rx_total > 0) {
                        static float favg = 0.0;
                        static int favg_cnt = 0;
                        favg = ema(favg, pipedata.rx_total, &favg_cnt);
                        avg = favg + 0.5;
                        if (pipedata.rx_total > rmx)
                            rmx = pipedata.rx_total;
                    }

                    if (pipedata.status != FAIL_TIMEOUT && pipedata.rx_total > 0) {
                        static float ftav = 0.0;
                        static int ftav_cnt = 0;
                        ftav = ema(ftav, pipedata.run_time, &ftav_cnt);
                        tav = ftav + 0.5;
                        if (pipedata.run_time + 0.5 > tmx)
                            tmx = (pipedata.run_time + 0.5);
                    }
                } else if (pipedata.status == ACTION_DEC_KCC) {
                    static int kvg_cnt = 0;
                    kvg = ema(kvg, pipedata.krq, &kvg_cnt);
                    if (pipedata.krq > krq)
                        krq = pipedata.krq;
                }
            }
        }
    } /* end main event loop */

    /* Enhanced cleanup */
    log_msg(LGG_INFO, "Shutting down enhanced connection loop");
    
    /* Close epoll instance */
#if USE_EPOLL
    if (epfd >= 0) close(epfd);
#endif
    
    /* Close pipe file descriptors */
    if (pipefd[0] >= 0) close(pipefd[0]);
    if (pipefd[1] >= 0) close(pipefd[1]);
    
    /* Close listening sockets */
    for (int i = 0; i < num_listening_sockets; i++) {
        if (sockfds[i] >= 0) close(sockfds[i]);
    }
    
    /* Cleanup connection pool */
    if (conn_pool.connections) {
        free(conn_pool.connections);
        free(conn_pool.free_list);
        pthread_mutex_destroy(&conn_pool.mutex);
    }
    
    /* Print DOS client statistics */
    log_msg(LGG_INFO, "DOS client statistics: total=%d, downgrades=%d, legacy_handshakes=%d", 
            (int)dos_client_count, (int)dos_ssl_downgrades, (int)dos_legacy_handshakes);
}
/*
 * src/util/util.c - Enhanced utilities with DOS client support and statistics
 */

#include <stdlib.h>
#include <time.h>

#include "../util/util.h"
#include "../log/logger.h"

//#include "src/certs/certs.h"
#include "src/ssl/ssl_modules.h"

#if defined(__GLIBC__) && defined(BACKTRACE)
#include <execinfo.h>
#endif

char ssl_gate_pipe[SSLGATENX_MAX_PATH];

void generate_random_pipe_path(char *buffer, size_t buflen) {
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    int len = 32;

    srand(time(NULL) ^ getpid());
    snprintf(buffer, buflen, "/tmp/");
    for (int i = 0; i < len; ++i) {
        buffer[5 + i] = charset[rand() % (sizeof(charset) - 1)];
    }
    buffer[5 + len] = '\0';
}

// stats data
// note that child processes inherit a snapshot copy
// public data (should probably change to a struct)
volatile sig_atomic_t count = 0;
volatile sig_atomic_t avg = 0;
volatile sig_atomic_t rmx = 0;
volatile sig_atomic_t tav = 0;
volatile sig_atomic_t tmx = 0;
volatile sig_atomic_t ers = 0;
volatile sig_atomic_t tmo = 0;
volatile sig_atomic_t cls = 0;
volatile sig_atomic_t nou = 0;
volatile sig_atomic_t pth = 0;
volatile sig_atomic_t nfe = 0;
volatile sig_atomic_t ufe = 0;
volatile sig_atomic_t gif = 0;
volatile sig_atomic_t bad = 0;
volatile sig_atomic_t txt = 0;
volatile sig_atomic_t jpg = 0;
volatile sig_atomic_t png = 0;
volatile sig_atomic_t swf = 0;
volatile sig_atomic_t ico = 0;
volatile sig_atomic_t sta = 0;
volatile sig_atomic_t stt = 0;
volatile sig_atomic_t noc = 0;
volatile sig_atomic_t rdr = 0;
volatile sig_atomic_t pst = 0;
volatile sig_atomic_t hed = 0;
volatile sig_atomic_t opt = 0;
volatile sig_atomic_t cly = 0;

volatile sig_atomic_t slh = 0;
volatile sig_atomic_t slm = 0;
volatile sig_atomic_t sle = 0;
volatile sig_atomic_t slc = 0;
volatile sig_atomic_t slu = 0;
volatile sig_atomic_t uca = 0;
volatile sig_atomic_t ucb = 0;
volatile sig_atomic_t uce = 0;
volatile sig_atomic_t ush = 0;
volatile sig_atomic_t kcc = 0;
volatile sig_atomic_t kmx = 0;
float kvg = 0.0;
volatile sig_atomic_t krq = 0;
volatile sig_atomic_t clt = 0;
volatile sig_atomic_t v13 = 0;
volatile sig_atomic_t v12 = 0;
volatile sig_atomic_t v10 = 0;
volatile sig_atomic_t zrt = 0;

/* Enhanced DOS client statistics */
volatile sig_atomic_t dos_client_count = 0;
volatile sig_atomic_t dos_ssl_downgrades = 0;
volatile sig_atomic_t dos_legacy_handshakes = 0;
volatile sig_atomic_t dos_total_connections = 0;
volatile sig_atomic_t dos_successful_requests = 0;
volatile sig_atomic_t dos_failed_requests = 0;
volatile sig_atomic_t dos_ssl2_connections = 0;
volatile sig_atomic_t dos_ssl3_connections = 0;
volatile sig_atomic_t dos_tls10_connections = 0;

/* High-performance connection statistics */
volatile sig_atomic_t epoll_events_processed = 0;
volatile sig_atomic_t worker_thread_spawns = 0;
volatile sig_atomic_t connection_pool_hits = 0;
volatile sig_atomic_t connection_pool_misses = 0;

// private data
static struct timespec startup_time = {0, 0};
static clockid_t clock_source = CLOCK_MONOTONIC;

void get_time(struct timespec *time) {
  if (clock_gettime(clock_source, time) < 0) {
    if (errno == EINVAL &&
        clock_source == CLOCK_MONOTONIC) {
      clock_source = CLOCK_REALTIME;
      syslog(LOG_WARNING, "clock_gettime() reports CLOCK_MONOTONIC not supported; switching to less accurate CLOCK_REALTIME");
      get_time(time); // try again with new clock setting
    } else {
      // this should never happen
      syslog(LOG_ERR, "clock_gettime() reported failure getting time: %m");
      time->tv_sec = time->tv_nsec = 0;
    }
  }
}

unsigned int process_uptime()
{
    struct timespec now;
    get_time(&now);
    return (unsigned int) difftime(now.tv_sec, startup_time.tv_sec);
}

char* get_version(int argc, char* argv[]) {
  char* retbuf = NULL;
  char* optbuf = NULL;
  unsigned int optlen = 0, freeoptbuf = 0;
  unsigned int arglen[argc];

  // capture startup_time if not yet set
  if (!startup_time.tv_sec) {
    get_time(&startup_time);
  }

  // determine total size of all arguments
  for (int i = 1; i < argc; ++i) {
    arglen[i] = strlen(argv[i]) + 1; // add 1 for leading space
    optlen += arglen[i];
  }
  if (optlen > 0) {
    // allocate a buffer to hold all arguments
    optbuf = malloc((optlen * sizeof(char)) + 1);
    if (optbuf) {
      freeoptbuf = 1;
      // concatenate arguments into buffer
      for (int i = 1, optlen = 0; i < argc; ++i) {
        optbuf[optlen] = ' '; // prepend a space to each argument
        strncpy(optbuf + optlen + 1, argv[i], arglen[i]);
        optlen += arglen[i];
      }
      optbuf[optlen] = '\0';
    } else {
      optbuf = " <malloc error>";
    }
  } else {
    optbuf = " <none>";
  }

  if (asprintf(&retbuf, "SSLGateNX %s (compiled: %s" FEATURE_FLAGS " +DOS_SUPPORT +EPOLL_MODE) options:%s",
          VERSION, __DATE__ " " __TIME__, optbuf) < 1) {
    retbuf = " <asprintf error>";
  }

  if (freeoptbuf) {
    free(optbuf);
    freeoptbuf = 0;
  }

  return retbuf;
}

/* Print DOS client statistics */
void print_dos_statistics(void) {
    printf("\n=== DOS Client Statistics ===\n");
    printf("Active DOS clients: %d\n", (int)dos_client_count);
    printf("Total DOS connections: %d\n", (int)dos_total_connections);
    printf("DOS SSL downgrades: %d\n", (int)dos_ssl_downgrades);
    printf("DOS legacy handshakes: %d\n", (int)dos_legacy_handshakes);
    printf("DOS successful requests: %d\n", (int)dos_successful_requests);
    printf("DOS failed requests: %d\n", (int)dos_failed_requests);
    printf("DOS SSLv2 connections: %d\n", (int)dos_ssl2_connections);
    printf("DOS SSLv3 connections: %d\n", (int)dos_ssl3_connections);
    printf("DOS TLS 1.0 connections: %d\n", (int)dos_tls10_connections);
    printf("=============================\n");
}

char* get_stats(const int sta_offset, const int stt_offset) {
    char* retbuf = NULL, *uptimeStr = NULL;
    unsigned int uptime = process_uptime();

    /* Enhanced stats format with DOS client support */
    const char* sta_fmt = "<br><table>"
        "<tr><td>uts</td><td>%s</td><td>process uptime</td></tr>"
        "<tr><td>log</td><td>%d</td><td>critical (0) error (1) warning (2) notice (3) info (4) debug (5)</td></tr>"
        "<tr><td>kcc</td><td>%d</td><td>number of active service threads</td></tr>"
        "<tr><td>kmx</td><td>%d</td><td>maximum number of service threads</td></tr>"
        "<tr><td>kvg</td><td>%.2f</td><td>average number of requests per service thread</td></tr>"
        "<tr><td>krq</td><td>%d</td><td>max number of requests by one service thread</td></tr>"
        "<tr><th colspan=\"3\">DOS CLIENT STATISTICS</th></tr>"
        "<tr><td>dos</td><td>%d</td><td>active DOS clients</td></tr>"
        "<tr><td>dot</td><td>%d</td><td>total DOS connections served</td></tr>"
        "<tr><td>dod</td><td>%d</td><td>DOS SSL downgrades performed</td></tr>"
        "<tr><td>dol</td><td>%d</td><td>DOS legacy handshakes</td></tr>"
        "<tr><td>dos2</td><td>%d</td><td>DOS SSLv2 connections</td></tr>"
        "<tr><td>dos3</td><td>%d</td><td>DOS SSLv3 connections</td></tr>"
        "<tr><td>dot1</td><td>%d</td><td>DOS TLS 1.0 connections</td></tr>"
        "<tr><th colspan=\"3\">PERFORMANCE STATISTICS</th></tr>"
        "<tr><td>epo</td><td>%d</td><td>epoll events processed</td></tr>"
        "<tr><td>wts</td><td>%d</td><td>worker thread spawns</td></tr>"
        "<tr><td>cph</td><td>%d</td><td>connection pool hits</td></tr>"
        "<tr><td>cpm</td><td>%d</td><td>connection pool misses</td></tr>"
        "<tr><th colspan=\"3\">GENERAL STATISTICS</th></tr>"
        "<tr><td>req</td><td>%d</td><td>total # of requests (HTTP, HTTPS, success, failure etc)</td></tr>"
        "<tr><td>avg</td><td>%d bytes</td><td>average size of requests</td></tr>"
        "<tr><td>rmx</td><td>%d bytes</td><td>largest size of request(s)</td></tr>"
        "<tr><td>tav</td><td>%d ms</td><td>average processing time (per request)</td></tr>"
        "<tr><td>tmx</td><td>%d ms</td><td>longest processing time (per request)</td></tr>"
        "<tr><th colspan=\"3\">SSL/TLS STATISTICS</th></tr>"
        "<tr><td>slh</td><td>%d</td><td># of accepted HTTPS requests</td></tr>"
        "<tr><td>slm</td><td>%d</td><td># of rejected HTTPS requests (missing certificate)</td></tr>"
        "<tr><td>sle</td><td>%d</td><td># of rejected HTTPS requests (certificate available but not usable)</td></tr>"
        "<tr><td>slc</td><td>%d</td><td># of dropped HTTPS requests (client disconnect without sending any request)</td></tr>"
        "<tr><td>slu</td><td>%d</td><td># of dropped HTTPS requests (other TLS handshake errors)</td></tr>"
        "<tr><th colspan=\"3\">TLS VERSION BREAKDOWN</th></tr>"
        "<tr><td>v13</td><td>%d</td><td>slh/slc break-down: TLS 1.3</td></tr>"
        "<tr><td>v12</td><td>%d</td><td>slh/slc break-down: TLS 1.2</td></tr>"
        "<tr><td>v10</td><td>%d</td><td>slh/slc break-down: TLS 1.0</td></tr>"
        "<tr><td>zrt</td><td>%d</td><td>slh break-down: TLS 1.3 Early Data aka 0-RTT</td></tr>"
        "<tr><th colspan=\"3\">SSL ERROR BREAKDOWN</th></tr>"
        "<tr><td>uca</td><td>%d</td><td>slu break-down: # of unknown CA reported by clients</td></tr>"
        "<tr><td>ucb</td><td>%d</td><td>slu break-down: # of bad certificate reported by clients</td></tr>"
        "<tr><td>uce</td><td>%d</td><td>slu break-down: # of unknown cert reported by clients</td></tr>"
        "<tr><td>ush</td><td>%d</td><td>slu break-down: # of shutdown by clients after ServerHello</td></tr>"
        "<tr><th colspan=\"3\">CERTIFICATE CACHE</th></tr>"
        "<tr><td>sct</td><td>%d</td><td>cert cache: # of certs in cache</td></tr>"
        "<tr><td>sch</td><td>%d</td><td>cert cache: # of reuses of cached certs</td></tr>"
        "<tr><td>scm</td><td>%d</td><td>cert cache: # of misses to find a cert in cache</td></tr>"
        "<tr><td>scp</td><td>%d</td><td>cert cache: # of purges to give room for a new cert</td></tr>"
        "<tr><td>ssh</td><td>%d</td><td>sess cache: # of reuses of cached TLS sessions</td></tr>"
        "<tr><td>ssm</td><td>%d</td><td>sess cache: # of misses to find a TLS session in cache</td></tr>"
        "<tr><td>ssp</td><td>%d</td><td>sess cache: # of purges to give room for a new TLS session</td></tr>"
        "<tr><th colspan=\"3\">REQUEST TYPE BREAKDOWN</th></tr>"
        "<tr><td>nfe</td><td>%d</td><td># of GET requests for server-side scripting</td></tr>"
        "<tr><td>gif</td><td>%d</td><td># of GET requests for GIF</td></tr>"
        "<tr><td>ico</td><td>%d</td><td># of GET requests for ICO</td></tr>"
        "<tr><td>txt</td><td>%d</td><td># of GET requests for Javascripts</td></tr>"
        "<tr><td>jpg</td><td>%d</td><td># of GET requests for JPG</td></tr>"
        "<tr><td>png</td><td>%d</td><td># of GET requests for PNG</td></tr>"
        "<tr><td>swf</td><td>%d</td><td># of GET requests for SWF</td></tr>"
        "<tr><td>ufe</td><td>%d</td><td># of GET requests /w unknown file extension</td></tr>"
        "<tr><th colspan=\"3\">HTTP METHOD BREAKDOWN</th></tr>"
        "<tr><td>opt</td><td>%d</td><td># of OPTIONS requests</td></tr>"
        "<tr><td>pst</td><td>%d</td><td># of POST requests</td></tr>"
        "<tr><td>hed</td><td>%d</td><td># of HEAD requests (HTTP 501 response)</td></tr>"
        "<tr><td>rdr</td><td>%d</td><td># of GET requests resulted in REDIRECT response</td></tr>"
        "<tr><td>nou</td><td>%d</td><td># of GET requests /w empty URL</td></tr>"
        "<tr><td>pth</td><td>%d</td><td># of GET requests /w malformed URL</td></tr>"
        "<tr><td>204</td><td>%d</td><td># of GET requests (HTTP 204 response)</td></tr>"
        "<tr><td>bad</td><td>%d</td><td># of unknown HTTP requests (HTTP 501 response)</td></tr>"
        "<tr><th colspan=\"3\">CONNECTION FAILURES</th></tr>"
        "<tr><td>cls</td><td>%d</td><td># of dropped requests (client disconnect without sending any request)</td></tr>"
        "<tr><td>cly</td><td>%d</td><td># of dropped requests (client disconnect before response sent)</td></tr>"
        "<tr><td>clt</td><td>%d</td><td># of dropped requests (reached maximum service threads)</td></tr>"
        "<tr><td>err</td><td>%d</td><td># of dropped requests (unknown reason)</td></tr>"
        "</table>";

    const char* stt_fmt = "%d uts, %d log, %d kcc, %d kmx, %.2f kvg, %d krq, "
        "%d dos, %d dot, %d dod, %d dol, %d dos2, %d dos3, %d dot1, "
        "%d epo, %d wts, %d cph, %d cpm, "
        "%d req, %d avg, %d rmx, %d tav, %d tmx, %d slh, %d slm, %d sle, %d slc, %d slu, "
        "%d v13, %d v12, %d v10, %d zrt, %d uca, %d ucb, %d uce, %d ush, "
        "%d sct, %d sch, %d scm, %d scp, %d ssh, %d ssm, %d ssp, "
        "%d nfe, %d gif, %d ico, %d txt, %d jpg, %d png, %d swf, %d ufe, "
        "%d opt, %d pst, %d hed, %d rdr, %d nou, %d pth, %d 204, %d bad, "
        "%d cls, %d cly, %d clt, %d err";

    int sct = sslctx_tbl_get_cnt_total();
    int sch = sslctx_tbl_get_cnt_hit();
    int scm = sslctx_tbl_get_cnt_miss();
    int scp = sslctx_tbl_get_cnt_purge();
    int sst = sslctx_tbl_get_sess_cnt();
    int ssh = sslctx_tbl_get_sess_hit();
    int ssm = sslctx_tbl_get_sess_miss();
    int ssp = sslctx_tbl_get_sess_purge();

    if (asprintf(&uptimeStr, "%dd %02d:%02d", (int)uptime/86400, (int)(uptime%86400)/3600, (int)((uptime%86400)%3600)/60) < 1
        || asprintf(&retbuf, (sta_offset) ? sta_fmt : stt_fmt,
        (sta_offset) ? (long)uptimeStr : (long)uptime, log_get_verb(), kcc, kmx, kvg, krq,
        /* DOS statistics */
        (int)dos_client_count, (int)dos_total_connections, (int)dos_ssl_downgrades, (int)dos_legacy_handshakes,
        (int)dos_ssl2_connections, (int)dos_ssl3_connections, (int)dos_tls10_connections,
        /* Performance statistics */
        (int)epoll_events_processed, (int)worker_thread_spawns, (int)connection_pool_hits, (int)connection_pool_misses,
        /* General statistics */
        count, avg, rmx, tav, tmx, slh, slm, sle, slc, slu, v13, v12, v10, zrt, uca, ucb, uce, ush, 
        sct, sch, scm, scp, sst + ssh, ssm, ssp, nfe, gif, ico, txt, jpg, png, swf, ufe, 
        opt, pst, hed, rdr, nou, pth, noc, bad, cls, cly, clt, ers
        ) < 1)
        retbuf = " <asprintf error>";

    free(uptimeStr);
    return retbuf;
}

// Use SMA for the first 500 samples approximated by # of requets. Use EMA afterwards
float ema(float curr, int new, int *cnt) {
    if (count < 500) {
      curr *= *cnt;
      curr = (curr + new) / ++(*cnt);
    } else
      curr += 0.002 * (new - curr);
    return curr;
}

double elapsed_time_msec(const struct timespec start_time) {
  struct timespec current_time = {0, 0};
  struct timespec diff_time = {0, 0};

  if (!start_time.tv_sec &&
      !start_time.tv_nsec) {
    log_msg(LGG_DEBUG, "check_time(): returning because start_time not set");
    return -1.0;
  }

  get_time(&current_time);

  diff_time.tv_sec = difftime(current_time.tv_sec, start_time.tv_sec) + 0.5;
  diff_time.tv_nsec = current_time.tv_nsec - start_time.tv_nsec;
  if (diff_time.tv_nsec < 0) {
    // normalize nanoseconds
    diff_time.tv_sec  -= 1;
    diff_time.tv_nsec += 1000000000;
  }

  return diff_time.tv_sec * 1000 + ((double)diff_time.tv_nsec / 1000000);
}

/* Enhanced client IP detection with DOS client logging */
void get_client_ip(int fd, char *client_ip, size_t client_ip_len, char *client_port, size_t client_port_len) {
    struct sockaddr_storage addr;
    socklen_t addr_len = sizeof(addr);
    
    if (getpeername(fd, (struct sockaddr*)&addr, &addr_len) != 0) {
        log_msg(LGG_ERR, "getpeername failed: %m");
        if (client_ip && client_ip_len > 0) client_ip[0] = '\0';
        if (client_port && client_port_len > 0) client_port[0] = '\0';
        return;
    }
    
    char ip_str[INET6_ADDRSTRLEN];
    char port_str[NI_MAXSERV];
    
    if (getnameinfo((struct sockaddr*)&addr, addr_len,
                   ip_str, sizeof(ip_str),
                   port_str, sizeof(port_str),
                   NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
        log_msg(LGG_ERR, "getnameinfo failed: %m");
        if (client_ip && client_ip_len > 0) client_ip[0] = '\0';
        if (client_port && client_port_len > 0) client_port[0] = '\0';
        return;
    }
    
    if (client_ip && client_ip_len > 0) {
        strncpy(client_ip, ip_str, client_ip_len - 1);
        client_ip[client_ip_len - 1] = '\0';
    }
    
    if (client_port && client_port_len > 0) {
        strncpy(client_port, port_str, client_port_len - 1);
        client_port[client_port_len - 1] = '\0';
    }
}

/* Enhanced logging function with DOS client context */
void log_xcs(logger_level level, const char *client_ip, const char *host, 
             int ssl_version, const char *request, const char *post_data, size_t post_len) {
    if (log_get_verb() < level) return;
    
    char ssl_info[64] = "";
    char dos_info[32] = "";
    
    /* Format SSL version information */
    switch (ssl_version) {
        case SSL2_VERSION:
            strcpy(ssl_info, "SSLv2");
            strcpy(dos_info, " [DOS]");
            break;
        case SSL3_VERSION:
            strcpy(ssl_info, "SSLv3");
            strcpy(dos_info, " [DOS]");
            break;
        case TLS1_VERSION:
            strcpy(ssl_info, "TLS1.0");
            strcpy(dos_info, " [DOS]");
            break;
        case TLS1_1_VERSION:
            strcpy(ssl_info, "TLS1.1");
            break;
        case TLS1_2_VERSION:
            strcpy(ssl_info, "TLS1.2");
            break;
#ifdef TLS1_3_VERSION
        case TLS1_3_VERSION:
            strcpy(ssl_info, "TLS1.3");
            break;
#endif
        default:
            strcpy(ssl_info, "HTTP");
            break;
    }
    
    /* Enhanced logging format with DOS client indication */
    log_msg(level, "Client: %s%s Host: %s Protocol: %s Request: %.100s%s",
            client_ip ? client_ip : "unknown",
            dos_info,
            host ? host : "unknown",
            ssl_info,
            request ? request : "none",
            post_len > 0 ? " [POST data]" : "");
}

#if defined(__GLIBC__) && defined(BACKTRACE)
void print_trace(int sig) {

  void *buf[32];
  char **strings;
  int size, i;
  log_msg(LGG_CRIT, "signal %d\n", sig);
  size = backtrace(buf, 32);
  strings = backtrace_symbols(buf, size);
  log_msg(LGG_CRIT, "backtrace:");
  for (i = 0; i < size; i++)
    log_msg(LGG_CRIT, "%d %s", buf[i], strings[i]);
  free(strings);
  exit(EXIT_FAILURE);
}
#endif
/*
 * debug_system.c - Debug System Implementation
 * 
 * Diese Datei wird NUR bei DEBUG-Builds kompiliert!
 * Production Builds enthalten diese Datei GAR NICHT.
 */

#ifdef DEBUG

#include "debug_system.h"
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <ctype.h>
#include <stdlib.h>

/* =========================================================================
 * DEBUG STATE
 * ========================================================================= */

static logger_level current_verbose_level = LGG_ERR;
static struct timespec debug_start_time = {0, 0};

/* =========================================================================
 * HELPER FUNCTIONS
 * ========================================================================= */

static void get_current_time(struct timespec *ts) {
    clock_gettime(CLOCK_MONOTONIC, ts);
}

static double time_diff_ms(struct timespec start, struct timespec end) {
    return (end.tv_sec - start.tv_sec) * 1000.0 + 
           (end.tv_nsec - start.tv_nsec) / 1000000.0;
}

static int should_log(logger_level level) {
    return level <= current_verbose_level;
}

static int ctrl_char(char *buf, size_t len) {
    if (strlen(buf) < len)
        return 1;
    for (size_t i=0; i<(len - 1); i++) {
        if (buf[i] >= 10 && buf[i] <= 13)
            continue;
        if (buf[i] < 32) {
            return 1;
        }
    }
    return 0;
}

/* =========================================================================
 * CORE LOGGING FUNCTIONS
 * ========================================================================= */

void debug_log_msg(logger_level level, const char *fmt, ...) {
    if (!should_log(level)) {
        return;
    }
    
    va_list args;
    va_start(args, fmt);
    
    /* Syslog fĆ¼r wichtige Nachrichten */
    vsyslog(LOG_CRIT + level, fmt, args);
    
    va_end(args);
}

void debug_log_xcs(logger_level level, char *client_ip, char *host, int tls, 
                   char *req, char *body, size_t body_len) {
    if (!should_log(level) || !client_ip || !host || !req) {
        return;
    }
    
    /* TLS Version String */
    const char* tls_ver;
    switch (tls) {
        case TLS1_3_VERSION: tls_ver = "1.3"; break;
        case TLS1_2_VERSION: tls_ver = "1.2"; break;
        case TLS1_VERSION:   tls_ver = "1.0"; break;
        case 0:
        default:
            tls_ver = "none";
    }

    /* Request Logging */
    if (strlen(req) < MAX_LOG_CHUNK_SIZE) {
        syslog(LOG_CRIT + level, "%s %s %s tls_%s", client_ip, host, req, tls_ver);
    } else {
        int num_chunks = strlen(req) / MAX_LOG_CHUNK_SIZE + 1;
        char store = req[MAX_LOG_CHUNK_SIZE];
        req[MAX_LOG_CHUNK_SIZE] = '\0';
        syslog(LOG_CRIT + level, "%s %s %s", client_ip, host, req);
        req[MAX_LOG_CHUNK_SIZE] = store;

        int chunk = 1;
        if (num_chunks > 2) {
            for (; chunk < num_chunks - 1; chunk++) {
                store = req[MAX_LOG_CHUNK_SIZE * (chunk + 1)];
                req[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = '\0';
                syslog(LOG_CRIT + level, "%s", req + MAX_LOG_CHUNK_SIZE * chunk);
                req[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = store;
            }
        }
        syslog(LOG_CRIT + level, "%s tls_%s", req + MAX_LOG_CHUNK_SIZE * chunk, tls_ver);
    }

    /* Body Logging falls vorhanden */
    if (body_len > 0 && body) {
        if (ctrl_char(body, body_len)) {
            syslog(LOG_CRIT + level, "[%s]", "-binary POST content not dumped-");
        } else if (strlen(body) < MAX_LOG_CHUNK_SIZE) {
            syslog(LOG_CRIT + level, "[%s]", body);
        } else {
            int num_chunks = strlen(body) / MAX_LOG_CHUNK_SIZE + 1;
            char store = body[MAX_LOG_CHUNK_SIZE];
            body[MAX_LOG_CHUNK_SIZE] = '\0';
            syslog(LOG_CRIT + level, "[%s", body);
            body[MAX_LOG_CHUNK_SIZE] = store;

            int chunk = 1;
            if (num_chunks > 2) {
                for (; chunk < num_chunks - 1; chunk++) {
                    store = body[MAX_LOG_CHUNK_SIZE * (chunk + 1)];
                    body[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = '\0';
                    syslog(LOG_CRIT + level, "%s", body + MAX_LOG_CHUNK_SIZE * chunk);
                    body[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = store;
                }
            }
            syslog(LOG_CRIT + level, "%s]", body + MAX_LOG_CHUNK_SIZE * chunk);
        }
    }
}

/* =========================================================================
 * CONFIGURATION FUNCTIONS
 * ========================================================================= */

void debug_set_verbose_level(logger_level level) {
    if (level >= LGG_CRIT && level <= LGG_DEBUG) {
        current_verbose_level = level;
        debug_log_msg(LGG_NOTICE, "Debug verbose level set to %d", level);
    }
}

logger_level debug_get_verbose_level(void) {
    return current_verbose_level;
}

/* =========================================================================
 * UTILITY FUNCTIONS
 * ========================================================================= */

void debug_time_check(const char *description) {
    static struct timespec last_time = {0, 0};
    struct timespec now;
    get_current_time(&now);
    
    if (last_time.tv_sec != 0) {
        double elapsed = time_diff_ms(last_time, now);
        debug_log_msg(LGG_DEBUG, "TIME_CHECK [%s]: %.2f ms", description, elapsed);
    }
    
    last_time = now;
}

void debug_hex_dump(void *data, int size) {
    if (!should_log(LGG_DEBUG) || !data || size <= 0) {
        return;
    }
    
    unsigned char *p = (unsigned char*)data;
    char hex_str[16*3 + 5] = {0};
    char char_str[16*1 + 5] = {0};
    
    debug_log_msg(LGG_DEBUG, "=== HEX DUMP (%d bytes) ===", size);
    
    for (int n = 0; n < size; n++) {
        if (n % 16 == 0 && n > 0) {
            debug_log_msg(LGG_DEBUG, "[%04x]   %-48s  %s", n - 16, hex_str, char_str);
            hex_str[0] = '\0';
            char_str[0] = '\0';
        }
        
        /* Hex Teil */
        char byte_str[4];
        snprintf(byte_str, sizeof(byte_str), "%02X ", p[n]);
        strncat(hex_str, byte_str, sizeof(hex_str) - strlen(hex_str) - 1);
        
        /* Char Teil */
        char char_byte[2];
        char_byte[0] = isprint(p[n]) ? p[n] : '.';
        char_byte[1] = '\0';
        strncat(char_str, char_byte, sizeof(char_str) - strlen(char_str) - 1);
        
        /* Spacing bei 8 Bytes */
        if ((n + 1) % 8 == 0) {
            strncat(hex_str, " ", sizeof(hex_str) - strlen(hex_str) - 1);
            strncat(char_str, " ", sizeof(char_str) - strlen(char_str) - 1);
        }
    }
    
    /* Letzte Zeile */
    if (strlen(hex_str) > 0) {
        int remaining = size % 16;
        debug_log_msg(LGG_DEBUG, "[%04x]   %-48s  %s", 
                     size - remaining, hex_str, char_str);
    }
    
    debug_log_msg(LGG_DEBUG, "=== END HEX DUMP ===");
}

/* =========================================================================
 * SYSTEM INITIALIZATION
 * ========================================================================= */

void debug_system_init(void) {
    get_current_time(&debug_start_time);
    current_verbose_level = LGG_ERR; /* Default Level */
    
    /* Syslog initialisieren */
    openlog("SSLGateNX-debug", LOG_PID | LOG_PERROR, LOG_DAEMON);
    
    debug_log_msg(LGG_NOTICE, "Debug system initialized");
}

void debug_system_cleanup(void) {
    debug_log_msg(LGG_NOTICE, "Debug system cleanup");
    closelog();
}

#endif /* DEBUG */
/*
 * SSLGateNX.c - Main entry point with DOS client support and high-performance scaling
 * 
 * Enhanced for MS-DOS client compatibility and 2-3M user scalability
 */

#include "src/util/util.h"

#include <sys/resource.h>
#include <pwd.h>
#include <grp.h>

#ifdef __linux__
#include <sys/epoll.h>
#define USE_EPOLL 1
#define MAX_EPOLL_EVENTS 1000
#else
#define USE_EPOLL 0
#endif

#include "src/main/server_init.h"
#include "src/main/connection_loop.h"
#include "src/log/logger.h"
#include "src/ssl/ssl_config.h"

/* Global configuration */
struct Global *g_config = NULL;

/* DOS Client Detection */
typedef struct {
    int is_dos_client;
    int use_small_buffers;
    int legacy_ssl_mode;
    time_t connect_time;
} dos_client_info_t;

/* High-performance worker thread pool */
#define WORKER_THREAD_COUNT 64
#define CONNECTION_QUEUE_SIZE 10000

typedef struct connection_job {
    int fd;
    struct sockaddr_storage client_addr;
    socklen_t addr_len;
    dos_client_info_t dos_info;
    struct connection_job *next;
} connection_job_t;

typedef struct {
    connection_job_t *head;
    connection_job_t *tail;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int count;
} connection_queue_t;

static connection_queue_t job_queue = {0};
static pthread_t worker_threads[WORKER_THREAD_COUNT];
static volatile int workers_shutdown = 0;

/* DOS Client Detection Functions */
static int detect_dos_client(int fd, struct sockaddr_storage *addr) {
    char peek_buf[16];
    int peek_len = recv(fd, peek_buf, sizeof(peek_buf), MSG_PEEK);
    
    if (peek_len <= 0) return 0;
    
    /* Basic heuristics for DOS clients:
     * - Very small initial packets
     * - Specific SSL handshake patterns
     * - Legacy cipher preferences
     */
    if (peek_len < 8) return 1;  /* DOS clients often send small packets */
    
    /* Check for SSLv2 CLIENT-HELLO (starts with 0x80) */
    if ((unsigned char)peek_buf[0] == 0x80) return 1;
    
    /* Check for very old TLS patterns */
    if (peek_len >= 3 && peek_buf[0] == 0x16 && peek_buf[1] == 0x03 && peek_buf[2] <= 0x01) {
        return 1;  /* TLS 1.0 or earlier */
    }
    
    return 0;
}

static void configure_dos_client(SSL_CTX *ctx, dos_client_info_t *dos_info) {
    if (!dos_info->is_dos_client) return;
    
    log_msg(LGG_INFO, "Configuring DOS client compatibility mode");
    
    /* Enable legacy protocols */
    SSL_CTX_clear_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1);
    SSL_CTX_set_min_proto_version(ctx, SSL2_VERSION);
    SSL_CTX_set_max_proto_version(ctx, TLS1_VERSION);
    
    /* Set DOS-compatible cipher list */
    SSL_CTX_set_cipher_list(ctx, SSLGATENX_CIPHER_LIST_DOS);
    
    /* Increase timeouts for slow DOS clients */
    SSL_CTX_set_timeout(ctx, 300);  /* 5 minutes */
    
    /* Use smaller session cache */
    SSL_CTX_sess_set_cache_size(ctx, 10);
    
    dos_info->use_small_buffers = 1;
    dos_info->legacy_ssl_mode = 1;
}

/* Worker thread function */
static void* worker_thread(void *arg) {
    int worker_id = (int)(intptr_t)arg;
    
    log_msg(LGG_DEBUG, "Worker thread %d started", worker_id);
    
    while (!workers_shutdown) {
        pthread_mutex_lock(&job_queue.mutex);
        
        while (!job_queue.head && !workers_shutdown) {
            pthread_cond_wait(&job_queue.cond, &job_queue.mutex);
        }
        
        if (workers_shutdown) {
            pthread_mutex_unlock(&job_queue.mutex);
            break;
        }
        
        /* Dequeue job */
        connection_job_t *job = job_queue.head;
        job_queue.head = job->next;
        if (!job_queue.head) job_queue.tail = NULL;
        job_queue.count--;
        
        pthread_mutex_unlock(&job_queue.mutex);
        
        /* Process connection */
        if (job) {
            conn_tlstor_struct *conn_data = conn_stor_acquire();
            if (conn_data) {
                conn_data->new_fd = job->fd;
                conn_data->dos_client_info = job->dos_info;
                
                /* Call enhanced connection handler */
                conn_handler(conn_data);
            } else {
                log_msg(LGG_WARNING, "Failed to acquire connection storage");
                close(job->fd);
            }
            free(job);
        }
    }
    
    log_msg(LGG_DEBUG, "Worker thread %d terminated", worker_id);
    return NULL;
}

/* Initialize worker thread pool */
static int init_worker_pool(void) {
    pthread_mutex_init(&job_queue.mutex, NULL);
    pthread_cond_init(&job_queue.cond, NULL);
    
    for (int i = 0; i < WORKER_THREAD_COUNT; i++) {
        if (pthread_create(&worker_threads[i], NULL, worker_thread, (void*)(intptr_t)i) != 0) {
            log_msg(LGG_ERR, "Failed to create worker thread %d", i);
            return -1;
        }
    }
    
    log_msg(LGG_INFO, "Initialized %d worker threads", WORKER_THREAD_COUNT);
    return 0;
}

/* Shutdown worker thread pool */
static void shutdown_worker_pool(void) {
    workers_shutdown = 1;
    pthread_cond_broadcast(&job_queue.cond);
    
    for (int i = 0; i < WORKER_THREAD_COUNT; i++) {
        pthread_join(worker_threads[i], NULL);
    }
    
    pthread_mutex_destroy(&job_queue.mutex);
    pthread_cond_destroy(&job_queue.cond);
    log_msg(LGG_INFO, "Worker thread pool shutdown complete");
}

/* Enhanced connection acceptance with epoll */
static int run_enhanced_server(char *ip_addr, int use_ip, char *ports[], int num_ports, 
                              int max_num_threads, struct Global *global_config) {
    int sockfds[MAX_PORTS] = {0};
    int num_sockets = 0;
    
#if USE_EPOLL
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        log_msg(LGG_ERR, "Failed to create epoll instance: %m");
        return -1;
    }
    
    struct epoll_event events[MAX_EPOLL_EVENTS];
    log_msg(LGG_INFO, "Using epoll for high-performance I/O");
#else
    fd_set readfds, selectfds;
    int nfds = 0;
    FD_ZERO(&readfds);
    log_msg(LGG_INFO, "Using select for I/O (epoll not available)");
#endif
    
    /* Set up listening sockets */
    for (int i = 0; i < num_ports; i++) {
        int sockfd = create_listening_socket(ip_addr, ports[i], use_ip);
        if (sockfd < 0) {
            log_msg(LGG_ERR, "Failed to create listening socket for port %s", ports[i]);
            continue;
        }
        
        sockfds[num_sockets] = sockfd;
        
#if USE_EPOLL
        struct epoll_event ev;
        ev.events = EPOLLIN;
        ev.data.fd = sockfd;
        if (epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev) == -1) {
            log_msg(LGG_ERR, "Failed to add socket to epoll: %m");
            close(sockfd);
            continue;
        }
#else
        FD_SET(sockfd, &readfds);
        if (sockfd > nfds) nfds = sockfd;
#endif
        
        num_sockets++;
        log_msg(LGG_INFO, "Listening on %s:%s (socket %d)", 
                ip_addr ? ip_addr : "*", ports[i], sockfd);
    }
    
    if (num_sockets == 0) {
        log_msg(LGG_ERR, "No listening sockets created");
        return -1;
    }
    
    /* Main event loop */
    log_msg(LGG_INFO, "Starting main event loop with %d sockets", num_sockets);
    
    while (1) {
        int ready_count;
        
#if USE_EPOLL
        ready_count = epoll_wait(epfd, events, MAX_EPOLL_EVENTS, -1);
        if (ready_count == -1) {
            if (errno == EINTR) continue;
            log_msg(LGG_ERR, "epoll_wait failed: %m");
            break;
        }
#else
        selectfds = readfds;
        ready_count = select(nfds + 1, &selectfds, NULL, NULL, NULL);
        if (ready_count == -1) {
            if (errno == EINTR) continue;
            log_msg(LGG_ERR, "select failed: %m");
            break;
        }
#endif
        
        /* Process ready sockets */
#if USE_EPOLL
        for (int i = 0; i < ready_count; i++) {
            int listen_fd = events[i].data.fd;
#else
        for (int i = 0; i < num_sockets; i++) {
            int listen_fd = sockfds[i];
            if (!FD_ISSET(listen_fd, &selectfds)) continue;
#endif
            
            /* Accept new connection */
            struct sockaddr_storage client_addr;
            socklen_t addr_len = sizeof(client_addr);
            int client_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &addr_len);
            
            if (client_fd == -1) {
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
                    log_msg(LGG_WARNING, "accept failed: %m");
                }
                continue;
            }
            
            /* Set non-blocking mode for client socket */
            int flags = fcntl(client_fd, F_GETFL, 0);
            fcntl(client_fd, F_SETFL, flags & ~O_NONBLOCK);  /* Make blocking for SSL */
            
            /* Detect DOS client */
            dos_client_info_t dos_info = {0};
            dos_info.is_dos_client = detect_dos_client(client_fd, &client_addr);
            dos_info.connect_time = time(NULL);
            
            if (dos_info.is_dos_client) {
                log_msg(LGG_INFO, "DOS client detected, enabling compatibility mode");
            }
            
            /* Queue job for worker thread */
            connection_job_t *job = malloc(sizeof(connection_job_t));
            if (!job) {
                log_msg(LGG_ERR, "Failed to allocate connection job");
                close(client_fd);
                continue;
            }
            
            job->fd = client_fd;
            job->client_addr = client_addr;
            job->addr_len = addr_len;
            job->dos_info = dos_info;
            job->next = NULL;
            
            /* Add to job queue */
            pthread_mutex_lock(&job_queue.mutex);
            if (job_queue.count >= CONNECTION_QUEUE_SIZE) {
                pthread_mutex_unlock(&job_queue.mutex);
                log_msg(LGG_WARNING, "Connection queue full, dropping connection");
                close(client_fd);
                free(job);
                continue;
            }
            
            if (!job_queue.tail) {
                job_queue.head = job_queue.tail = job;
            } else {
                job_queue.tail->next = job;
                job_queue.tail = job;
            }
            job_queue.count++;
            
            pthread_cond_signal(&job_queue.cond);
            pthread_mutex_unlock(&job_queue.mutex);
        }
    }
    
    /* Cleanup */
#if USE_EPOLL
    close(epfd);
#endif
    
    for (int i = 0; i < num_sockets; i++) {
        close(sockfds[i]);
    }
    
    return 0;
}

/* Enhanced main function */
int main(int argc, char *argv[]) {
    /* Set high file descriptor limit */
    struct rlimit rl;
    rl.rlim_cur = rl.rlim_max = 100000;
    if (setrlimit(RLIMIT_NOFILE, &rl) == -1) {
        log_msg(LGG_WARNING, "Failed to increase file descriptor limit: %m");
    }
    
    /* Initialize logging */
    log_set_verb(LGG_INFO);
    log_msg(LGG_INFO, "SSLGateNX starting with DOS client support and high-performance scaling");
    
    /* Parse command line arguments (simplified for example) */
    char *ip_addr = NULL;
    char *ports[] = {"80", "443"};
    int num_ports = 2;
    int max_threads = 10000;  /* Increased for high load */
    
    /* Create global configuration */
    g_config = malloc(sizeof(struct Global));
    if (!g_config) {
        log_msg(LGG_ERR, "Failed to allocate global configuration");
        return EXIT_FAILURE;
    }
    
    /* Initialize global config (simplified) */
    memset(g_config, 0, sizeof(struct Global));
    g_config->argc = argc;
    g_config->argv = argv;
    
    /* Initialize SSL and certificate handling */
    cert_tlstor_t cert_storage;
    pthread_t cert_thread;
    
    if (initialize_server("/opt/var/cache/SSLGateNX", 1000, max_threads, 0, 
                         &cert_storage, NULL, &cert_thread) != 0) {
        log_msg(LGG_ERR, "Server initialization failed");
        free(g_config);
        return EXIT_FAILURE;
    }
    
    /* Initialize worker thread pool */
    if (init_worker_pool() != 0) {
        log_msg(LGG_ERR, "Failed to initialize worker thread pool");
        cleanup_server();
        free(g_config);
        return EXIT_FAILURE;
    }
    
    /* Start enhanced server */
    log_msg(LGG_INFO, "Starting enhanced server with DOS support");
    int result = run_enhanced_server(ip_addr, 0, ports, num_ports, max_threads, g_config);
    
    /* Cleanup */
    log_msg(LGG_INFO, "Shutting down server");
    shutdown_worker_pool();
    cleanup_server();
    free(g_config);
    
    log_msg(LGG_INFO, "SSLGateNX shutdown complete");
    return result == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
}
