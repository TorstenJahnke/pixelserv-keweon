/*
* pixelserv.c
* Location: ./pixelserv.c
* 
* a small mod to public domain server.c -- a stream socket server demo
* from http://beej.us/guide/bgnet/
* single pixel http string from http://proxytunnel.sourceforge.net/pixelserv.php
*/

#include <fcntl.h>
#include <pthread.h>
#ifdef DROP_ROOT
#include <pwd.h>
#endif
#ifdef TEST
#include <arpa/inet.h>
#endif
#ifdef linux
#include <linux/version.h>
#endif
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>

#include "src/ssl/ssl_modules.h"
#include "src/sock/socket_handler.h"
#include "src/log/logger.h"
#include "src/util/util.h"
#include "src/main/signal_handler.h"
#include "src/main/server_init.h"
#include "src/main/connection_loop.h"

#if defined(__GLIBC__) && !defined(__UCLIBC__)
#  include <malloc.h>
#endif

#ifndef SO_BINDTODEVICE
#  define SO_BINDTODEVICE IP_RECVIF
#endif

#define PAGE_SIZE 4096
#define THREAD_STACK_SIZE  9*PAGE_SIZE
#define TCP_FASTOPEN_QLEN  25

const char *tls_pem = DEFAULT_PEM_PATH;
int tls_ports[MAX_TLS_PORTS + 1] = {0}; /* one extra port for admin */
int num_tls_ports = 0;
int admin_port = 0;
struct Global *g;
cert_tlstor_t cert_tlstor;
pthread_t certgen_thread;

int main (int argc, char* argv[])
{
  char* version_string = NULL;
  time_t select_timeout = DEFAULT_TIMEOUT;
  time_t http_keepalive = DEFAULT_KEEPALIVE;
  char* ip_addr = DEFAULT_IP;
  int use_ip = 0;
  int error = 0;
  char* ports[MAX_PORTS + 1];
  int num_ports = 0;
  int i;
#ifdef IF_MODE
  char *ifname = "";
  int use_if = 0;
#endif
#ifdef DROP_ROOT
  char *user = DEFAULT_USER;
  struct passwd *pw = 0;
#endif
  char* stats_url = DEFAULT_STATS_URL;
  char* stats_text_url = DEFAULT_STATS_TEXT_URL;
  int do_204 = 1;
#ifndef TEST
  int do_foreground = 0;
#endif
  int do_redirect = 0;
  int do_benchmark = 0;
  char *bm_cert = NULL;
#ifdef DEBUG
  int warning_time = 0;
#endif
  int max_num_threads = DEFAULT_THREAD_MAX;
  int cert_cache_size = DEFAULT_CERT_CACHE_SIZE;

  /* Initialize OpenSSL */
#if !OPENSSL_API_1_1
  SSL_library_init();
  SSL_load_error_strings();
#else
  OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
#endif

  /* Optimize memory allocation for high connection counts */
#if defined(__GLIBC__) && !defined(__UCLIBC__)
  mallopt(M_ARENA_MAX, 2); /* Increased for better multi-threading */
  mallopt(M_MMAP_THRESHOLD, 64 * 1024); /* Use mmap for larger allocations */
#endif

  /* Set resource limits */
  struct rlimit l = {THREAD_STACK_SIZE, THREAD_STACK_SIZE * 2};
  if (setrlimit(RLIMIT_STACK, &l) == -1) {
    log_msg(LGG_ERR, "setrlimit STACK failed: %ld %ld errno:%d", 
            (long)l.rlim_cur, (long)l.rlim_max, errno);
  }

  /* Set file descriptor limits for high-scale deployment */
  l.rlim_cur = max_num_threads + 100;
  l.rlim_max = max_num_threads * 2 + 200;
  if (setrlimit(RLIMIT_NOFILE, &l) == -1) {
    log_msg(LGG_ERR, "setrlimit NOFILE failed: %ld %ld errno:%d", 
            (long)l.rlim_cur, (long)l.rlim_max, errno);
  }

  /* Command line arguments processing */
  for (i = 1; i < argc && error == 0; ++i) {
    if (argv[i][0] == '-') {
      switch (argv[i][1]) {
        case '2': do_204 = 0; continue;
        case 'B':
          if ((i + 1) == argc || argv[i + 1][0] == '-') {
            do_benchmark = 1; 
            bm_cert = NULL;
            continue;
          }
          break;
#ifndef TEST
        case 'f': do_foreground = 1; continue;
#endif
        case 'r': /* deprecated - ignoring */ continue;
        case 'R': do_redirect = 1; continue;
        case 'l':
          if ((i + 1) == argc || argv[i + 1][0] == '-') {
            log_set_verb(LGG_INFO);
            continue;
          }
          /* fall through */
      }
      
      if ((i + 1) < argc) {
        switch (argv[i++][1]) {
          case 'B':
            do_benchmark = 1;
            if (argv[i][0] == '-') {
              error = 1;
            } else {
              bm_cert = argv[i];
            }
            continue;
          case 'c':
            errno = 0;
            cert_cache_size = strtol(argv[i], NULL, 10);
            if (errno || cert_cache_size <= 0) {
              error = 1;
            }
            continue;
          case 'l':
            if ((logger_level)atoi(argv[i]) > LGG_DEBUG || atoi(argv[i]) < 0) {
              error = 1;
            } else {
              log_set_verb((logger_level)atoi(argv[i]));
            }
            continue;
#ifdef IF_MODE
          case 'n':
            ifname = argv[i];
            use_if = 1;
            continue;
#endif
          case 'o':
            log_msg(LGG_ERR, "'-o SELECT_TIMEOUT' is deprecated. will be removed in a future version");
            continue;
          case 'O':
            errno = 0;
            http_keepalive = strtol(argv[i], NULL, 10);
            if (errno || http_keepalive <= 0) {
              error = 1;
            }
            continue;
          case 'A':
            if (num_tls_ports < MAX_TLS_PORTS) {
              admin_port = atoi(argv[i]);
            } else {
              error = 1;
            }
            /* fall through to case 'k' */
          case 'k':
            if (num_tls_ports < MAX_TLS_PORTS) {
              tls_ports[num_tls_ports++] = atoi(argv[i]);
            } else {
              error = 1;
            }
            /* fall through to case 'p' */
          case 'p':
            if (num_ports < MAX_PORTS) {
              ports[num_ports++] = argv[i];
            } else {
              error = 1;
            }
            continue;
          case 's': stats_url = argv[i]; continue;
          case 't': stats_text_url = argv[i]; continue;
          case 'T':
            errno = 0;
            max_num_threads = strtol(argv[i], NULL, 10);
            if (errno || max_num_threads <= 0) {
              error = 1;
            }
            continue;
#ifdef DROP_ROOT
          case 'u': user = argv[i]; continue;
#endif
#ifdef DEBUG
          case 'w':
            errno = 0;
            warning_time = strtol(argv[i], NULL, 10);
            if (errno || warning_time <= 0) {
              error = 1;
            }
            continue;
#endif
          case 'z':
            tls_pem = argv[i];
            continue;
          default: error = 1; continue;
        }
      } else {
        error = 1;
      }
    } else if (use_ip == 0) {
      ip_addr = argv[i];
      use_ip = 1;
    } else {
      error = 1;
    }
  }

  if (error) {
    printf("pixelserv-tls %s (compiled: " __DATE__ " " __TIME__ FEATURE_FLAGS ")\n"
           "Usage: pixelserv-tls [OPTION]" "\n"
           "options:" "\n"
           "\t" "ip_addr/hostname\t(default: 0.0.0.0)" "\n"
           "\t" "-2\t\t\t(disable HTTP 204 reply to generate_204 URLs)" "\n"
           "\t" "-A  ADMIN_PORT\t\t(HTTPS only. Default is none)" "\n"
           "\t" "-B  [CERT_FILE]\t\t(Benchmark crypto and disk then quit)" "\n"
           "\t" "-c  CERT_CACHE_SIZE\t(default: %d)" "\n"
#ifndef TEST
           "\t" "-f\t\t\t(stay in foreground/don't daemonize)" "\n"
#endif
           "\t" "-k  HTTPS_PORT\t\t(default: " SECOND_PORT ")" "\n"
           "\t" "-l  LEVEL\t\t(0:critical 1:error<default> 2:warning 3:notice 4:info 5:debug)" "\n"
#ifdef IF_MODE
           "\t" "-n  IFACE\t\t(default: all interfaces)" "\n"
#endif
           "\t" "-o  SELECT_TIMEOUT\t(deprecated; will be removed in a future version)" "\n"
           "\t" "-O  KEEPALIVE_TIME\t(for HTTP/1.1 connections; default: %ds)" "\n"
           "\t" "-p  HTTP_PORT\t\t(default: " DEFAULT_PORT ")" "\n"
           "\t" "-R\t\t\t(enable redirect to encoded path in URLs)" "\n"
           "\t" "-s  STATS_HTML_URL\t(default: " DEFAULT_STATS_URL ")" "\n"
           "\t" "-t  STATS_TXT_URL\t(default: " DEFAULT_STATS_TEXT_URL ")" "\n"
           "\t" "-T  MAX_THREADS\t\t(default: %d)\n"
#ifdef DROP_ROOT
           "\t" "-u  USER\t\t(default: \"nobody\")" "\n"
#endif
#ifdef DEBUG
           "\t" "-w  warning_time\t(warn when elapsed connection time exceeds value in msec)" "\n"
#endif
           "\t" "-z  CERT_PATH\t\t(default: " DEFAULT_PEM_PATH ")" "\n"
           , VERSION, DEFAULT_CERT_CACHE_SIZE, DEFAULT_KEEPALIVE, DEFAULT_THREAD_MAX);
    exit(EXIT_FAILURE);
  }

#ifndef TEST
  if (!do_foreground && !do_benchmark && daemon(0, 0)) {
    log_msg(LGG_ERR, "failed to daemonize, exit: %m");
    exit(EXIT_FAILURE);
  }
#endif

  openlog("pixelserv-tls",
#ifdef DEBUG
    LOG_PERROR |
#endif
    LOG_PID, LOG_DAEMON);

  version_string = get_version(argc, argv);
  if (version_string) {
    if (!do_benchmark) log_msg(LGG_CRIT, "%s", version_string);
    free(version_string);
  } else {
    exit(EXIT_FAILURE);
  }

  /* Initialize server */
  if (initialize_server(tls_pem, cert_cache_size, max_num_threads, do_benchmark, &cert_tlstor, bm_cert, &certgen_thread) != 0) {
    exit(EXIT_FAILURE);
  }

  if (do_benchmark) {
    goto quit_main;
  }

  /* Set up signal handling */
  setup_signal_handlers();

  /* Set up sockets and run main loop */
  struct Global _g = {
        argc,
        argv,
        select_timeout,
        http_keepalive,
        0, /* pipefd will be set in run_connection_loop */
        stats_url,
        stats_text_url,
        do_204,
        do_redirect,
#ifdef DEBUG
        warning_time,
#endif
        tls_pem,
  };
  g = &_g;

#ifdef DROP_ROOT
  pw = getpwnam(user);
  if (!pw) {
    log_msg(LGG_ERR, "Unknown user: %s", user);
    exit(EXIT_FAILURE);
  }
  if (chown(pixel_cert_pipe, pw->pw_uid, pw->pw_gid) < 0) {
    log_msg(LGG_CRIT, "chown failed to set owner of %s to %s", pixel_cert_pipe, user);
    exit(EXIT_FAILURE);
  }
#endif

#ifdef DROP_ROOT
  if (pw && setuid(pw->pw_uid)) {
    log_msg(LGG_WARNING, "setuid %d: %m", pw->pw_uid);
  }
#endif

  run_connection_loop(ip_addr, use_ip, ports, num_ports, max_num_threads, &_g
#ifdef IF_MODE
    , ifname, use_if
#endif
  );

  pthread_cancel(certgen_thread);
  pthread_join(certgen_thread, NULL);

quit_main:
  cleanup_server();
  
  return (EXIT_SUCCESS);
}
/*
* connection_loop.c
* Location: ./src/main/connection_loop.c
* 
* Main connection loop with select() and accept() for pixelserv-tls
*/

#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>

#ifdef linux
#include <linux/version.h>
#endif

#include <openssl/ssl.h>
#include <openssl/err.h>

#include "../ssl/ssl_modules.h"
#include "../sock/socket_handler.h"
#include "../log/logger.h"
#include "../util/util.h"
#include "connection_loop.h"

#ifndef SO_BINDTODEVICE
#  define SO_BINDTODEVICE IP_RECVIF
#endif

#define PAGE_SIZE 4096
#define THREAD_STACK_SIZE  9*PAGE_SIZE
#define TCP_FASTOPEN_QLEN  25

extern const char *tls_pem;
extern int tls_ports[];
extern int num_tls_ports;
extern int admin_port;
extern struct Global *g;
extern cert_tlstor_t cert_tlstor;

void run_connection_loop(char *ip_addr, int use_ip, char *ports[], int num_ports, int max_num_threads, 
                        struct Global *global_config
#ifdef IF_MODE
  , char *ifname, int use_if
#endif
)
{
  int sockfd = 0;
  int new_fd = 0;
  struct sockaddr_storage their_addr;
  socklen_t sin_size;
  int rv = 0;
  struct addrinfo hints, *servinfo = NULL;
  int pipefd[2];
  response_struct pipedata = { 0 };
  char *port = NULL;
  fd_set readfds;
  fd_set selectfds;
  int sockfds[MAX_PORTS] = {0};
  int select_rv = 0;
  int nfds = 0;
  int i;

  /* Set default ports if none specified */
  if ((!admin_port && !num_ports) || (admin_port && num_ports == 1)) {
    tls_ports[num_tls_ports++] = atoi(SECOND_PORT);
    ports[num_ports++] = SECOND_PORT;
    ports[num_ports++] = DEFAULT_PORT;
  } else if ((!admin_port && !num_tls_ports) || (admin_port && num_tls_ports == 1)) {
    tls_ports[num_tls_ports++] = atoi(SECOND_PORT);
    ports[num_ports++] = SECOND_PORT;
  } else if (num_ports == num_tls_ports) {
    ports[num_ports++] = DEFAULT_PORT;
  }

  /* Set up address hints */
  memset(&hints, 0, sizeof hints);
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  if (!use_ip) {
    hints.ai_flags = AI_PASSIVE;
  }

  /* Initialize socket monitoring */
  FD_ZERO(&readfds);
  
  for (i = 0; i < num_ports; i++) {
    port = ports[i];

    rv = getaddrinfo(use_ip ? ip_addr : NULL, port, &hints, &servinfo);
    if (rv) {
      log_msg(LGG_ERR, "getaddrinfo: %s", gai_strerror(rv));
      exit(EXIT_FAILURE);
    }

    sockfd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
    if (sockfd < 1) {
      log_msg(LGG_CRIT, "socket() failed: %m");
      freeaddrinfo(servinfo);
      exit(EXIT_FAILURE);
    }

    /* Set socket options */
    int off = 0;
    if (servinfo->ai_family == AF_INET6 && 
        setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &off, sizeof(off)) < 0) {
      log_msg(LGG_WARNING, "Failed to set IPV6_V6ONLY: %m");
    }

    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof(int)) < 0 ||
        setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &(int){ 1 }, sizeof(int)) < 0) {
      log_msg(LGG_ERR, "Failed to set socket options: %m");
      close(sockfd);
      freeaddrinfo(servinfo);
      exit(EXIT_FAILURE);
    }

#ifdef IF_MODE
    if (use_if && setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE, ifname, strlen(ifname)) < 0) {
      log_msg(LGG_ERR, "Failed to bind to interface %s: %m", ifname);
      close(sockfd);
      freeaddrinfo(servinfo);
      exit(EXIT_FAILURE);
    }
#endif

#ifdef linux
#  if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0) || defined(TCP_FASTOPEN)
    if (setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN, &(int){ TCP_FASTOPEN_QLEN }, sizeof(int)) < 0) {
      log_msg(LGG_DEBUG, "TCP_FASTOPEN not supported: %m");
    }
#  endif
#endif

    if (bind(sockfd, servinfo->ai_addr, servinfo->ai_addrlen) < 0 ||
        listen(sockfd, BACKLOG) < 0 ||
        fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL) | O_NONBLOCK) < 0) {
#ifdef IF_MODE
      log_msg(LGG_CRIT, "Abort: %m - %s:%s:%s", ifname, ip_addr, port);
#else
      log_msg(LGG_CRIT, "Abort: %m - %s:%s", ip_addr, port);
#endif
      close(sockfd);
      freeaddrinfo(servinfo);
      exit(EXIT_FAILURE);
    }

    sockfds[i] = sockfd;
    FD_SET(sockfd, &readfds);
    if (sockfd > nfds) {
      nfds = sockfd;
    }

    freeaddrinfo(servinfo);
    servinfo = NULL;

#ifdef IF_MODE
    log_msg(LGG_CRIT, "Listening on %s:%s:%s", ifname, ip_addr, port);
#else
    log_msg(LGG_CRIT, "Listening on %s:%s", ip_addr, port);
#endif
  }

  /* Set up inter-process communication pipe */
  if (pipe(pipefd) == -1) {
    log_msg(LGG_ERR, "pipe() error: %m");
    exit(EXIT_FAILURE);
  }
  
  if (fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) | O_NONBLOCK) == -1) {
    log_msg(LGG_ERR, "fcntl() error setting O_NONBLOCK on read end of pipe: %m");
    exit(EXIT_FAILURE);
  }

  FD_SET(pipefd[0], &readfds);
  if (pipefd[0] > nfds) {
    nfds = pipefd[0];
  }

  ++nfds;
  sin_size = sizeof their_addr;

  /* Set global pointer */
  g = global_config;

  /* Main accept loop */
  while(1) {
    if (select_rv <= 0) {
      selectfds = readfds;
      select_rv = TEMP_FAILURE_RETRY(select(nfds, &selectfds, NULL, NULL, NULL));
      if (select_rv < 0) {
        log_msg(LGG_ERR, "main select() error: %m");
        exit(EXIT_FAILURE);
      } else if (select_rv == 0) {
        log_msg(LGG_WARNING, "main select() returned zero (timeout?)");
        continue;
      }
    }

    /* Find first ready socket descriptor */
    for (i = 0, sockfd = 0; i < num_ports; i++) {
      if (FD_ISSET(sockfds[i], &selectfds)) {
        sockfd = sockfds[i];
        --select_rv;
        FD_CLR(sockfd, &selectfds);
        break;
      }
    }

    /* Check for pipe I/O */
    if (!sockfd && FD_ISSET(pipefd[0], &selectfds)) {
      rv = read(pipefd[0], &pipedata, sizeof(pipedata));
      if (rv < 0) {
        log_msg(LGG_WARNING, "error reading from pipe: %m");
      } else if (rv == 0) {
        log_msg(LGG_WARNING, "pipe read() returned zero");
      } else if (rv != sizeof(pipedata)) {
        log_msg(LGG_WARNING, "pipe read() got %d bytes, but %u bytes were expected - discarding",
          rv, (unsigned int)sizeof(pipedata));
      } else {
        /* Process response statistics */
        switch (pipedata.status) {
          case FAIL_GENERAL:   ++ers; break;
          case FAIL_TIMEOUT:   ++tmo; break;
          case FAIL_CLOSED:    ++cls; break;
          case FAIL_REPLY:     ++cly; break;
          case SEND_GIF:       ++gif; break;
          case SEND_TXT:       ++txt; break;
          case SEND_JPG:       ++jpg; break;
          case SEND_PNG:       ++png; break;
          case SEND_SWF:       ++swf; break;
          case SEND_ICO:       ++ico; break;
          case SEND_BAD:       ++bad; break;
          case SEND_STATS:     ++sta; break;
          case SEND_STATSTEXT: ++stt; break;
          case SEND_204:       ++noc; break;
          case SEND_REDIRECT:  ++rdr; break;
          case SEND_NO_EXT:    ++nfe; break;
          case SEND_UNK_EXT:   ++ufe; break;
          case SEND_NO_URL:    ++nou; break;
          case SEND_BAD_PATH:  ++pth; break;
          case SEND_POST:      ++pst; break;
          case SEND_HEAD:      ++hed; break;
          case SEND_OPTIONS:   ++opt; break;
          case ACTION_LOG_VERB:  log_set_verb(pipedata.verb); break;
          case ACTION_DEC_KCC: --kcc; break;
          default:
            log_msg(LGG_DEBUG, "conn_handler reported unknown response value: %d", pipedata.status);
        }
        
        switch (pipedata.ssl) {
          case SSL_HIT_RTT0:   ++zrt; /* fall through */
          case SSL_HIT:        ++slh; break;
          case SSL_HIT_CLS:    ++slc; break;
          default:             ;
        }
        
        if (pipedata.ssl == SSL_HIT ||
            pipedata.ssl == SSL_HIT_RTT0 ||
            pipedata.ssl == SSL_HIT_CLS) {
          switch (pipedata.ssl_ver) {
#ifdef TLS1_3_VERSION
            case TLS1_3_VERSION: ++v13; break;
#endif
            case TLS1_2_VERSION: ++v12; break;
            case TLS1_VERSION:   ++v10; break;
            default:             ;
          }
        }
        
        if (pipedata.status < ACTION_LOG_VERB) {
          count++;
          if (pipedata.rx_total > 0) {
            static float favg = 0.0;
            static int favg_cnt = 0;
            favg = ema(favg, pipedata.rx_total, &favg_cnt);
            avg = favg + 0.5;
            if (pipedata.rx_total > rmx)
              rmx = pipedata.rx_total;
          }

          if (pipedata.status != FAIL_TIMEOUT && pipedata.rx_total > 0) {
            static float ftav = 0.0;
            static int ftav_cnt = 0;
            ftav = ema(ftav, pipedata.run_time, &ftav_cnt);
            tav = ftav + 0.5;
            if (pipedata.run_time + 0.5 > tmx)
              tmx = (pipedata.run_time + 0.5);
          }
        } else if (pipedata.status == ACTION_DEC_KCC) {
          static int kvg_cnt = 0;
          kvg = ema(kvg, pipedata.krq, &kvg_cnt);
          if (pipedata.krq > krq)
            krq = pipedata.krq;
        }
      }
      --select_rv;
      continue;
    }

    if (!sockfd) {
      log_msg(LGG_WARNING, "select() returned a value of %d but no file descriptors of interest are ready for read", select_rv);
      select_rv = 0;
      continue;
    }

    struct timespec init_time = {0, 0};
    get_time(&init_time);
    new_fd = accept(sockfd, (struct sockaddr *) &their_addr, &sin_size);
    if (new_fd < 0) {
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            cls++;
        }
        log_msg(LGG_DEBUG, "accept: %m");
        continue;
    }
    
    if (kcc >= max_num_threads) {
        clt++;
        shutdown(new_fd, SHUT_RDWR);
        close(new_fd);
        continue;
    }

    conn_tlstor_struct *conn_tlstor = conn_stor_acquire();
    if (conn_tlstor == NULL) {
      log_msg(LGG_WARNING, "%s conn_tlstor alloc failed", __FUNCTION__);
      shutdown(new_fd, SHUT_RDWR);
      close(new_fd);
      continue;
    }

    /* Set fd to blocking explicitly */
    int flags;
    if ((flags = fcntl(new_fd, F_GETFL, 0)) < 0 || 
        fcntl(new_fd, F_SETFL, flags & (~O_NONBLOCK)) < 0) {
        log_msg(LGG_WARNING, "%s fail to set new_fd to blocking", __FUNCTION__);
    }

    /* Set socket options */
    if (setsockopt(new_fd, IPPROTO_TCP, TCP_NODELAY, &(int){ 1 }, sizeof(int)) ||
        setsockopt(new_fd, SOL_SOCKET, SO_RCVTIMEO, 
                  (char*)&(struct timeval){ 0, 150000 }, sizeof(struct timeval))) {
        log_msg(LGG_WARNING, "%s setsockopt() failed on new_fd", __FUNCTION__);
    }

    conn_tlstor->new_fd = new_fd;
    conn_tlstor->ssl = NULL;
    conn_tlstor->allow_admin = (!admin_port) ? 1 : 0;
    
    char *server_ip = conn_tlstor->tlsext_cb_arg->server_ip;
    int ssl_port = is_ssl_conn(new_fd, server_ip, INET6_ADDRSTRLEN, tls_ports, num_tls_ports);
    
    if (ssl_port) {
      int ssl_attempt = 5;
      int sslerr = SSL_ERROR_NONE;
      char ip_buf[NI_MAXHOST], port_buf[NI_MAXSERV];

      tlsext_cb_arg_struct *t = conn_tlstor->tlsext_cb_arg;
      SSL *ssl = NULL;
      SSL_CTX *sslctx = create_default_sslctx(tls_pem);
      //t->tls_pem = tls_pem;
      t->tls_pem = (char*)tls_pem;
      t->cachain = cert_tlstor.cachain;
      t->status = SSL_UNKNOWN;
      t->sslctx_idx = -1;

      ssl = SSL_new(sslctx);
      if (!ssl) {
        log_msg(LGG_ERR, "SSL_new() failed");
        goto cleanup_connection;
      }
      
      SSL_set_fd(ssl, new_fd);
      conn_tlstor->ssl = ssl;
      
      if (ssl_port == admin_port)
        conn_tlstor->allow_admin = 1;

#ifdef TLS1_3_VERSION
      SSL_CTX_set_client_hello_cb(sslctx, tls_clienthello_cb, t);
      conn_tlstor->early_data = read_tls_early_data(ssl, &sslerr);
      if (conn_tlstor->early_data) {
        conn_tlstor->init_time = elapsed_time_msec(init_time);
        goto start_service_thread;
      }

      if (sslerr != SSL_ERROR_NONE)
        goto skip_ssl_accept;
#else
      SSL_CTX_set_tlsext_servername_arg(sslctx, t);
      conn_tlstor->early_data = NULL;
#endif
      conn_tlstor->init_time = elapsed_time_msec(init_time);

redo_ssl_accept:
      errno = 0;
      ERR_clear_error();
      int sslret = SSL_accept(ssl);
      if (sslret == 1)
        goto start_service_thread;
      sslerr = SSL_get_error(ssl, sslret);

#ifdef TLS1_3_VERSION
skip_ssl_accept:
#endif

      if (log_get_verb() >= LGG_WARNING && 
          getnameinfo((struct sockaddr *)&their_addr, sin_size,
                     ip_buf, sizeof ip_buf, port_buf, sizeof port_buf, 
                     NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
        ip_buf[0] = '\0';
        port_buf[0] = '\0';
        log_msg(LGG_ERR, "failed to get client_ip: %s", strerror(errno));
      }

      switch(sslerr) {
        case SSL_ERROR_WANT_READ:
          ssl_attempt--;
          if (ssl_attempt > 0) {
            get_time(&init_time);
            goto redo_ssl_accept;
          }
          log_msg(LGG_WARNING, "handshake failed: reached max retries. client %s:%s server %s",
              ip_buf, port_buf, t->servername);
          break;
        case SSL_ERROR_SSL:
          switch(ERR_GET_REASON(ERR_peek_last_error())) {
              case SSL_R_SSLV3_ALERT_BAD_CERTIFICATE:
                  ucb++;
                  log_msg(LGG_WARNING, "handshake failed: bad cert. client %s:%s server %s",
                      ip_buf, port_buf, t->servername);
                  break;
              case SSL_R_TLSV1_ALERT_UNKNOWN_CA:
                  uca++;
                  log_msg(LGG_WARNING, "handshake failed: unknown CA. client %s:%s server %s",
                      ip_buf, port_buf, t->servername);
                  break;
              case SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN:
                  uce++;
                  log_msg(LGG_WARNING, "handshake failed: unknown cert. client %s:%s server %s",
                      ip_buf, port_buf, t->servername);
                  break;
              case SSL_R_PARSE_TLSEXT:
                  if (t->status == SSL_MISS)
                    break;
                  /* fall through */
              default:
                  log_msg(LGG_WARNING, "handshake failed: client %s:%s server %s. Lib(%d) Func(%d) Reason(%d)",
                      ip_buf, port_buf, t->servername,
                      ERR_GET_LIB(ERR_peek_last_error()), 
                      0,
                      ERR_GET_REASON(ERR_peek_last_error()));
          }
          break;
        case SSL_ERROR_SYSCALL:
            if (t->status == SSL_MISS)
              break;

            if (errno == 0 || errno == 104) {
              char m[2];
              int rv = recv(new_fd, m, 2, MSG_PEEK);
              if (rv == 0) {
                ush++;
                log_msg(LGG_WARNING, "handshake failed: shutdown after ServerHello. client %s:%s server %s",
                  ip_buf, port_buf, t->servername);
                break;
              }
            }
            log_msg(LGG_WARNING, "handshake failed: socket I/O error. client %s:%s server %s. errno: %d",
                ip_buf, port_buf, t->servername, errno);
            break;
        default:
          log_msg(LGG_WARNING, "handshake failed: unknown error %d. client %s:%s server %s",
              sslerr, ip_buf, port_buf, t->servername);
      }
      
      count++;
      switch(t->status) {
        case SSL_ERR:        ++sle; break;
        case SSL_MISS:       ++slm; break;
        case SSL_HIT:
        case SSL_UNKNOWN:    ++slu; break;
        default:             ;
      }

cleanup_connection:
      if (ssl) {
        SSL_set_shutdown(ssl, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
        SSL_free(ssl);
      }
      shutdown(new_fd, SHUT_RDWR);
      close(new_fd);
      conn_stor_relinq(conn_tlstor);
      continue;
    }

start_service_thread:
    conn_tlstor->init_time += elapsed_time_msec(init_time);
    pthread_t conn_thread;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_attr_setstacksize(&attr, THREAD_STACK_SIZE);
    
    int err = pthread_create(&conn_thread, &attr, conn_handler, (void*)conn_tlstor);
    if (err) {
      log_msg(LGG_ERR, "Failed to create conn_handler thread. err: %d", err);
      if (conn_tlstor->ssl) {
        SSL_set_shutdown(conn_tlstor->ssl, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
        SSL_free(conn_tlstor->ssl);
      }
      shutdown(new_fd, SHUT_RDWR);
      close(new_fd);
      conn_stor_relinq(conn_tlstor);
      continue;
    }
    pthread_attr_destroy(&attr);

    if (++kcc > kmx)
      kmx = kcc;
  }

  /* Close pipe file descriptors */
  if (pipefd[0] >= 0) close(pipefd[0]);
  if (pipefd[1] >= 0) close(pipefd[1]);
  
  /* Close listening sockets */
  for (i = 0; i < num_ports; i++) {
    if (sockfds[i] >= 0) close(sockfds[i]);
  }
}
/*
* server_init.c
* Location: ./src/main/server_init.c
* 
* Server initialization and SSL setup for pixelserv-tls
*/

#include <pthread.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#ifdef DROP_ROOT
#include <pwd.h>
#endif

#include <openssl/ssl.h>

#include "../ssl/ssl_modules.h"
#include "../sock/socket_handler.h"
#include "../log/logger.h"
#include "../util/util.h"
#include "server_init.h"

#define PAGE_SIZE 4096
#define THREAD_STACK_SIZE  9*PAGE_SIZE

extern char pixel_cert_pipe[];
extern cert_tlstor_t cert_tlstor;

int initialize_server(const char *tls_pem, int cert_cache_size, int max_num_threads, 
                     int do_benchmark, cert_tlstor_t *cert_tlstor, char *bm_cert, 
                     pthread_t *certgen_thread)
{
  /* Generate random pipe path */
  generate_random_pipe_path(pixel_cert_pipe, sizeof(pixel_cert_pipe));
  if (mkfifo(pixel_cert_pipe, 0600) < 0 && errno != EEXIST) {
    log_msg(LGG_ERR, "Failed to create cert pipe: %s", strerror(errno));
    return -1;
  }

  /* Initialize SSL and certificate handling */
  ssl_init_locks();
  cert_tlstor_init(tls_pem, cert_tlstor);
  sslctx_tbl_init(cert_cache_size);
  conn_stor_init(max_num_threads);

  /* Load existing certificates */
  sslctx_tbl_load(tls_pem, cert_tlstor->cachain);
  SSL_CTX *sslctx = create_default_sslctx(tls_pem);
  if (!sslctx) {
    log_msg(LGG_ERR, "Failed to create default SSL context");
    return -1;
  }

  if (do_benchmark) {
    run_benchmark(cert_tlstor, bm_cert);
    return 0;
  } else {
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, THREAD_STACK_SIZE);
    if (pthread_create(certgen_thread, &attr, cert_generator, (void*)cert_tlstor) != 0) {
      log_msg(LGG_ERR, "Failed to create certificate generator thread");
      pthread_attr_destroy(&attr);
      return -1;
    }
    pthread_attr_destroy(&attr);
  }

  return 0;
}

void cleanup_server(void)
{
  conn_stor_flush();
  sslctx_tbl_cleanup();
  cert_tlstor_cleanup(&cert_tlstor);
  ssl_free_locks();
}
/*
 * src/main/signal_handler.c
 * Location: ./src/main/signal_handler.c
 * 
 * Signal handling functionality for pixelserv-tls
*/

#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/wait.h>

#if defined(__GLIBC__) && !defined(__UCLIBC__)
#  include <malloc.h>
#endif

#include "../ssl/ssl_modules.h"
#include "../sock/socket_handler.h"
#include "../log/logger.h"
#include "../util/util.h"
#include "signal_handler.h"

extern char pixel_cert_pipe[];
extern const char *tls_pem;

/* Signal handler with improved cleanup */
void signal_handler(int sig)
{
  if (sig != SIGTERM
   && sig != SIGUSR1
#ifdef DEBUG
   && sig != SIGUSR2
#endif
  ) {
    log_msg(LGG_WARNING, "Ignoring unsupported signal number: %d", sig);
    return;
  }

#ifdef DEBUG
  if (sig == SIGUSR2) {
    log_msg(LGG_INFO, "Main process caught signal %d file %s", sig, __FILE__);
  } else {
#endif
    if (sig == SIGTERM) {
      signal(SIGTERM, SIG_IGN);
    }

    /* Cleanup connection storage */
    conn_stor_flush();
    
    /* Remove certificate pipe */
    if (unlink(pixel_cert_pipe) == 0) {
        log_msg(LGG_NOTICE, "Removed cert pipe: %s", pixel_cert_pipe);
    } else {
        log_msg(LGG_WARNING, "Could not remove cert pipe %s: %s", pixel_cert_pipe, strerror(errno));
    }

#if defined(__GLIBC__) && !defined(__UCLIBC__)
    malloc_trim(0);
#endif

    /* Log final statistics */
    char* stats_string = get_stats(0, 0);
    if (stats_string) {
        log_msg(LGG_CRIT, "%s", stats_string);
        free(stats_string);
    }

    /* Save SSL context table */
    sslctx_tbl_save(tls_pem);

    if (sig == SIGTERM) {
      log_msg(LGG_NOTICE, "exit on SIGTERM");
      exit(EXIT_SUCCESS);
    }
#ifdef DEBUG
  }
#endif
}

void setup_signal_handlers(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = signal_handler;
  sigemptyset(&sa.sa_mask);
  
  if (sigaction(SIGTERM, &sa, NULL)) {
    log_msg(LGG_ERR, "SIGTERM %m");
    exit(EXIT_FAILURE);
  }
  
  if (signal(SIGCHLD, SIG_IGN) == SIG_ERR) {
    log_msg(LGG_WARNING, "SIGCHLD %m");
  }
  
  sa.sa_flags = SA_RESTART;
  if (sigaction(SIGUSR1, &sa, NULL)) {
    log_msg(LGG_ERR, "SIGUSR1 %m");
    exit(EXIT_FAILURE);
  }

#if defined(__GLIBC__) && defined(BACKTRACE)
  sa.sa_handler = print_trace;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGABRT, &sa, NULL);
  sigaction(SIGILL, &sa, NULL);
  sigaction(SIGFPE, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
#endif

#ifdef DEBUG
  sa.sa_flags = SA_RESTART;
  if (sigaction(SIGUSR2, &sa, NULL)) {
    log_msg(LGG_ERR, "SIGUSR2 %m");
    exit(EXIT_FAILURE);
  }
#endif

  signal(SIGPIPE, SIG_IGN);
}
/*
* connection_loop.h
* Location: ./src/main/connection_loop.h
* 
* Header file for main connection loop functionality
*/

#ifndef CONNECTION_LOOP_H
#define CONNECTION_LOOP_H

void run_connection_loop(char *ip_addr, int use_ip, char *ports[], int num_ports, int max_num_threads,
                        struct Global *global_config
#ifdef IF_MODE
  , char *ifname, int use_if
#endif
);

#endif
/*
 * src/main/server_init.h
 * Location: ./src/main/server_init.h
 * 
 * Header file for server initialization functionality
*/

#ifndef SERVER_INIT_H
#define SERVER_INIT_H

#include <pthread.h>
#include "../ssl/ssl_modules.h"

int initialize_server(const char *tls_pem, int cert_cache_size, int max_num_threads, 
                     int do_benchmark, cert_tlstor_t *cert_tlstor, char *bm_cert, 
                     pthread_t *certgen_thread);
void cleanup_server(void);

#endif
/*
 * src/main/signal_handler.h
 * Location: ./src/main/signal_handler.h
 * 
 * Header file for signal handling functionality
*/

#ifndef SIGNAL_HANDLER_H
#define SIGNAL_HANDLER_H

void signal_handler(int sig);
void setup_signal_handlers(void);

#endif
/*
 * src/comm/connection_handler.c - Connection Lifecycle Management
 * 
 * Hauptfunktion conn_handler() und Connection Event Loop
*/

#include "../util/util.h" // _GNU_SOURCE

#include <pthread.h>
#include <poll.h>
#include <sys/stat.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#include <signal.h>

#include "../comm/connection_handler.h"
#include "../sock/socket_io.h"
#include "../http/http_responses.h"
#include "../http/http_utils.h"
#include "../comm/request_processor.h"
#include "../log/logger.h"
#include "../addon/favicon.h"

#ifndef FAVICON_H
#define FAVICON_H
unsigned char  favicon_ico[]   = { /* â€¦ */ };
unsigned int   favicon_ico_len = /* â€¦ */;
#endif /* FAVICON_H */

extern struct Global *g;
static struct timespec start_time = {0, 0};

void* conn_handler( void *ptr )
{
  // High-Load Fix: Lokale Kopie der globalen Config fÃ¼r Thread-Safety
  if (!g) {
    log_msg(LGG_ERR, "Global state pointer is NULL");
    return NULL;
  }
  
  // Atomarer Snapshot der globalen Konfiguration
  struct {
    int argc;
    char **argv;
    int new_fd;
    int pipefd;
    const char *stats_url;
    const char *stats_text_url;
    const char *pem_dir;
    int do_204;
    int do_redirect;
    int select_timeout;
    int http_keepalive;
#ifdef DEBUG
    int warning_time;
#endif
  } config;
  
  // Schneller Snapshot - minimiert Zeit in kritischer Sektion
  config.argc = GLOBAL(g, argc);
  config.argv = GLOBAL(g, argv);
  config.new_fd = CONN_TLSTOR(ptr, new_fd);
  config.pipefd = GLOBAL(g, pipefd);
  config.stats_url = GLOBAL(g, stats_url);
  config.stats_text_url = GLOBAL(g, stats_text_url);
  config.pem_dir = GLOBAL(g, pem_dir);
  config.do_204 = GLOBAL(g, do_204);
  config.do_redirect = GLOBAL(g, do_redirect);
  config.select_timeout = GLOBAL(g, select_timeout);
  config.http_keepalive = GLOBAL(g, http_keepalive);
#ifdef DEBUG
  config.warning_time = GLOBAL(g, warning_time);
#endif

  // NOTES:
  // - from here on, all exit points should be counted or at least logged
  // - exit() should not be called from the child process
  response_struct pipedata = {0};
  struct timeval timeout = {config.select_timeout, 0};
  int rv = 0;
  char *buf = NULL, *bufptr = NULL;
  char* aspbuf = NULL;
  char* response;  // Fix: nicht const, da process_get_request char** erwartet
  int rsize;
  int num_req = 0; // number of requests processed by this thread
  char *req_url = NULL;
  unsigned int req_len = 0;
  #define HOST_LEN_MAX 80
  char host[HOST_LEN_MAX + 1];
  char *post_buf = NULL;
  size_t post_buf_len = 0;
  unsigned int total_bytes = 0; /* number of bytes received by this thread */
  #define CORS_ORIGIN_LEN_MAX 256
  char *cors_origin = NULL;
  char client_ip[INET6_ADDRSTRLEN]= {'\0'}; //yipst
  char *method = NULL;

#ifdef DEBUG
  int do_warning = (config.warning_time > 0);
  // set up signal handling
  {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = child_signal_handler;
    sigemptyset(&sa.sa_mask);
    // set signal handler for termination
    if (sigaction(SIGTERM, &sa, NULL)) {
      log_msg(LGG_DEBUG, "sigaction(SIGTERM) reported error: %m");
    }
    // set signal handler for info
    sa.sa_flags = SA_RESTART; // prevent EINTR from interrupted library calls
    if (sigaction(SIGUSR2, &sa, NULL)) {
      log_msg(LGG_DEBUG, "sigaction(SIGUSR2) reported error: %m");
    }
  }
  printf("%s: tid = %d\n", __FUNCTION__, (int)pthread_self());
#endif

  // the socket is connected, but we need to perform a check for incoming data
  // since we're using blocking checks, we first want to set a timeout
  if (setsockopt(config.new_fd, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(struct timeval)) < 0)
    log_msg(LGG_DEBUG, "setsockopt(timeout) reported error: %m");

  pipedata.ssl_ver = (CONN_TLSTOR(ptr, ssl)) ? SSL_version(CONN_TLSTOR(ptr, ssl)) : 0;
  pipedata.run_time = CONN_TLSTOR(ptr, init_time);
  get_client_ip(config.new_fd, client_ip, sizeof client_ip, NULL, 0);
  
  // Logging fÃ¼r get_client_ip Fehler hier
  if (client_ip[0] == '\0') {
    log_msg(LGG_ERR, "getnameinfo failed to get client_ip");
  }

  /* main event loop */
  while(1) {

    /* wait for requests if no early data on initial connection */
    if (!CONN_TLSTOR(ptr, early_data)) {

      struct pollfd pfd = { config.new_fd, POLLIN, POLLIN };
      int selrv = poll(&pfd, 1, 1000 * config.http_keepalive);
      TESTPRINT("socket:%d selrv:%d errno:%d\n", config.new_fd, selrv, errno);

      /* selrv -1: error; selrv 0: no data before timed out;
         selrv > 0 and peek_socket <= 0: client disconnects */

      int peekrv = peek_socket(config.new_fd, CONN_TLSTOR(ptr, ssl));
      if (total_bytes == 0 && peekrv <= 0) {

        /* no data in the whole session. counted as one 'cls'
           run_time is ignorable */
        if (CONN_TLSTOR(ptr, ssl))
          pipedata.ssl = SSL_HIT_CLS;
        pipedata.status = FAIL_CLOSED;
        pipedata.rx_total = 0;
        write_pipe(config.pipefd, &pipedata);
        num_req++;
        break; /* done with this thread */
      }
      if (selrv <= 0 || peekrv <=0 )
        break; /* done with this thread */
    }

    get_time(&start_time);

    int log_verbose = log_get_verb();
    response = (char*)httpnulltext;  // Fix: Cast um const qualifier zu entfernen
    rsize = 0;
    post_buf_len = 0;

    errno = 0;
    rv = read_socket(config.new_fd, &buf, CONN_TLSTOR(ptr, ssl), CONN_TLSTOR(ptr, early_data));
    if (rv <= 0) {
      if (errno == ECONNRESET || rv == 0) {
        log_msg(LGG_DEBUG, "recv() ECONNRESET: %m");
        pipedata.status = FAIL_CLOSED;
      } else if (errno == EAGAIN || errno == EWOULDBLOCK) {
        log_msg(LGG_DEBUG, "recv() EAGAIN: %m");
        pipedata.status = FAIL_TIMEOUT;
      } else {
        log_msg(LGG_DEBUG, "recv() error: %m");
        pipedata.status = FAIL_GENERAL;
      }
    } else {                    // got some data
      if (CONN_TLSTOR(ptr, ssl)) {
        pipedata.ssl = CONN_TLSTOR(ptr, early_data) ? SSL_HIT_RTT0 : SSL_HIT;
      } else {
        pipedata.ssl = SSL_NOT_TLS;
      }

      TIME_CHECK("initial recv()");
      buf[rv] = '\0';
      TESTPRINT("\nreceived %d bytes\n'%s'\n", rv, buf);
      pipedata.rx_total = rv;
      total_bytes += rv;

#ifdef HEX_DUMP
      hex_dump(buf, rv);
#endif
      
      // [REST DER FUNKTION WIRD IM NÃ„CHSTEN UPDATE FORTGESETZT]
      
      // body Variable entfernt - wird nicht verwendet
      char *req = strtok_r(buf, "\r\n", &bufptr);
      if (log_verbose >= LGG_INFO) {
        if (req) {
          host[0] = '\0';
          if (strlen(req) > req_len) {
            req_len = strlen(req);
            // Memory-Leak Fix: Null-Check fÃ¼r realloc
            char *new_req_url = realloc(req_url, req_len + 1);
            if (new_req_url) {
              req_url = new_req_url;
              req_url[0] = '\0';
            } else {
              log_msg(LGG_ERR, "Failed to realloc req_url");
              // Weiter mit altem req_url falls vorhanden
              if (req_url) req_url[0] = '\0';
            }
          }
          if (req_url) {
            strcpy(req_url, req);
          }
          
          /* locate and copy Host */
          char *tmph = strstr_first(bufptr, "Host: "); // e.g. "Host: abc.com"
          if (tmph) {
            // Fix: Sichere strncpy mit garantierter Null-Terminierung
            strncpy(host, tmph + 6 /* strlen("Host: ") */, HOST_LEN_MAX);
            host[HOST_LEN_MAX] = '\0';
            strtok(host, "\r\n");
            TESTPRINT("socket:%d host:%s\n", config.new_fd, host);
          }
        }
      }

      /* CORS */
      char *orig_hdr;
      orig_hdr = strstr_first(bufptr, "Origin: ");
      if (orig_hdr) {
        // Memory-Leak Fix: Null-Check fÃ¼r realloc
        char *new_cors_origin = realloc(cors_origin, CORS_ORIGIN_LEN_MAX);
        if (new_cors_origin) {
          cors_origin = new_cors_origin;
          strncpy(cors_origin, orig_hdr + 8, CORS_ORIGIN_LEN_MAX - 1);
          cors_origin[CORS_ORIGIN_LEN_MAX - 1] = '\0';
          strtok(cors_origin, "\r\n");
          if (strncmp(cors_origin, "null", 4) == 0) { /* some web developers are just ... */
              cors_origin[0] = '*';
              cors_origin[1] = '\0';
          }
        } else {
          log_msg(LGG_ERR, "Failed to realloc cors_origin");
        }
      }

      char *reqptr;
      method = req ? strtok_r(req, " ", &reqptr) : NULL;

      if (method == NULL) {
        log_msg(LGG_DEBUG, "client did not specify method");
      } else {
        TESTPRINT("method: '%s'\n", method);
        if (!strcmp(method, "OPTIONS")) {
          pipedata.status = SEND_OPTIONS;
          rsize = asprintf(&aspbuf, "%s", httpoptions);
          response = aspbuf;
        } else if (!strcmp(method, "POST")) {
          // [POST HANDLING BLEIBT WIE ORIGINAL - wird im nÃ¤chsten Update fortgesetzt]
          pipedata.status = SEND_POST;
        } else if (!strcmp(method, "GET")) {
          // send default from here, no matter what happens
          pipedata.status = DEFAULT_REPLY;
          // trim up to non path chars
          char *path = strtok_r(NULL, " ", &reqptr);
          if (path == NULL) {
            pipedata.status = SEND_NO_URL;
            log_msg(LGG_DEBUG, "client did not specify URL for GET request");
          } else {
            // GET Request Processing Ã¼ber request_processor.c
            pipedata.status = process_get_request(path, host, &response, &rsize, 
                                                 &aspbuf, CONN_TLSTOR(ptr, allow_admin),
                                                 config.stats_url, config.stats_text_url,
                                                 config.pem_dir, config.argc, config.argv,
                                                 config.do_204, config.do_redirect, bufptr,
                                                 cors_origin);
          }
        } else {
          if (!strcmp(method, "HEAD")) {
            // HEAD (TODO: send header of what the actual response type would be?)
            pipedata.status = SEND_HEAD;
          } else {
            // something else, possibly even non-HTTP
            log_msg(LGG_DEBUG, "Sending HTTP 501 response for unknown HTTP method: %s", method);
            pipedata.status = SEND_BAD;
          }
          response = (char*)http501;  // Fix: Cast zu char*
          rsize = strlen(http501);     // Fix: Verwende strlen() statt sizeof
        }
      }
      TESTPRINT("%s: req type %d\n", __FUNCTION__, pipedata.status);

      /* cors */
      if (response == httpnulltext) {
        // High-Load Fix: Minimize asprintf() calls fÃ¼r bessere Performance
        if (!cors_origin) {
          rsize = asprintf(&aspbuf, httpnulltext, "");
        } else {
          // Vorgefertigte CORS-Response mit Length-Limit fÃ¼r Performance
          static const char cors_template[] = 
            "Access-Control-Allow-Origin: %.100s\r\n"
            "Access-Control-Allow-Credentials: true\r\n"
            "Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, documentReferer\r\n";
          
          char cors_buf[256]; // Fixed size statt malloc
          int cors_len = snprintf(cors_buf, sizeof(cors_buf), cors_template, cors_origin);
          
          if (cors_len > 0 && cors_len < sizeof(cors_buf)) {
            rsize = asprintf(&aspbuf, httpnulltext, cors_buf);
          } else {
            // Fallback bei Overflow
            rsize = asprintf(&aspbuf, httpnulltext, "");
          }
        }
        // Fix: asprintf Fehler-Check fÃ¼r CORS
        if (rsize != -1) {
          response = aspbuf;
        }
      }
    }
#ifdef DEBUG
    if (pipedata.status != FAIL_TIMEOUT)
      TIME_CHECK("response selection");
#endif

    // done processing socket connection; now handle selected result action
    if (pipedata.status == FAIL_GENERAL) {
      log_msg(LGG_DEBUG, "Client request processing completed with FAIL_GENERAL status");
    } else if (pipedata.status != FAIL_TIMEOUT && pipedata.status != FAIL_CLOSED) {

      // only attempt to send response if we've chosen a valid response type
      errno = 0;
      rv = write_socket(config.new_fd, response, rsize, CONN_TLSTOR(ptr, ssl), &CONN_TLSTOR(ptr, early_data));
      if (rv < 0) {
        if (errno == ECONNRESET || errno == EPIPE) {
          if (CONN_TLSTOR(ptr, ssl))
            strncpy(host, CONN_TLSTOR(ptr, tlsext_cb_arg)->servername, HOST_LEN_MAX);
          log_msg(LGG_WARNING, "disconnected client: %s method: %s server: %s", client_ip, method ? method : "unknown", host);
          pipedata.status = FAIL_REPLY;
        } else {
          log_msg(LGG_ERR, "attempt to send response for status=%d resulted in send() error: %m", pipedata.status);
          pipedata.status = FAIL_GENERAL;
        }
      } else if (rv != rsize) {
        log_msg(LGG_ERR, "send() reported only %d of %d bytes sent; status=%d", rv, rsize, pipedata.status);
      }

      if (log_verbose >= LGG_INFO) {
        log_xcs(LGG_INFO, client_ip, host, pipedata.ssl_ver, req_url, post_buf, post_buf_len);
      }

      // Memory-Leak Fix: Sofort freigeben nach Senden
      if (aspbuf) {
        free(aspbuf);
        aspbuf = NULL;
      }
    }

    /*** NOTE: pipedata.status should not be altered after this point ***/

    TIME_CHECK("response send()");

    // store time delta in milliseconds
    pipedata.run_time += elapsed_time_msec(start_time);
    write_pipe(config.pipefd, &pipedata);
    num_req++;

    TESTPRINT("run_time %.2f\n", pipedata.run_time);
    pipedata.run_time = 0.0;

    TIME_CHECK("pipe write()");

    if (pipedata.status == FAIL_CLOSED)
      break; /* goto done_with_this_thread */

  } /* end of main event loop */

  /* done with the thread and let's finish with some house keeping */
  log_msg(LGG_DEBUG, "Exit recv loop socket:%d rv:%d errno:%d num_req:%d\n", config.new_fd, rv, errno, num_req);

  // signal the socket connection that we're done read-write
  if(CONN_TLSTOR(ptr, ssl)){
    SSL_set_shutdown(CONN_TLSTOR(ptr, ssl), SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
    SSL_free(CONN_TLSTOR(ptr, ssl));
  }

  if (shutdown(config.new_fd, SHUT_RDWR) < 0)
    log_msg(LGG_DEBUG, "%s shutdown error: %m", __FUNCTION__);
  if (close(config.new_fd) < 0)
    log_msg(LGG_DEBUG, "%s close error: %m", __FUNCTION__);

  TIME_CHECK("socket close()");
  
  // decrement number of service threads/processes by one before we exit
  // don't check for write errors
  memset(&pipedata, 0, sizeof(pipedata));
  pipedata.status = ACTION_DEC_KCC;
  pipedata.krq = num_req;
  rv = write(config.pipefd, &pipedata, sizeof(pipedata));

  // Memory-Leak Fix: Finale AufrÃ¤umung vor Thread-Ende
  if (cors_origin) {
    free(cors_origin);
    cors_origin = NULL;
  }
  if (req_url) {
    free(req_url);
    req_url = NULL;
  }
  if (post_buf) {
    free(post_buf);
    post_buf = NULL;
  }
  if (aspbuf) {
    free(aspbuf);
    aspbuf = NULL;
  }
  if (buf) {
    free(buf);
    buf = NULL;
  }

  conn_stor_relinq(ptr);
  return NULL;
}
/*
 * src/comm/request_processor.c - HTTP Request Processing
 * 
 * Verarbeitung von GET-Requests und File-Extension-Handling
 * HIER WERDEN DIE 290+ EXTENSIONS HINZUGEFÃœGT
*/

#include "../util/util.h" // _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "request_processor.h"
#include "../http/http_responses.h"
#include "../http/http_utils.h"
#include "../log/logger.h"

// Externe Favicon-Definitionen (in connection_handler.c definiert)
extern unsigned char favicon_ico[];
extern unsigned int favicon_ico_len;

// Externe Funktionen die wir brauchen
extern char* get_version(int argc, char **argv);
extern char* get_stats(int html, int text);

response_enum process_get_request(char *path, char *host, char **response, int *rsize, 
                                  char **aspbuf, int allow_admin, 
                                  const char *stats_url, const char *stats_text_url,
                                  const char *pem_dir, int argc, char **argv,
                                  int do_204, int do_redirect, char *bufptr,
                                  char *cors_origin)
{
    char *version_string = NULL;
    char *stat_string = NULL;
    char *url = NULL;
    
    if (!strncmp(path, "/favicon.ico", 12)) {
        // favicon aus eingebettetem Header ausliefern
        size_t favicon_len = favicon_ico_len;
        // HTTPâ€‘Header
        char hdr[128];
        int hdrlen = snprintf(hdr, sizeof hdr,
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: image/x-icon\r\n"
            "Content-Length: %zu\r\n"
            "Connection: keep-alive\r\n"
            "\r\n",
            favicon_len);
        
        // Hier mÃ¼sste write_socket aufgerufen werden, aber das ist nicht in diesem Modul
        // Das wird in connection_handler.c gemacht
        (void)hdrlen; // Suppress unused warning
        return SEND_ICO;
        
    } else if (!strncmp(path, "/log=", 5) && allow_admin) {
        // Fix: Input-Validierung fÃ¼r log-Level
        if (strlen(path) <= 5) {
            return SEND_BAD;
        } else {
            int v = atoi(path + strlen("/log="));
            if (v > LGG_DEBUG || v < 0)
                return SEND_BAD;
            else {
                return ACTION_LOG_VERB;
            }
        }
    } else if (!strncmp(path, "/ca.crt", 7)) {
        FILE *fp;
        char *ca_file = NULL;
        // Fix: KEINE 404! Immer erfolgreiche Response
        *response = (char*)httpnulltext;
        *rsize = strlen(httpnulltext);

        // Fix: asprintf RÃ¼ckgabewert korrekt prÃ¼fen (-1 = Fehler)
        if (asprintf(&ca_file, "%s%s", pem_dir, "/ca.crt") != -1 &&
           NULL != (fp = fopen(ca_file, "r")))
        {
            fseek(fp, 0L, SEEK_END);
            long file_sz = ftell(fp);
            rewind(fp);
            *rsize = asprintf(aspbuf, "%s%ld%s", httpcacert, file_sz, httpcacert2);
            if (*rsize != -1 && (*aspbuf = (char*)realloc(*aspbuf, *rsize + file_sz + 16)) != NULL &&
                   fread(*aspbuf + *rsize, 1, file_sz, fp) == (size_t)file_sz) {
                                                            // should be fairly safe to cast here
              *response = *aspbuf;
              *rsize += file_sz;
            }
            fclose(fp);
        }
        if (ca_file) free(ca_file);
        return SEND_TXT;
        
    } else if (!strcmp(path, stats_url) && allow_admin) {
        version_string = get_version(argc, argv);
        stat_string = get_stats(1, 0);
        if (version_string && stat_string) {
            *rsize = asprintf(aspbuf,
                           "%s%u%s%s%s<br>%s%s",
                           httpstats1,
                           (unsigned int)(statsbaselen + strlen(version_string) + 4 + strlen(stat_string)),
                           httpstats2,
                           httpstats3,
                           version_string,
                           stat_string,
                           httpstats4);
            // Fix: asprintf Fehler-Check hinzufÃ¼gen - ABER KEINE 404!
            if (*rsize == -1) {
                log_msg(LGG_ERR, "asprintf failed for stats response");
                // Fallback: leere HTML statt 404
                *response = (char*)httpnulltext;
                *rsize = strlen(httpnulltext);
            } else {
                *response = *aspbuf;
            }
        }
        // Memory-Leak Fix: Sofort freigeben
        if (version_string) {
            free(version_string);
            version_string = NULL;
        }
        if (stat_string) {
            free(stat_string);
            stat_string = NULL;
        }
        return SEND_STATS;
        
    } else if (!strcmp(path, stats_text_url) && allow_admin) {
        version_string = get_version(argc, argv);
        stat_string = get_stats(0, 1);
        if (version_string && stat_string) {
            *rsize = asprintf(aspbuf,
                           "%s%u%s%s\n%s%s",
                           txtstats1,
                           (unsigned int)(strlen(version_string) + 1 + strlen(stat_string) + 2),
                           txtstats2,
                           version_string,
                           stat_string,
                           txtstats3);
            // Fix: asprintf Fehler-Check hinzufÃ¼gen - ABER KEINE 404!
            if (*rsize == -1) {
                log_msg(LGG_ERR, "asprintf failed for text stats response");
                // Fallback: leere HTML statt 404
                *response = (char*)httpnulltext;
                *rsize = strlen(httpnulltext);
            } else {
                *response = *aspbuf;
            }
        }
        // Memory-Leak Fix: Sofort freigeben
        if (version_string) {
            free(version_string);
            version_string = NULL;
        }
        if (stat_string) {
            free(stat_string);
            stat_string = NULL;
        }
        return SEND_STATSTEXT;
        
    } else if (do_204 && (!strcasecmp(path, "/generate_204") || !strcasecmp(path, "/gen_204"))) {
        *response = (char*)http204;
        *rsize = strlen(http204);
        return SEND_204;
        
    } else if (!strncasecmp(path, "/pagead/imgad?", 14) ||
               !strncasecmp(path, "/pagead/conversion/", 19 ) ||
               !strncasecmp(path, "/pcs/view?xai=AKAOj", 19 ) ||
               !strncasecmp(path, "/daca_images/simgad/", 20)) {
        *response = (char*)httpnullpixel;
        *rsize = strlen(httpnullpixel);
        return SEND_GIF;
        
    } else {
        // pick out encoded urls (usually advert redirects)
        if (do_redirect && strcasestr(path, "=http")) {
            char *decoded = malloc(strlen(path)+1);
            if (decoded) {
                urldecode(decoded, path);

                // double decode
                urldecode(path, decoded);
                free(decoded);
                url = strstr_last(path, "http://");
                if (url == NULL) {
                    url = strstr_last(path, "https://");
                }
                // WORKAROUND: google analytics block - request bomb on pages with conversion callbacks (see in chrome)
                if (url) {
                    char *tok = NULL;
                    for (tok = strtok_r(NULL, "\r\n", &bufptr); tok; tok = strtok_r(NULL, "\r\n", &bufptr)) {
                        char *hkey = strtok(tok, ":");
                        char *hvalue = strtok(NULL, "\r\n");
                        if (strstr_first(hkey, "Referer") && strstr_first(hvalue, url)) {
                            url = NULL;
                            TESTPRINT("Not redirecting likely callback URL: %s:%s\n", hkey, hvalue);
                            break;
                        }
                    }
                }
            }
        }
        if (do_redirect && url) {
            if (!cors_origin) {
                *rsize = asprintf(aspbuf, httpredirect, url, "");
            } else {
                char *tmpcors = NULL;
                int ret = asprintf(&tmpcors, httpcors_headers, cors_origin);
                if (ret != -1) {
                    *rsize = asprintf(aspbuf, httpredirect, url, tmpcors);
                    free(tmpcors);
                }
            }
            // Fix: asprintf Fehler-Check fÃ¼r Redirect - ABER KEINE 404!
            if (*rsize == -1) {
                log_msg(LGG_ERR, "asprintf failed for redirect response");
                // Fallback: leere HTML statt 404
                *response = (char*)httpnulltext;
                *rsize = strlen(httpnulltext);
                return SEND_TXT;
            } else {
                *response = *aspbuf;
                return SEND_REDIRECT;
            }
            url = NULL;
            TESTPRINT("Sending redirect: %s\n", url);
        } else {
            char *file = strrchr(strtok(path, "?#;="), '/');
            if (file == NULL) {
                // Fix: KEINE 404! Ad-Blocker soll immer "erfolgreich" sein
                *response = (char*)httpnulltext;
                *rsize = strlen(httpnulltext);
                log_msg(LGG_DEBUG, "URL contains invalid file path %s - sending empty HTML", path);
                return SEND_TXT;
            } else {
                TESTPRINT("file: '%s'\n", file);
                return handle_file_extension(file, response, rsize);
            }
        }
    }
    
    return DEFAULT_REPLY;
}

response_enum handle_file_extension(char *file, char **response, int *rsize)
{
    char *ext = strrchr(file, '.');
    if (ext == NULL) {
        // Fix: KEINE 404! Unbekannte URLs als leere HTML behandeln
        *response = (char*)httpnulltext;
        *rsize = strlen(httpnulltext);
        log_msg(LGG_DEBUG, "no file extension %s - sending empty HTML", file);
        return SEND_TXT;
    } else {
        TESTPRINT("ext: '%s'\n", ext);
        
        // === ERWEITERTE EXTENSION-BEHANDLUNG MIT ASP-UNTERSTÃœTZUNG ===
        // HIER WERDEN DIE 290+ EXTENSIONS HINZUGEFÃœGT
        const char *norm_ext = (ext[0] == '.') ? ext + 1 : ext;
        
        if (!strcasecmp(norm_ext, "gif")) {
            TESTPRINT("Sending gif response\n");
            *response = (char*)httpnullpixel;
            *rsize = strlen(httpnullpixel);
            return SEND_GIF;
        } else if (!strcasecmp(norm_ext, "png")) {
            TESTPRINT("Sending png response\n");
            *response = (char*)httpnull_png;
            *rsize = strlen(httpnull_png);
            return SEND_PNG;
        } else if (!strncasecmp(norm_ext, "jp", 2)) { // jpg, jpeg
            TESTPRINT("Sending jpg response\n");
            *response = (char*)httpnull_jpg;
            *rsize = strlen(httpnull_jpg);
            return SEND_JPG;
        } else if (!strcasecmp(norm_ext, "swf")) {
            TESTPRINT("Sending swf response\n");
            *response = (char*)httpnull_swf;
            *rsize = strlen(httpnull_swf);
            return SEND_SWF;
        } else if (!strcasecmp(norm_ext, "ico")) {
            TESTPRINT("Sending ico response\n");
            *response = (char*)httpnull_ico;
            *rsize = strlen(httpnull_ico);
            return SEND_ICO;
        }
        // === NEUE ASP-UNTERSTÃœTZUNG ===
        else if (!strcasecmp(norm_ext, "asp")) {
            TESTPRINT("Sending ASP response\n");
            *response = (char*)httpnull_asp;
            *rsize = strlen(httpnull_asp);
            return SEND_ASP;
        } else if (!strcasecmp(norm_ext, "aspx")) {
            TESTPRINT("Sending ASPX response\n");
            *response = (char*)httpnull_aspx;
            *rsize = strlen(httpnull_aspx);
            return SEND_ASPX;
        } else if (!strcasecmp(norm_ext, "ashx")) {
            TESTPRINT("Sending ASHX response\n");
            *response = (char*)httpnull_ashx;
            *rsize = strlen(httpnull_ashx);
            return SEND_ASHX;
        }
        // === WEITERE SERVER-SKRIPTE ===
        else if (!strcasecmp(norm_ext, "php")) {
            TESTPRINT("Sending PHP response\n");
            *response = (char*)httpnull_php;
            *rsize = strlen(httpnull_php);
            return SEND_PHP;
        } else if (!strcasecmp(norm_ext, "jsp")) {
            TESTPRINT("Sending JSP response\n");
            *response = (char*)httpnull_jsp;
            *rsize = strlen(httpnull_jsp);
            return SEND_JSP;
        } else if (!strncasecmp(norm_ext, "js", 2)) {  // .js, .jsx
            TESTPRINT("Sending JavaScript response\n");
            *response = (char*)httpnull_js;
            *rsize = strlen(httpnull_js);
            return SEND_JS;
        }
        // === WEB-STANDARDS ===
        else if (!strcasecmp(norm_ext, "css")) {
            TESTPRINT("Sending CSS response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_CSS;
        } else if (!strcasecmp(norm_ext, "html") || !strcasecmp(norm_ext, "htm")) {
            TESTPRINT("Sending HTML response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_HTML;
        }
        // === DATENFORMATE ===
        else if (!strcasecmp(norm_ext, "xml") || !strcasecmp(norm_ext, "rss")) {
            TESTPRINT("Sending XML response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_XML;
        } else if (!strcasecmp(norm_ext, "json")) {
            TESTPRINT("Sending JSON response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_JSON;
        }
        // === CGI UND ANDERE SERVER-SKRIPTE ===
        else if (!strcasecmp(norm_ext, "cgi") || !strcasecmp(norm_ext, "pl") || 
                 !strcasecmp(norm_ext, "fcgi")) {
            TESTPRINT("Sending CGI/Perl response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_TXT;
        }
        // === JAVA SERVER-TECHNOLOGIEN ===
        else if (!strcasecmp(norm_ext, "do") || !strcasecmp(norm_ext, "action")) {
            TESTPRINT("Sending Java Action response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_TXT;
        }
        // === .NET WEB SERVICES ===
        else if (!strcasecmp(norm_ext, "asmx") || !strcasecmp(norm_ext, "svc")) {
            TESTPRINT("Sending .NET Web Service response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_TXT;
        }
        // === COLDFUSION ===
        else if (!strcasecmp(norm_ext, "cfm")) {
            TESTPRINT("Sending ColdFusion response\n");
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            return SEND_TXT;
        }
        
        // === HIER KOMMEN DIE 290+ WEITEREN EXTENSIONS DAZU ===
        
        // === FALLBACK FÃœR ALLE ANDEREN EXTENSIONS ===
        else {
            // Fix: Automatische Behandlung aller anderen Extensions
            *response = (char*)httpnulltext;
            *rsize = strlen(httpnulltext);
            
            // Detailliertes Logging mit Extension-Info fÃ¼r bessere Diagnostik
            log_msg(LGG_DEBUG, "Auto-handling extension '%s' from file '%s' - sending empty HTML", 
                    norm_ext, file);
            TESTPRINT("Sending auto-response for extension '%s'\n", norm_ext);
            return SEND_TXT;
        }
    }
}
/*
 * src/comm/connection_handler.h - Connection Management Header
*/

#ifndef CONNECTION_HANDLER_H
#define CONNECTION_HANDLER_H

#include "../sock/socket_handler.h"

/* Connection Management */
void* conn_handler(void *ptr);

/* Time measurement macros */
#ifdef DEBUG
#define TIME_CHECK(x) {\
  if (do_warning) {\
    do_warning = 0;\
    double time_msec = 0.0;\
    time_msec = elapsed_time_msec(start_time);\
    if (time_msec > warning_time) {\
      log_msg(LGG_DEBUG, "Elapsed time %f msec exceeded warning_time=%d msec following operation: %s", time_msec, warning_time, x);\
    }\
  }\
}

#define ELAPSED_TIME(op) {\
    double time_msec = 0.0;\
    time_msec = elapsed_time_msec(start_time);\
    log_msg(LGG_DEBUG, "Elapsed time %f msec following operation: %s", time_msec, op);\
}
#else
#define TIME_CHECK(x,y...)
#define ELAPSED_TIME(x,y...)
#endif //DEBUG

#endif /* CONNECTION_HANDLER_H */
/*
 * src/comm/request_processor.h - HTTP Request Processing Header
*/

#ifndef REQUEST_PROCESSOR_H
#define REQUEST_PROCESSOR_H

#include "../sock/socket_handler.h"

/* Request Processing Functions */
response_enum process_get_request(char *path, char *host, char **response, int *rsize, 
                                  char **aspbuf, int allow_admin, 
                                  const char *stats_url, const char *stats_text_url,
                                  const char *pem_dir, int argc, char **argv,
                                  int do_204, int do_redirect, char *bufptr,
                                  char *cors_origin);

response_enum handle_file_extension(char *file, char **response, int *rsize);

#endif /* REQUEST_PROCESSOR_H */
/*
 * src/http/http_responses.c - HTTP Response Templates
 * 
 * Alle statischen HTTP-Response-Templates und Konstanten
*/

#include "../http/http_responses.h"

// private data for socket_handler() use
const char httpcors_headers[] =
  "Access-Control-Allow-Origin: %s\r\n"
  "Access-Control-Allow-Credentials: true\r\n"
  "Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, documentReferer\r\n";

const char httpnulltext[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-Type: text/html; charset=UTF-8\r\n"
  "Connection: keep-alive\r\n"
  "Content-Length: 0\r\n"
  "%s" /* optional CORS */
  "\r\n";

// HTTP 204 No Content for Google generate_204 URLs
const char http204[] =
  "HTTP/1.1 204 No Content\r\n"
  "Content-Length: 0\r\n"
  "Content-Type: text/html; charset=UTF-8\r\n"
  "\r\n";

// HTML stats response pieces
const char httpstats1[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html\r\n"
  "Content-length: ";
// total content length goes between these two strings
const char httpstats2[] =
  "\r\n"
  "Connection: keep-alive\r\n"
  "\r\n";
// split here because we care about the length of what follows
const char httpstats3[] =
  "<!DOCTYPE html><html><head><link rel='icon' href='/favicon.ico' type='image/x-icon'/><meta name='viewport' content='width=device-width'><title>pixelserv statistics</title><style>body {font-family:monospace;} table {min-width: 75%; border-collapse: collapse;} th { height:18px; } td {border: 1px solid #e0e0e0; background-color: #f9f9f9;} td:first-child {width: 7%;} td:nth-child(2) {width: 15%; background-color: #ebebeb; border: 1px solid #f9f9f9;}</style></head><body>";
// stats text goes between these two strings
const char httpstats4[] =
  "</body></html>\r\n";

// note: the -2 is to avoid counting the last line ending characters
const unsigned int statsbaselen = sizeof httpstats3 + sizeof httpstats4 - 2;

// TXT stats response pieces
const char txtstats1[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/plain\r\n"
  "Content-length: ";
// total content length goes between these two strings
const char txtstats2[] =
  "\r\n"
  "Connection: keep-alive\r\n"
  "\r\n";
// split here because we care about the length of what follows
const char txtstats3[] =
  "\r\n";

const char httpredirect[] =
  "HTTP/1.1 307 Temporary Redirect\r\n"
  "Location: %s\r\n"
  "Content-type: text/plain\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "%s" /* optional CORS */
  "\r\n";

const char httpnullpixel[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: image/gif\r\n"
  "Content-length: 42\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "GIF89a" // header
  "\1\0\1\0"  // little endian width, height
  "\x80"    // Global Colour Table flag
  "\0"    // background colour
  "\0"    // default pixel aspect ratio
  "\1\1\1"  // RGB
  "\0\0\0"  // RBG black
  "!\xf9"  // Graphical Control Extension
  "\4"  // 4 byte GCD data follow
  "\1"  // there is transparent background color
  "\0\0"  // delay for animation
  "\0"  // transparent colour
  "\0"  // end of GCE block
  ","  // image descriptor
  "\0\0\0\0"  // NW corner
  "\1\0\1\0"  // height * width
  "\0"  // no local color table
  "\2"  // start of image LZW size
  "\1"  // 1 byte of LZW encoded image data
  "D"    // image data
  "\0"  // end of image data
  ";";  // GIF file terminator

const char http501[] =
  "HTTP/1.1 501 Method Not Implemented\r\n"
  "Connection: keep-alive\r\n"
  "\r\n";

const char httpnull_png[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: image/png\r\n"
  "Content-length: 67\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "\x89"
  "PNG"
  "\r\n"
  "\x1a\n"  // EOF
  "\0\0\0\x0d" // 13 bytes length
  "IHDR"
  "\0\0\0\1\0\0\0\1"  // width x height
  "\x08"  // bit depth
  "\x06"  // Truecolour with alpha
  "\0\0\0"  // compression, filter, interlace
  "\x1f\x15\xc4\x89"  // CRC
  "\0\0\0\x0a"  // 10 bytes length
  "IDAT"
  "\x78\x9c\x63\0\1\0\0\5\0\1"
  "\x0d\x0a\x2d\xb4"  // CRC
  "\0\0\0\0"  // 0 length
  "IEND"
  "\xae\x42\x60\x82";  // CRC

const char httpnull_jpg[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: image/jpeg\r\n"
  "Content-length: 159\r\n"
  "Connection: close\r\n"
  "\r\n"
  "\xff\xd8"  // SOI, Start Of Image
  "\xff\xe0"  // APP0
  "\x00\x10"  // length of section 16
  "JFIF\0"
  "\x01\x01"  // version 1.1
  "\x01"      // pixel per inch
  "\x00\x48"  // horizontal density 72
  "\x00\x48"  // vertical density 72
  "\x00\x00"  // size of thumbnail 0 x 0
  "\xff\xdb"  // DQT
  "\x00\x43"  // length of section 3+64
  "\x00"      // 0 QT 8 bit
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xff\xff\xff\xff\xff\xff\xff"
  "\xff\xc0"  // SOF
  "\x00\x0b"  // length 11
  "\x08\x00\x01\x00\x01\x01\x01\x11\x00"
  "\xff\xc4"  // DHT Define Huffman Table
  "\x00\x14"  // length 20
  "\x00\x01"  // DC table 1
  "\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00\x00\x00\x00\x03"
  "\xff\xc4"  // DHT
  "\x00\x14"  // length 20
  "\x10\x01"  // AC table 1
  "\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00\x00\x00\x00\x00"
  "\xff\xda"  // SOS, Start of Scan
  "\x00\x08"  // length 8
  "\x01"    // 1 component
  "\x01\x00"
  "\x00\x3f\x00"  // Ss 0, Se 63, AhAl 0
  "\x37" // image
  "\xff\xd9";  // EOI, End Of image

const char httpnull_swf[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: application/x-shockwave-flash\r\n"
  "Content-length: 25\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "FWS"
  "\x05"  // File version
  "\x19\x00\x00\x00"  // litle endian size 16+9=25
  "\x30\x0A\x00\xA0"  // Frame size 1 x 1
  "\x00\x01"  // frame rate 1 fps
  "\x01\x00"  // 1 frame
  "\x43\x02"  // tag type is 9 = SetBackgroundColor block 3 bytes long
  "\x00\x00\x00"  // black
  "\x40\x00"  // tag type 1 = show frame
  "\x00\x00";  // tag type 0 - end file

const char httpnull_ico[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: image/x-icon\r\n"
  "Cache-Control: max-age=2592000\r\n"
  "Content-length: 70\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "\x00\x00" // reserved 0
  "\x01\x00" // ico
  "\x01\x00" // 1 image
  "\x01\x01\x00" // 1 x 1 x >8bpp colour
  "\x00" // reserved 0
  "\x01\x00" // 1 colour plane
  "\x20\x00" // 32 bits per pixel
  "\x30\x00\x00\x00" // size 48 bytes
  "\x16\x00\x00\x00" // start of image 22 bytes in
  "\x28\x00\x00\x00" // size of DIB header 40 bytes
  "\x01\x00\x00\x00" // width
  "\x02\x00\x00\x00" // height
  "\x01\x00" // colour planes
  "\x20\x00" // bits per pixel
  "\x00\x00\x00\x00" // no compression
  "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
  "\x00\x00\x00\x00" // end of header
  "\x00\x00\x00\x00" // Colour table
  "\x00\x00\x00\x00" // XOR B G R
  "\x80\xF8\x9C\x41"; // AND ?

// === NEUE ASP/SERVER-SIDE SCRIPT RESPONSES ===

// ASP Classic Response
const char httpnull_asp[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "\r\n";

// ASPX Response  
const char httpnull_aspx[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "X-AspNet-Version: 4.0.30319\r\n"
  "\r\n";

// ASHX Response (Generic Handler)
const char httpnull_ashx[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: application/octet-stream\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "\r\n";

// PHP Response
const char httpnull_php[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "X-Powered-By: PHP/7.4.0\r\n"
  "\r\n";

// JSP Response
const char httpnull_jsp[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "\r\n";

// JavaScript Response
const char httpnull_js[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: application/javascript; charset=UTF-8\r\n"
  "Content-length: 0\r\n"
  "Connection: keep-alive\r\n"
  "Cache-Control: no-cache, no-store, must-revalidate\r\n"
  "Pragma: no-cache\r\n"
  "Expires: 0\r\n"
  "\r\n";

const char httpoptions[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-type: text/html\r\n"
  "Content-length: 11\r\n"
  "Allow: GET,OPTIONS\r\n"
  "Connection: keep-alive\r\n"
  "\r\n"
  "GET,OPTIONS";

const char httpcacert[] =
  "HTTP/1.1 200 OK\r\n"
  "Content-Type: application/x-x509-ca-cert\r\n"
  "Accept-Ranges: bytes\r\n"
  "Content-Length: ";
const char httpcacert2[] =
  "\r\n"
  "\r\n";
/*
 * src/http/http_utils.c - HTTP Utility Functions
 * 
 * String-Manipulationen, URL-Dekodierung und Hilfsfunktionen
 * NUR Debug-Features und basis Utilities - KEIN normales Logging!
*/

#include "../util/util.h" // _GNU_SOURCE

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>

#include "../http/http_utils.h"

#ifdef DEBUG
#include "../log/logger.h"  // Nur fÃ¼r Debug-Features
#endif

#ifdef HEX_DUMP
// from http://sws.dett.de/mini/hexdump-c/
void hex_dump(void *data, int size)
{
  /* dumps size bytes of *data to stdout. Looks like:
   * [0000] 75 6E 6B 6E 6F 77 6E 20   30 FF 00 00 00 00 39 00 unknown 0.....9.
   * (in a single line of course)
   */

  if (!data || size <= 0) return;

  char *p = data;
  char c;
  int n;
  char bytestr[4] = {0};
  char addrstr[10] = {0};
  char hexstr[16*3 + 5] = {0};
  char charstr[16*1 + 5] = {0};
  
  // High-Load Fix: Thread-safe logging mit flockfile()
  flockfile(stdout);
  
  for (n = 1; n <= size; n++) {
    if (n%16 == 1) {
      // store address for this line - Fix: sichere Pointer-Arithmetik
      snprintf(addrstr, sizeof addrstr, "%.4x",
         (unsigned int)((uintptr_t)p - (uintptr_t)data) );
    }

    c = *p;
    if (isprint(c) == 0) {
      c = '.';
    }

    // store hex str (for left side)
    snprintf(bytestr, sizeof bytestr, "%02X ", (unsigned char)*p);
    strncat(hexstr, bytestr, sizeof hexstr - strlen(hexstr) - 1);

    // store char str (for right side)
    snprintf(bytestr, sizeof bytestr, "%c", c);
    strncat(charstr, bytestr, sizeof charstr - strlen(charstr) - 1);

    if (n%16 == 0) {
      // line completed
      printf("[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
      hexstr[0] = 0;
      charstr[0] = 0;
    } else if (n%8 == 0) {
      // half line: add whitespaces
      strncat(hexstr, "  ", sizeof hexstr - strlen(hexstr) - 1);
      strncat(charstr, " ", sizeof charstr - strlen(charstr) - 1);
    }

    p++; // next byte
  }

  if (strlen(hexstr) > 0) {
    // print rest of buffer if not empty
    printf("[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
  }
  
  funlockfile(stdout);
}
#endif // HEX_DUMP

// redirect utility functions
char* strstr_last(const char* const str1, const char* const str2) {
  char *strp;
  int len1, len2;
  len2 = strlen(str2);
  if (len2==0) {
    return (char *) str1;
  }
  len1 = strlen(str1);
  if (len1 - len2 <= 0) {
    return 0;
  }
  strp = (char *)(str1 + len1 - len2);
  while (strp != str1) {
    if (*strp == *str2 && strncmp(strp, str2, len2) == 0) {
      return strp;
    }
    strp--;
  }
  return 0;
}

/* strstr behavior undefined if one or more parameter is null.
   Not portable as MacOS default to crash. */
char* strstr_first(const char* const str1, const char* const str2) {
  if (!str1) return NULL;
  if (!str2) return (char*)str1;
  return strstr(str1, str2);
}

char from_hex(const char ch) {
  return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;
}

void urldecode(char* const decoded, char* const encoded) {
  char* pstr = encoded;
  char* pbuf = decoded;

  while (*pstr) {
    if (*pstr == '%') {
      if (pstr[1] && pstr[2]) {
        *pbuf++ = from_hex(pstr[1]) << 4 | from_hex(pstr[2]);
        pstr += 2;
      }
    } else {
      *pbuf++ = *pstr;
    }
    pstr++;
  }
  *pbuf = '\0';
}

void get_client_ip(int socket_fd, char *ip, int ip_len, char *port, int port_len)
{
  struct sockaddr_storage sin_addr;
  socklen_t sin_addr_len = sizeof(sin_addr);

  if (ip == NULL || ip_len <= 0 || (socket_fd < 0 && (ip[0] = '\0') == '\0'))
    return;

  if (getpeername(socket_fd, (struct sockaddr*)&sin_addr, &sin_addr_len) != 0 ||
      getnameinfo((struct sockaddr *)&sin_addr, sin_addr_len,
               ip, ip_len, port, port_len, NI_NUMERICHOST | NI_NUMERICSERV ) != 0) {
    ip[0] = '\0';
    // Kein Logging hier - wird in den aufrufenden Modulen gemacht
  }
}

#ifdef DEBUG
void child_signal_handler(int sig)
{
  if (sig != SIGTERM
   && sig != SIGUSR2) {
    log_msg(LGG_DEBUG, "Thread or child process ignoring unsupported signal number: %d", sig);
    return;
  }

  if (sig == SIGTERM) {
    // Ignore this signal while we are quitting
    signal(SIGTERM, SIG_IGN);
  }

  log_msg(LGG_DEBUG, "Thread or child process caught signal %d file %s", sig, __FILE__);

  if (sig == SIGTERM) {
    // exit program on SIGTERM
    log_msg(LGG_DEBUG, "Thread or child process exit on SIGTERM");
    exit(EXIT_SUCCESS);
  }

  return;
}
#endif
/*
 * src/http/http_responses.h - HTTP Response Templates Header
*/

#ifndef HTTP_RESPONSES_H
#define HTTP_RESPONSES_H

/* HTTP Response Templates */
extern const char httpcors_headers[];
extern const char httpnulltext[];
extern const char http204[];
extern const char httpstats1[];
extern const char httpstats2[];
extern const char httpstats3[];
extern const char httpstats4[];
extern const unsigned int statsbaselen;
extern const char txtstats1[];
extern const char txtstats2[];
extern const char txtstats3[];
extern const char httpredirect[];
extern const char httpnullpixel[];
extern const char http501[];
extern const char httpnull_png[];
extern const char httpnull_jpg[];
extern const char httpnull_swf[];
extern const char httpnull_ico[];

/* ASP/Server-side Script Responses */
extern const char httpnull_asp[];
extern const char httpnull_aspx[];
extern const char httpnull_ashx[];
extern const char httpnull_php[];
extern const char httpnull_jsp[];
extern const char httpnull_js[];

/* HTTP Options Response */
extern const char httpoptions[];

/* CA Certificate Response */
extern const char httpcacert[];
extern const char httpcacert2[];

/* Response Lengths - fÃ¼r sizeof() Ersatz */
extern const int http501_len;

#endif /* HTTP_RESPONSES_H */
/*
 * src/http/http_utils.h - HTTP Utility Functions Header
*/

#ifndef HTTP_UTILS_H
#define HTTP_UTILS_H

#include <netinet/in.h>

/* String utilities */
char* strstr_last(const char* const str1, const char* const str2);
char* strstr_first(const char* const str1, const char* const str2);
char from_hex(const char ch);
void urldecode(char* const decoded, char* const encoded);

/* Network utilities */
void get_client_ip(int socket_fd, char *ip, int ip_len, char *port, int port_len);

/* Debug utilities - nur bei DEBUG aktiv */
#ifdef HEX_DUMP
void hex_dump(void *data, int size);
#endif

#ifdef DEBUG
void child_signal_handler(int sig);
#endif

#endif /* HTTP_UTILS_H */
/*
 * src/ssl/keypool.c - SSL Context Cache and Connection Pool
*/

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509v3.h>
#include <openssl/opensslv.h>

#include "../ssl/ssl_config.h"
#include "../ssl/ssl_modules.h"
#include "../log/logger.h"
#include "../util/util.h"

#if defined(__GLIBC__) && !defined(__UCLIBC__)
#  include <malloc.h>
#endif

sslctx_cache_struct *sslctx_tbl;
static int sslctx_tbl_size, sslctx_tbl_end;
static int sslctx_tbl_cnt_hit, sslctx_tbl_cnt_miss, sslctx_tbl_cnt_purge;
static unsigned int sslctx_tbl_last_flush;

static void **conn_stor;
static int conn_stor_last = -1, conn_stor_max = -1;
static pthread_mutex_t cslock = PTHREAD_MUTEX_INITIALIZER;

/* Job Queue for parallel certificate generation */
cert_job_t *cert_q_head = NULL, *cert_q_tail = NULL;
pthread_mutex_t cert_q_lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cert_q_cond = PTHREAD_COND_INITIALIZER;
volatile int cert_workers_shutdown = 0;

static int sslctx_tbl_insert(const char *cert_name, SSL_CTX *sslctx, int ins_idx);

#ifdef DEBUG
void sslctx_tbl_dump(int idx, const char * func);
#endif

inline int sslctx_tbl_get_cnt_total() { return sslctx_tbl_end; }
inline int sslctx_tbl_get_cnt_hit() { return sslctx_tbl_cnt_hit; }
inline int sslctx_tbl_get_cnt_miss() { return sslctx_tbl_cnt_miss; }
inline int sslctx_tbl_get_cnt_purge() { return sslctx_tbl_cnt_purge; }

void conn_stor_init(int slots) {
    if (slots < 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s invalid slots %d", __FUNCTION__, slots);
#endif
        return;
    }
    conn_stor = calloc(slots, sizeof(void *));
    if (!conn_stor) {
#ifdef DEBUG
        log_msg(LGG_ERR, "Failed to allocate conn_stor of size %d", slots);
#endif
        return;
    }
    conn_stor_last = -1;
    conn_stor_max = slots;
}

void conn_stor_flush() {
    if (conn_stor_max < 0 || conn_stor_last < 0 || conn_stor_last <= conn_stor_max / 2)
        return;
        
    int threshold = conn_stor_max / 2;
    pthread_mutex_lock(&cslock);
    for (; conn_stor_last >= threshold && conn_stor[conn_stor_last] != NULL; conn_stor_last--) {
        free(conn_stor[conn_stor_last]);
        conn_stor[conn_stor_last] = NULL;
    }
    pthread_mutex_unlock(&cslock);
}

void conn_stor_relinq(conn_tlstor_struct *p) {
    if (!p) return;
    
    pthread_mutex_lock(&cslock);
    if (conn_stor_last >= conn_stor_max - 1) {
        pthread_mutex_unlock(&cslock);
        free(p);
#ifdef DEBUG
        log_msg(LGG_WARNING, "%s conn_stor overflow, freeing directly", __FUNCTION__);
#endif
    } else {
        conn_stor[++conn_stor_last] = p;
        pthread_mutex_unlock(&cslock);
    }
}

conn_tlstor_struct* conn_stor_acquire() {
    conn_tlstor_struct *ret = NULL;

    pthread_mutex_lock(&cslock);
    if (conn_stor_last >= 0) {
        ret = conn_stor[conn_stor_last];
        conn_stor[conn_stor_last--] = NULL;
    }
    pthread_mutex_unlock(&cslock);

    if (ret == NULL) {
        ret = calloc(1, sizeof(conn_tlstor_struct));
        if (ret != NULL) {
            ret->tlsext_cb_arg = &ret->v;
        }
    } else {
        /* Reset the structure but preserve allocated memory */
        memset(ret, 0, sizeof(conn_tlstor_struct));
        ret->tlsext_cb_arg = &ret->v;
    }
    return ret;
}

void sslctx_tbl_init(int tbl_size)
{
    if (tbl_size <= 0)
        return;
        
    sslctx_tbl_end = 0;
    sslctx_tbl = calloc(tbl_size, sizeof(sslctx_cache_struct));
    if (!sslctx_tbl) {
        sslctx_tbl_size = 0;
#ifdef DEBUG
        log_msg(LGG_ERR, "Failed to allocate sslctx_tbl of size %d", tbl_size);
#endif
        return;
    }
    
    sslctx_tbl_size = tbl_size;
    sslctx_tbl_cnt_hit = sslctx_tbl_cnt_miss = sslctx_tbl_cnt_purge = sslctx_tbl_last_flush = 0;
    
    /* Initialize mutexes for each cache entry */
    for (int i = 0; i < tbl_size; i++) {
        pthread_mutex_init(&SSLCTX_TBL_get(i, lock), NULL);
    }
}

void sslctx_tbl_cleanup()
{
    if (!sslctx_tbl) return;
    
    shutdown_cert_workers();
    
    for (int idx = 0; idx < sslctx_tbl_end; idx++) {
        free(SSLCTX_TBL_get(idx, cert_name));
        SSL_CTX_free(SSLCTX_TBL_get(idx, sslctx));
        pthread_mutex_destroy(&SSLCTX_TBL_get(idx, lock));
    }
    
    free(sslctx_tbl);
    sslctx_tbl = NULL;
    
    pthread_mutex_destroy(&cslock);
    
    if (conn_stor) {
        for (int i = 0; i <= conn_stor_last; i++) {
            free(conn_stor[i]);
        }
        free(conn_stor);
        conn_stor = NULL;
    }
}

static int cmp_sslctx_reuse_count(const void *p1, const void *p2)
{
    return ((sslctx_cache_struct *)p2)->reuse_count - ((sslctx_cache_struct *)p1)->reuse_count;
}

static int cmp_sslctx_certname(const void *k, const void *p)
{
    return strcmp(((sslctx_cache_struct *)k)->cert_name, ((sslctx_cache_struct *)p)->cert_name);
}

void sslctx_tbl_load(const char* pem_dir, const STACK_OF(X509_INFO) *cachain)
{
    char *fname = NULL, *line = NULL;
    size_t line_len = PIXELSERV_MAX_PATH;
    FILE *fp = NULL;
    
    if (!(line = malloc(line_len)) || !(fname = malloc(PIXELSERV_MAX_PATH))) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to allocate memory", __FUNCTION__);
#endif
        goto quit_load;
    }

    snprintf(fname, PIXELSERV_MAX_PATH, "%s/prefetch", pem_dir);
    if (!(fp = fopen(fname, "r"))) {
#ifdef DEBUG
        log_msg(LGG_WARNING, "%s: %s doesn't exist.", __FUNCTION__, fname);
#endif
        goto quit_load;
    }

    while (getline(&line, &line_len, fp) != -1) {
        char *cert_name = strtok(line, " \n\t");
        if (!cert_name) continue;
        
        snprintf(fname, PIXELSERV_MAX_PATH, "%s/%s", pem_dir, cert_name);

        SSL_CTX *sslctx = create_child_sslctx(fname, cachain);
        if (sslctx) {
            int ins_idx = sslctx_tbl_end;
            sslctx_tbl_insert(cert_name, sslctx, ins_idx);
#ifdef DEBUG
            log_msg(LGG_NOTICE, "%s: %s", __FUNCTION__, cert_name);
#endif
        }
        if (sslctx_tbl_end >= sslctx_tbl_size)
            break;
    }
    
    fclose(fp);
    fp = NULL;
    
    sslctx_tbl_cnt_miss = 0; /* reset */
    qsort(SSLCTX_TBL_ptr(0), sslctx_tbl_end, sizeof(sslctx_cache_struct), cmp_sslctx_certname);

quit_load:
    free(fname);
    free(line);
    if (fp) fclose(fp);
}

void sslctx_tbl_save(const char* pem_dir)
{
    #define RATIO_TO_SAVE 1
    char *fname = NULL;
    FILE *fp = NULL;

    if (!(fname = malloc(PIXELSERV_MAX_PATH))) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to allocate memory", __FUNCTION__);
#endif
        return;
    }
    
    snprintf(fname, PIXELSERV_MAX_PATH, "%s/prefetch", pem_dir);
    if (!(fp = fopen(fname, "w"))) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to open %s", __FUNCTION__, fname);
#endif
        goto quit_save;
    }
    
    qsort(SSLCTX_TBL_ptr(0), sslctx_tbl_end, sizeof(sslctx_cache_struct), cmp_sslctx_reuse_count);
    
    int save_count = (sslctx_tbl_end > (sslctx_tbl_size * RATIO_TO_SAVE)) 
                     ? (sslctx_tbl_size * RATIO_TO_SAVE) 
                     : sslctx_tbl_end;

    for (int idx = 0; idx < save_count; idx++) {
        fprintf(fp, "%s\t%d\n", SSLCTX_TBL_get(idx, cert_name), SSLCTX_TBL_get(idx, reuse_count));
    }
    
    fclose(fp);
    fp = NULL;

quit_save:
    free(fname);
    if (fp) fclose(fp);
}

void sslctx_tbl_lock(int idx)
{
    if (idx < 0 || idx >= sslctx_tbl_size) {
#ifdef DEBUG
        log_msg(LGG_DEBUG, "%s: invalid idx %d", __FUNCTION__, idx);
#endif
        return;
    }
    pthread_mutex_lock(&SSLCTX_TBL_get(idx, lock));
}

void sslctx_tbl_unlock(int idx)
{
    if (idx < 0 || idx >= sslctx_tbl_size) {
#ifdef DEBUG
        log_msg(LGG_DEBUG, "%s: invalid idx %d", __FUNCTION__, idx);
#endif
        return;
    }
    pthread_mutex_unlock(&SSLCTX_TBL_get(idx, lock));
}

int sslctx_tbl_check_and_flush(void)
{
    int pixel_now = process_uptime();
#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: now %d last_flush %d", __FUNCTION__, pixel_now, sslctx_tbl_last_flush);
#endif

    /* flush at most every half of session timeout */
    int do_flush = pixel_now - sslctx_tbl_last_flush - PIXEL_SSL_SESS_TIMEOUT / 2;
    if (do_flush < 0) {
        return -1;
    }
    
    SSL_CTX_flush_sessions(g_sslctx, time(NULL));
    sslctx_tbl_last_flush = pixel_now;
    return 1;
}

int sslctx_tbl_lookup(const char* cert_name, int* found_idx, int* ins_idx)
{
    *found_idx = -1; 
    *ins_idx = -1;
    
    if (!cert_name || !found_idx || !ins_idx) {
#ifdef DEBUG
        log_msg(LGG_ERR, "Invalid params. cert_name: %s", cert_name ? cert_name : "NULL");
#endif
        return -1;
    }

    sslctx_cache_struct key, *found;
    key.cert_name = (char*)cert_name;
    found = bsearch(&key, SSLCTX_TBL_ptr(0), sslctx_tbl_end, sizeof(sslctx_cache_struct), cmp_sslctx_certname);

    if (found != NULL) {
        sslctx_tbl_cnt_hit++;
        found->reuse_count++;
        found->last_use = process_uptime();
        *found_idx = (found - SSLCTX_TBL_ptr(0));
    } else if (sslctx_tbl_end < sslctx_tbl_size) {
        *ins_idx = sslctx_tbl_end;
    } else {
        /* Find LRU entry to replace */
        int purge_idx = 0;
        unsigned int oldest_use = process_uptime();

        for (int idx = 0; idx < sslctx_tbl_end; idx++) {
            if (SSLCTX_TBL_get(idx, last_use) < oldest_use) {
                oldest_use = SSLCTX_TBL_get(idx, last_use);
                purge_idx = idx;
            }
        }
        *ins_idx = purge_idx;
    }
    return 0;
}

static int sslctx_tbl_insert(const char *cert_name, SSL_CTX *sslctx, int ins_idx)
{
    if (!cert_name || !sslctx || ins_idx >= sslctx_tbl_size || ins_idx < 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "Invalid params. cert_name: %s, ins_idx: %d", 
                cert_name ? cert_name : "NULL", ins_idx);
#endif
        return -1;
    }
    
    sslctx_tbl_cnt_miss++;

    unsigned int pixel_now = process_uptime();
    int len = strlen(cert_name);
    char *str = SSLCTX_TBL_get(ins_idx, cert_name);
    
    if ((len + 1) > SSLCTX_TBL_get(ins_idx, alloc_len)) {
        str = realloc(str, len + 1);
        if (!str) {
#ifdef DEBUG
            log_msg(LGG_ERR, "Failed to allocate memory for cert_name");
#endif
            return -1;
        }
        SSLCTX_TBL_set(ins_idx, alloc_len, len + 1);
    }
    
    strncpy(str, cert_name, len + 1);
    SSLCTX_TBL_set(ins_idx, cert_name, str);
    SSLCTX_TBL_set(ins_idx, last_use, pixel_now);
    SSLCTX_TBL_set(ins_idx, reuse_count, 0);
    
    if (ins_idx == sslctx_tbl_end && sslctx_tbl_end < sslctx_tbl_size) {
        sslctx_tbl_end++;
    } else {
#ifdef DEBUG
        log_msg(LGG_DEBUG, "%s: SSL_CTX_free %p sslctx_tbl_end %d", __FUNCTION__, 
                SSLCTX_TBL_get(ins_idx, sslctx), sslctx_tbl_end);
#endif
        SSL_CTX_free(SSLCTX_TBL_get(ins_idx, sslctx));
        sslctx_tbl_cnt_purge++;
    }
    
    SSLCTX_TBL_set(ins_idx, sslctx, sslctx);
    return 0;
}

int sslctx_tbl_cache(const char *cert_name, SSL_CTX *sslctx, int ins_idx)
{
    if (sslctx_tbl_insert(cert_name, sslctx, ins_idx) == 0) {
        qsort(SSLCTX_TBL_ptr(0), sslctx_tbl_end, sizeof(sslctx_cache_struct), cmp_sslctx_certname);
        return 0;
    }
    return -1;
}

int sslctx_tbl_purge(int idx) {
    if (idx < 0 || idx >= sslctx_tbl_end) {
        return -1;
    }

    free(SSLCTX_TBL_get(idx, cert_name));
    SSL_CTX_free(SSLCTX_TBL_get(idx, sslctx));
    
    --sslctx_tbl_end;
    if (idx < sslctx_tbl_end) {
        memmove(SSLCTX_TBL_ptr(idx), SSLCTX_TBL_ptr(idx+1), 
                sizeof(sslctx_cache_struct) * (sslctx_tbl_end - idx));
    }
    memset(SSLCTX_TBL_ptr(sslctx_tbl_end), 0, sizeof(sslctx_cache_struct));

    return 0;
}

#ifdef DEBUG
static void sslctx_tbl_dump(int idx, const char * func)
{
    if (idx < 0 || idx >= sslctx_tbl_end) return;
    
    log_msg(LGG_DEBUG, "%s: idx %d now %d", func, idx, process_uptime());
    log_msg(LGG_DEBUG, "** cert_name %s", SSLCTX_TBL_get(idx, cert_name));
    log_msg(LGG_DEBUG, "** alloc_len %d", SSLCTX_TBL_get(idx, alloc_len));
    log_msg(LGG_DEBUG, "** last_use %d", SSLCTX_TBL_get(idx, last_use));
    log_msg(LGG_DEBUG, "** reuse_count %d", SSLCTX_TBL_get(idx, reuse_count));
    log_msg(LGG_DEBUG, "** sslctx %p", SSLCTX_TBL_get(idx, sslctx));
}
#endif

/* Shutdown certificate workers */
void shutdown_cert_workers(void) {
    cert_workers_shutdown = 1;
    pthread_cond_broadcast(&cert_q_cond);
}

/* Enqueue certificate generation job */
void enqueue_cert_job(const char *cert_name) {
    cert_job_t *job = malloc(sizeof(*job));
    if (!job) {
#ifdef DEBUG
        log_msg(LGG_ERR, "Failed to allocate cert job for %s", cert_name);
#endif
        return;
    }
    
    strncpy(job->cert_name, cert_name, PIXELSERV_MAX_SERVER_NAME);
    job->cert_name[PIXELSERV_MAX_SERVER_NAME] = '\0';
    job->next = NULL;
    
    pthread_mutex_lock(&cert_q_lock);
    if (!cert_q_tail) {
        cert_q_head = job;
    } else {
        cert_q_tail->next = job;
    }
    cert_q_tail = job;
    pthread_cond_signal(&cert_q_cond);
    pthread_mutex_unlock(&cert_q_lock);
}

/* Get SSL context from cache by name */
SSL_CTX* sslctx_tbl_get_ctx(const char *cert_name) {
    if (!cert_name) return NULL;
    
    int found_idx, ins_idx;
    if (sslctx_tbl_lookup(cert_name, &found_idx, &ins_idx) == 0 && found_idx >= 0) {
        return SSLCTX_TBL_get(found_idx, sslctx);
    }
    return NULL;
}

/* Certificate validation */
int validate_certificate_chain(SSL_CTX *ctx) {
    if (!ctx) return 0;
    
    X509_STORE *store = SSL_CTX_get_cert_store(ctx);
    if (!store) return 0;
    
    /* Additional validation logic can be added here */
    return 1;
}

/* Enhanced certificate expiration check */
int check_cert_expiration(const char *cert_path, time_t *expires_at) {
    FILE *fp = fopen(cert_path, "r");
    if (!fp) return -1;
    
    X509 *cert = PEM_read_X509(fp, NULL, NULL, NULL);
    fclose(fp);
    
    if (!cert) return -1;
    
    ASN1_TIME *not_after = X509_get_notAfter(cert);
    if (!not_after) {
        X509_free(cert);
        return -1;
    }
    
    int days, seconds;
    if (ASN1_TIME_diff(&days, &seconds, NULL, not_after)) {
        if (expires_at) {
            *expires_at = time(NULL) + days * 86400 + seconds;
        }
        X509_free(cert);
        return (days > 0 || (days == 0 && seconds > 0)) ? 1 : 0;
    }
    
    X509_free(cert);
    return -1;
}

/* Enhanced error reporting for certificate operations */
void log_ssl_errors(const char *operation) {
    unsigned long err;
    char err_buf[256];
    
    while ((err = ERR_get_error()) != 0) {
        ERR_error_string_n(err, err_buf, sizeof(err_buf));
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: %s", operation, err_buf);
#endif
    }
}

/* Cleanup expired certificates from cache */
void sslctx_tbl_cleanup_expired(void) {
    time_t now = time(NULL);
    
    for (int i = 0; i < sslctx_tbl_end; i++) {
        SSL_CTX *ctx = SSLCTX_TBL_get(i, sslctx);
        if (!ctx) continue;
        
        X509 *cert = SSL_CTX_get0_certificate(ctx);
        if (!cert) continue;
        
        if (X509_cmp_time(X509_get_notAfter(cert), &now) < 0) {
#ifdef DEBUG
            log_msg(LGG_NOTICE, "Removing expired certificate from cache: %s", 
                    SSLCTX_TBL_get(i, cert_name));
#endif
            sslctx_tbl_purge(i);
            i--; /* Adjust index after removal */
        }
    }
}

/* Memory usage statistics */
size_t sslctx_tbl_memory_usage(void) {
    size_t total = 0;
    
    total += sslctx_tbl_size * sizeof(sslctx_cache_struct);
    
    for (int i = 0; i < sslctx_tbl_end; i++) {
        total += SSLCTX_TBL_get(i, alloc_len);
        /* SSL_CTX memory is harder to calculate, estimate conservatively */
        total += 64 * 1024; /* ~64KB per SSL_CTX */
    }
    
    return total;
}

/* Certificate pre-generation for common domains */
void pregenerate_common_certs(cert_tlstor_t *ct) {
    const char *common_domains[] = {
        "google.com", "facebook.com", "amazon.com", "microsoft.com",
        "apple.com", "netflix.com", "youtube.com", "twitter.com",
        "instagram.com", "linkedin.com", "github.com", "stackoverflow.com",
        NULL
    };
    
    if (!ct || !ct->privkey || !ct->issuer) {
#ifdef DEBUG
        log_msg(LGG_WARNING, "Cannot pregenerate certs: invalid cert_tlstor");
#endif
        return;
    }
    
#ifdef DEBUG
    log_msg(LGG_NOTICE, "Pre-generating certificates for common domains...");
#endif
    
    int i;
    for (i = 0; common_domains[i]; i++) {
        enqueue_cert_job(common_domains[i]);
    }
    
#ifdef DEBUG
    log_msg(LGG_NOTICE, "Queued %d certificates for pre-generation", i);
#endif
}

/* Statistics for monitoring */
void print_cert_statistics(void) {
    printf("\n=== Certificate Statistics ===\n");
    printf("Cache entries: %d/%d\n", sslctx_tbl_get_cnt_total(), sslctx_tbl_size);
    printf("Cache hits: %d\n", sslctx_tbl_get_cnt_hit());
    printf("Cache misses: %d\n", sslctx_tbl_get_cnt_miss());
    printf("Cache purges: %d\n", sslctx_tbl_get_cnt_purge());
    printf("Memory usage: %.2f MB\n", sslctx_tbl_memory_usage() / (1024.0 * 1024.0));
    printf("Connection store: %d/%d\n", conn_stor_last + 1, conn_stor_max);
    printf("===============================\n");
}
/*
 * src/ssl/ssl_context.c - SSL Context Management and TLS Callbacks
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509v3.h>
#include <openssl/opensslv.h>
#include "../ssl/ssl_config.h"
#include "../ssl/ssl_modules.h"
#include "../log/logger.h"
#include "../util/util.h"

extern SSL_CTX *g_sslctx;

/* Forward declarations */

/* Enhanced IP detection - use function from ssl_init.c */

inline int sslctx_tbl_get_sess_cnt() { return SSL_CTX_sess_number(g_sslctx); }
inline int sslctx_tbl_get_sess_hit() { return SSL_CTX_sess_hits(g_sslctx); }
inline int sslctx_tbl_get_sess_miss() { return SSL_CTX_sess_misses(g_sslctx); }
inline int sslctx_tbl_get_sess_purge() { return SSL_CTX_sess_cache_full(g_sslctx); }

#ifdef TLS1_3_VERSION
static const unsigned char *get_server_name(SSL *s, size_t *len)
{
    const unsigned char *p;
    size_t remaining;

    if (!SSL_client_hello_get0_ext(s, TLSEXT_TYPE_server_name, &p, &remaining) ||
        remaining <= 2)
        return NULL;
        
    /* Extract the length of the supplied list of names. */
    size_t list_len = (*(p++) << 8);
    list_len += *(p++);
    if (list_len + 2 != remaining)
        return NULL;
        
    remaining = list_len;
    if (remaining == 0 || *p++ != TLSEXT_NAMETYPE_host_name)
        return NULL;
        
    remaining--;
    if (remaining <= 2)
        return NULL;
        
    *len = (*(p++) << 8);
    *len += *(p++);
    if (*len + 2 > remaining)
        return NULL;
        
    return p;
}

int tls_clienthello_cb(SSL *ssl, int *ad, void *arg) {
# define CB_OK   1
# define CB_ERR  0
#else
static int tls_servername_cb(SSL *ssl, int *ad, void *arg) {
# define CB_OK   0
# define CB_ERR  SSL_TLSEXT_ERR_ALERT_FATAL
#endif
    int rv = CB_OK;
    tlsext_cb_arg_struct *cbarg = (tlsext_cb_arg_struct *)arg;
    char full_pem_path[PIXELSERV_MAX_PATH + 2];
    int len;

    if (!cbarg || !cbarg->tls_pem) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: invalid callback arguments", __FUNCTION__);
#endif
        rv = CB_ERR;
        goto quit_cb;
    }

    len = strlen(cbarg->tls_pem);
    if (len >= PIXELSERV_MAX_PATH) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: path too long", __FUNCTION__);
#endif
        rv = CB_ERR;
        goto quit_cb;
    }
    
    strncpy(full_pem_path, cbarg->tls_pem, PIXELSERV_MAX_PATH);
    full_pem_path[len++] = '/';
    full_pem_path[len] = '\0';

    const char *srv_name = NULL;
#ifdef TLS1_3_VERSION
    size_t name_len = 0;
    const unsigned char *name_data = get_server_name(ssl, &name_len);
    if (name_data && name_len > 0 && name_len < sizeof(cbarg->servername)) {
        memcpy(cbarg->servername, name_data, name_len);
        cbarg->servername[name_len] = '\0';
        srv_name = cbarg->servername;
    }
#else
    srv_name = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
    if (srv_name) {
        strncpy(cbarg->servername, srv_name, sizeof(cbarg->servername) - 1);
        cbarg->servername[sizeof(cbarg->servername) - 1] = '\0';
    }
#endif

    if (!srv_name) {
        if (strlen(cbarg->servername) > 0) {
            srv_name = cbarg->servername;
        } else {
#ifdef DEBUG
            log_msg(LGG_WARNING, "SNI failed. server name and ip empty.");
#endif
            rv = CB_ERR;
            goto quit_cb;
        }
    }

#ifdef DEBUG
    log_msg(LGG_DEBUG, "SNI servername: %s", srv_name);
#endif

    /* Check if this is an IP address - if so, use universal IP cert */
    if (is_ip_address(srv_name)) {
        char universal_ip_path[PIXELSERV_MAX_PATH];
        snprintf(universal_ip_path, sizeof(universal_ip_path), "%s/universal_ips.pem", cbarg->tls_pem);
        
        struct stat st;
        if (stat(universal_ip_path, &st) == 0) {
            SSL_CTX *ip_ctx = create_child_sslctx(universal_ip_path, cbarg->cachain);
            if (ip_ctx) {
                SSL_set_SSL_CTX(ssl, ip_ctx);
                cbarg->status = SSL_HIT;
#ifdef DEBUG
                log_msg(LGG_DEBUG, "ðŸ”’ Using universal IP cert for: %s", srv_name);
#endif
                goto quit_cb;
            }
        }
    }

    /* Determine certificate filename based on domain structure */
    int dot_count = 0;
    const char *tld = NULL;
    const char *dot_pos = strchr(srv_name, '.');
    while (dot_pos) {
        dot_count++;
        tld = dot_pos + 1;
        dot_pos = strchr(tld, '.');
    }

    const char *pem_file;
    if (dot_count <= 1 || 
        (dot_count == 2 && strlen(tld) == 2) || 
        (dot_count == 3 && atoi(tld) > 0)) {
        pem_file = srv_name;
        strncat(full_pem_path, srv_name, PIXELSERV_MAX_PATH - len);
        len += strlen(srv_name);
    } else {
        pem_file = full_pem_path + strlen(full_pem_path);
        strncat(full_pem_path, "_", PIXELSERV_MAX_PATH - len);
        len += 1;
        const char *wildcard_domain = strchr(srv_name, '.');
        if (wildcard_domain) {
            strncat(full_pem_path, wildcard_domain, PIXELSERV_MAX_PATH - len);
            len += strlen(wildcard_domain);
        }
    }

#ifdef DEBUG
    log_msg(LGG_DEBUG, "PEM filename: %s", full_pem_path);
#endif

    if (len > PIXELSERV_MAX_PATH) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: buffer overflow. %s", __FUNCTION__, full_pem_path);
#endif
        rv = CB_ERR;
        goto quit_cb;
    }

    int handle, ins_handle;
    if (sslctx_tbl_lookup(pem_file, &handle, &ins_handle) != 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: sslctx_tbl_lookup failed", __FUNCTION__);
#endif
        rv = CB_ERR;
        goto quit_cb;
    }

#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: handle %d ins_handle %d", __FUNCTION__, handle, ins_handle);
    if (handle >= 0) sslctx_tbl_dump(handle, __FUNCTION__);
    if (ins_handle >= 0) sslctx_tbl_dump(ins_handle, __FUNCTION__);
#endif

    if (handle >= 0) {
        SSL_set_SSL_CTX(ssl, SSLCTX_TBL_get(handle, sslctx));
        
        /* Check certificate expiration */
        X509 *cert = SSL_get_certificate(ssl);
        if (cert && X509_cmp_time(X509_get_notAfter(cert), NULL) > 0) {
            cbarg->status = SSL_HIT;
            goto quit_cb;
        }
        
        /* Certificate expired */
        cbarg->status = SSL_ERR;
#ifdef DEBUG
        log_msg(LGG_WARNING, "Expired certificate %s", pem_file);
#endif
        sslctx_tbl_purge(handle);
        remove(full_pem_path);
        goto submit_missing_cert;
    }

    /* Check if certificate file exists */
    struct stat st;
    if (stat(full_pem_path, &st) != 0) {
        cbarg->status = SSL_MISS;
        
        /* Artificial delay for missing certificate */
        struct timespec delay = {0, 300 * 1000000}; /* 300ms */
        nanosleep(&delay, NULL);

#ifdef DEBUG
        log_msg(LGG_WARNING, "%s %s missing", srv_name, pem_file);
#endif

submit_missing_cert:
        enqueue_cert_job(pem_file);
        rv = CB_ERR;
        goto quit_cb;
    }

    /* Load certificate from disk */
    SSL_CTX *sslctx = create_child_sslctx(full_pem_path, cbarg->cachain);
    if (!sslctx) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: fail to create sslctx for %s", __FUNCTION__, pem_file);
#endif
        cbarg->status = SSL_ERR;
        rv = CB_ERR;
        goto quit_cb;
    }

    SSL_set_SSL_CTX(ssl, sslctx);
    
    /* Check certificate expiration again */
    X509 *cert = SSL_get_certificate(ssl);
    if (cert && X509_cmp_time(X509_get_notAfter(cert), NULL) < 0) {
        cbarg->status = SSL_ERR;
#ifdef DEBUG
        log_msg(LGG_WARNING, "Expired certificate %s", pem_file);
#endif
        remove(full_pem_path);
        goto submit_missing_cert;
    }

    if (sslctx_tbl_cache(pem_file, sslctx, ins_handle) < 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: fail to cache sslctx for %s", __FUNCTION__, pem_file);
#endif
        cbarg->status = SSL_ERR;
        rv = CB_ERR;
        goto quit_cb;
    }
    
    cbarg->status = SSL_HIT;

quit_cb:
    return rv;
}

SSL_CTX* create_child_sslctx(const char* full_pem_path, const STACK_OF(X509_INFO) *cachain)
{
    SSL_CTX *sslctx = SSL_CTX_new(TLS_server_method());
    if (!sslctx) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: SSL_CTX_new failed", __FUNCTION__);
#endif
        return NULL;
    }

    /* Set up ECDH */
#if OPENSSL_VERSION_NUMBER >= 0x10101000L
    /* OpenSSL 1.1.1+ */
    int groups[] = { NID_X9_62_prime256v1, NID_secp384r1 };
    SSL_CTX_set1_groups(sslctx, groups, sizeof(groups)/sizeof(groups[0]));
#elif OPENSSL_VERSION_NUMBER >= 0x10100000L
    /* OpenSSL 1.1.0 */
    SSL_CTX_set_ecdh_auto(sslctx, 1);
#else
    /* Legacy OpenSSL */
    EC_KEY *ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
    if (ecdh) {
        SSL_CTX_set_tmp_ecdh(sslctx, ecdh);
        EC_KEY_free(ecdh);
    }
#endif

    /* Set SSL options */
    long options = SSL_OP_SINGLE_DH_USE |
                   SSL_OP_NO_COMPRESSION |
                   SSL_OP_NO_TICKET |
                   SSL_OP_NO_SSLv2 |
                   SSL_OP_NO_SSLv3 |
                   SSL_OP_CIPHER_SERVER_PREFERENCE;

#ifdef SSL_MODE_RELEASE_BUFFERS
    options |= SSL_MODE_RELEASE_BUFFERS;
#endif

#ifdef SSL_OP_NO_TLSv1_1
    options |= SSL_OP_NO_TLSv1_1;
#endif

    SSL_CTX_set_options(sslctx, options);

    /* Session cache settings */
    SSL_CTX_set_session_cache_mode(sslctx, SSL_SESS_CACHE_NO_AUTO_CLEAR | SSL_SESS_CACHE_SERVER);
    SSL_CTX_set_timeout(sslctx, PIXEL_SSL_SESS_TIMEOUT);
    SSL_CTX_sess_set_cache_size(sslctx, 1);

    /* Set cipher lists */
    if (SSL_CTX_set_cipher_list(sslctx, PIXELSERV_CIPHER_LIST) <= 0) {
#ifdef DEBUG
        log_msg(LGG_DEBUG, "%s: failed to set cipher list", __FUNCTION__);
#endif
    }

#ifdef TLS1_3_VERSION
    SSL_CTX_set_min_proto_version(sslctx, TLS1_VERSION);
    SSL_CTX_set_max_proto_version(sslctx, TLS1_3_VERSION);
    if (SSL_CTX_set_ciphersuites(sslctx, PIXELSERV_TLSV1_3_CIPHERS) <= 0) {
#ifdef DEBUG
        log_msg(LGG_DEBUG, "%s: failed to set TLSv1.3 ciphersuites", __FUNCTION__);
#endif
    }
#endif

    /* Load certificate and private key */
    if (SSL_CTX_use_certificate_file(sslctx, full_pem_path, SSL_FILETYPE_PEM) <= 0 ||
        SSL_CTX_use_PrivateKey_file(sslctx, full_pem_path, SSL_FILETYPE_PEM) <= 0) {
        SSL_CTX_free(sslctx);
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: cannot find or use %s", __FUNCTION__, full_pem_path);
#endif
        return NULL;
    }

    /* Add CA chain */
    if (cachain) {
        for (int i = sk_X509_INFO_num(cachain) - 1; i >= 0; i--) {
            X509_INFO *inf = sk_X509_INFO_value(cachain, i);
            if (inf && inf->x509) {
                X509 *cert_copy = X509_dup(inf->x509);
                if (!cert_copy || !SSL_CTX_add_extra_chain_cert(sslctx, cert_copy)) {
                    X509_free(cert_copy);
                    SSL_CTX_free(sslctx);
#ifdef DEBUG
                    log_msg(LGG_ERR, "%s: cannot add CA cert %d", __FUNCTION__, i);
#endif
                    return NULL;
                }
            }
        }
    }

    return sslctx;
}

SSL_CTX* create_default_sslctx(const char *pem_dir)
{
    if (g_sslctx) return g_sslctx;

    g_sslctx = SSL_CTX_new(TLS_server_method());
    if (!g_sslctx) {
#ifdef DEBUG
        log_msg(LGG_ERR, "Failed to create default SSL context");
#endif
        return NULL;
    }

    long options = SSL_OP_NO_COMPRESSION |
                   SSL_OP_NO_SSLv2 |
                   SSL_OP_NO_SSLv3 |
                   SSL_OP_CIPHER_SERVER_PREFERENCE;

#ifdef SSL_MODE_RELEASE_BUFFERS
    options |= SSL_MODE_RELEASE_BUFFERS;
#endif

#ifdef SSL_OP_NO_TLSv1_1
    options |= SSL_OP_NO_TLSv1_1;
#endif

    SSL_CTX_set_options(g_sslctx, options);
    SSL_CTX_sess_set_cache_size(g_sslctx, PIXEL_SSL_SESS_CACHE_SIZE);
    SSL_CTX_set_session_cache_mode(g_sslctx, SSL_SESS_CACHE_SERVER);
    SSL_CTX_set_timeout(g_sslctx, PIXEL_SSL_SESS_TIMEOUT);

    if (SSL_CTX_set_cipher_list(g_sslctx, PIXELSERV_CIPHER_LIST) <= 0) {
#ifdef DEBUG
        log_msg(LGG_DEBUG, "cipher_list cannot be set");
#endif
    }

#ifdef TLS1_3_VERSION
    SSL_CTX_set_max_early_data(g_sslctx, PIXEL_TLS_EARLYDATA_SIZE);
    SSL_CTX_set_client_hello_cb(g_sslctx, tls_clienthello_cb, NULL);
#else
    SSL_CTX_set_tlsext_servername_callback(g_sslctx, tls_servername_cb);
#endif

    return g_sslctx;
}

int is_ssl_conn(int fd, char *srv_ip, int srv_ip_len, const int *ssl_ports, int num_ssl_ports) {
    char server_ip[INET6_ADDRSTRLEN] = {'\0'};
    struct sockaddr_storage sin_addr;
    socklen_t sin_addr_len = sizeof(sin_addr);
    char port[NI_MAXSERV] = {'\0'};
    int rv = 0;

    if (getsockname(fd, (struct sockaddr*)&sin_addr, &sin_addr_len) != 0 ||
        getnameinfo((struct sockaddr *)&sin_addr, sin_addr_len,
                   server_ip, sizeof server_ip,
                   port, sizeof port,
                   NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "getnameinfo: %s", strerror(errno));
#endif
        return 0;
    }
    
    if (srv_ip && srv_ip_len > 0) {
        strncpy(srv_ip, server_ip, srv_ip_len - 1);
        srv_ip[srv_ip_len - 1] = '\0';
    }
    
    int port_num = atoi(port);
    for (int i = 0; i < num_ssl_ports; i++) {
        if (port_num == ssl_ports[i]) {
            rv = ssl_ports[i];
            break;
        }
    }

#ifdef DEBUG
    char client_ip[INET6_ADDRSTRLEN] = {'\0'};
    getpeername(fd, (struct sockaddr*)&sin_addr, &sin_addr_len);
    if (getnameinfo((struct sockaddr *)&sin_addr, sin_addr_len, client_ip,
                   sizeof client_ip, NULL, 0, NI_NUMERICHOST) == 0) {
        log_msg(LGG_DEBUG, "** NEW CONNECTION ** %s:%s", client_ip, port);
    }
#endif

    return rv;
}

#ifdef TLS1_3_VERSION
char* read_tls_early_data(SSL *ssl, int *err)
{
    size_t buf_siz = PIXEL_TLS_EARLYDATA_SIZE;
    char *buf = malloc(PIXEL_TLS_EARLYDATA_SIZE + 1);
    if (!buf) {
#ifdef DEBUG
        log_msg(LGG_DEBUG, "%s out of memory", __FUNCTION__);
#endif
        *err = SSL_ERROR_SYSCALL;
        return NULL;
    }

    char *pbuf = buf;
    int count = 0;
    *err = SSL_ERROR_NONE;

    for (;;) {
        size_t readbytes = 0;
        ERR_clear_error();
        int rv = SSL_read_early_data(ssl, pbuf, buf_siz, &readbytes);

        if (rv == SSL_READ_EARLY_DATA_FINISH) {
            if (buf == pbuf && readbytes == 0) {
                goto err_quit;
            } else {
                pbuf += readbytes;
                *pbuf = '\0';
            }
            break;
        } else if (rv == SSL_READ_EARLY_DATA_SUCCESS) {
            pbuf += readbytes;
            buf_siz -= readbytes;
            if (buf_siz <= 0) {
#ifdef DEBUG
                log_msg(LGG_DEBUG, "%s buffer full", __FUNCTION__);
#endif
                goto err_quit;
            }
            continue;
        }

        /* SSL_READ_EARLY_DATA_ERROR */
        switch (SSL_get_error(ssl, 0)) {
        case SSL_ERROR_WANT_WRITE:
        case SSL_ERROR_WANT_READ:
        case SSL_ERROR_WANT_ASYNC:
            if (count++ < 10) { /* 600ms total */
                struct timespec delay = {0, 60000000}; /* 60ms */
                nanosleep(&delay, NULL);
                continue;
            }
            /* fall through */
        default:
            *err = SSL_get_error(ssl, 0);
#ifdef DEBUG
            log_msg(LGG_DEBUG, "%s error: %d count: %d", __FUNCTION__, *err, count);
#endif
            goto err_quit;
        }
    }

#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s buf: %s", __FUNCTION__, buf);
#endif

    return buf;

err_quit:
    free(buf);
    return NULL;
}
#endif

void run_benchmark(const cert_tlstor_t *ct, const char *cert)
{
    if (!ct || !ct->pem_dir) {
#ifdef DEBUG
        log_msg(LGG_ERR, "Invalid certificate storage or pem_dir");
#endif
        return;
    }

    char *cert_file = NULL, *domain = NULL;
    struct stat st;
    struct timespec tm;
    float r_tm0 = 0.0, g_tm0 = 0.0, tm1;
    SSL_CTX *sslctx = NULL;

    printf("CERT_PATH: %s\n", ct->pem_dir);
    if (!ct->cachain) {
        printf("CA chain not loaded\n");
        goto quit;
    }

    const char *test_cert = cert ? cert : "_.bing.com";
    printf("CERT_FILE: ");
    
    if (asprintf(&cert_file, "%s/%s", ct->pem_dir, test_cert) < 0) {
        printf("Memory allocation failed\n");
        goto quit;
    }

    if (cert && stat(cert_file, &st) != 0) {
        printf("%s not found\n", cert);
        goto quit;
    }
    printf("%s\n", test_cert);

    if (asprintf(&domain, "%s", test_cert) < 0) {
        printf("Memory allocation failed for domain\n");
        goto quit;
    }
    
    if (domain[0] == '_') domain[0] = '*';

    /* Benchmark certificate generation and loading */
    for (int c = 1; c <= 10; c++) {
        get_time(&tm);
        for (int d = 0; d < 5; d++) {
            generate_cert(domain, ct->pem_dir, ct->issuer, ct->privkey, ct->cachain);
        }
        tm1 = (float)elapsed_time_msec(tm) / 5.0;
        printf("%2d. generate cert to disk: %.3f ms\t", c, tm1);
        g_tm0 += tm1;

        get_time(&tm);
        for (int d = 0; d < 5; d++) {
            if (stat(cert_file, &st) == 0) {
                sslctx = create_child_sslctx(cert_file, ct->cachain);
                if (sslctx) {
                    sslctx_tbl_cache(test_cert, sslctx, 0);
                } else {
#ifdef DEBUG
                    log_msg(LGG_WARNING, "Failed to create SSL context for %s", cert_file);
#endif
                }
            }
        }
        tm1 = (float)elapsed_time_msec(tm) / 5.0;
        printf("load from disk: %.3f ms\n", tm1);
        r_tm0 += tm1;
    }
    
    printf("generate to disk average: %.3f ms\n", g_tm0 / 10.0);
    printf("  load from disk average: %.3f ms\n", r_tm0 / 10.0);

quit:
    free(cert_file);
    free(domain);
}
/*
 * src/ssl/ssl_init.c - SSL Context Management and TLS Callbacks
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509v3.h>
#include <openssl/opensslv.h>
#include "../ssl/ssl_config.h"
#include "../ssl/ssl_modules.h"
#include "../log/logger.h"
#include "../util/util.h"

SSL_CTX *g_sslctx;

#if defined(__GLIBC__) && !defined(__UCLIBC__)
#  include <malloc.h>
#endif

/* Legacy threading support for older OpenSSL versions */
#if !OPENSSL_API_1_1
static pthread_mutex_t *locks;
#endif

/* WILDCARD IP FUNCTIONS */
/* Enhanced IP detection */
int is_ip_address(const char *addr) {
    struct sockaddr_in sa4;
    struct sockaddr_in6 sa6;
    
    if (inet_pton(AF_INET, addr, &(sa4.sin_addr)) == 1) return 4;
    if (inet_pton(AF_INET6, addr, &(sa6.sin6_addr)) == 1) return 6;
    return 0;
}

/* Generate universal catch-all certificate for all IPs */
void generate_universal_ip_cert(const char *pem_dir,
                                      X509_NAME *issuer,
                                      EVP_PKEY *privkey,
                                      const STACK_OF(X509_INFO) *cachain)
{
    char fname[PIXELSERV_MAX_PATH];
    EVP_PKEY *key = NULL;
    X509 *x509 = NULL;
    X509_EXTENSION *ext = NULL;
    EVP_MD_CTX *p_ctx = NULL;
    
    /* Mega SAN for all common IPs */
    char mega_san[2048];
    strcpy(mega_san, 
        "IP:127.0.0.1,IP:127.0.0.254,"           /* localhost */
        "IP:10.0.0.1,IP:10.255.255.254,"         /* 10.x.x.x */
        "IP:192.168.0.1,IP:192.168.255.254,"     /* 192.168.x.x */
        "IP:172.16.0.1,IP:172.31.255.254,"       /* 172.16-31.x.x */
        "IP:192.168.1.1,IP:192.168.0.1,IP:10.0.0.1," /* common routers */
        "DNS:localhost,DNS:*.local,DNS:*.lan"
    );

#if OPENSSL_API_1_1
    p_ctx = EVP_MD_CTX_new();
#else
    p_ctx = EVP_MD_CTX_create();
#endif
    if (!p_ctx || EVP_DigestSignInit(p_ctx, NULL, EVP_sha256(), NULL, privkey) != 1) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to init sign context", __FUNCTION__);
#endif
        goto free_all;
    }

    /* Generate key pair */
#if OPENSSL_VERSION_NUMBER >= 0x30000000L
    /* OpenSSL 3.0+ */
    key = EVP_RSA_gen(2048);
    if (!key) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to generate RSA key", __FUNCTION__);
#endif
        goto free_all;
    }
#elif OPENSSL_API_1_1
    /* OpenSSL 1.1.x */
    key = EVP_PKEY_new();
    if (!key) goto free_all;
    
    EVP_PKEY_CTX *pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    if (!pkey_ctx) goto free_all;
    
    if (EVP_PKEY_keygen_init(pkey_ctx) <= 0 ||
        EVP_PKEY_CTX_set_rsa_keygen_bits(pkey_ctx, 2048) <= 0 ||
        EVP_PKEY_keygen(pkey_ctx, &key) <= 0) {
        EVP_PKEY_CTX_free(pkey_ctx);
        goto free_all;
    }
    EVP_PKEY_CTX_free(pkey_ctx);
#else
    /* Legacy OpenSSL */
    BIGNUM *e = BN_new();
    if (!e) goto free_all;
    BN_set_word(e, RSA_F4);
    
    RSA *rsa = RSA_new();
    if (!rsa || RSA_generate_key_ex(rsa, 2048, e, NULL) < 0) {
        BN_free(e);
        RSA_free(rsa);
        goto free_all;
    }
    BN_free(e);
    
    key = EVP_PKEY_new();
    if (!key || !EVP_PKEY_assign_RSA(key, rsa)) {
        RSA_free(rsa);
        goto free_all;
    }
#endif

    /* Create certificate */
    x509 = X509_new();
    if (!x509) goto free_all;
    
    ASN1_INTEGER_set(X509_get_serialNumber(x509), rand());
    X509_set_version(x509, 2); /* X509 v3 */
    
    /* Random NotBefore date between -864000 and -172800 seconds */
    int offset = -(rand() % (864000 - 172800 + 1) + 172800);
    X509_gmtime_adj(X509_get_notBefore(x509), offset);
    X509_gmtime_adj(X509_get_notAfter(x509), 3600*24*390L); /* 390 days */
    
    X509_set_issuer_name(x509, issuer);
    X509_NAME *name = X509_get_subject_name(x509);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, (unsigned char *)"*.universal.ip", -1, -1, 0);

    /* Add the mega SAN extension */
    ext = X509V3_EXT_conf_nid(NULL, NULL, NID_subject_alt_name, mega_san);
    if (!ext) goto free_all;
    X509_add_ext(x509, ext, -1);
    X509_EXTENSION_free(ext);
    ext = NULL;
    
    ext = X509V3_EXT_conf_nid(NULL, NULL, NID_ext_key_usage, "TLS Web Server Authentication");
    if (!ext) goto free_all;
    X509_add_ext(x509, ext, -1);
    
    X509_set_pubkey(x509, key);
    X509_sign_ctx(x509, p_ctx);

    /* Save certificate to file */
    snprintf(fname, PIXELSERV_MAX_PATH, "%s/universal_ips.pem", pem_dir);
    
    FILE *fp = fopen(fname, "wb");
    if (!fp) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to open file for write: %s", __FUNCTION__, fname);
#endif
        goto free_all;
    }

    /* Write certificate */
    PEM_write_X509(fp, x509);

    /* Write CA chain */
    if (cachain) {
        for (int i = 0; i < sk_X509_INFO_num(cachain); i++) {
            X509_INFO *xi = sk_X509_INFO_value(cachain, i);
            if (xi && xi->x509) {
                PEM_write_X509(fp, xi->x509);
            }
        }
    }

    /* Write private key */
    PEM_write_PrivateKey(fp, key, NULL, NULL, 0, NULL, NULL);
    fclose(fp);
    
#ifdef DEBUG
    log_msg(LGG_NOTICE, "ðŸ”’ Universal IP certificate generated: %s", fname);
#endif

free_all:
    EVP_PKEY_free(key);
    X509_EXTENSION_free(ext);
    X509_free(x509);
    if (p_ctx) {
#if OPENSSL_API_1_1
        EVP_MD_CTX_free(p_ctx);
#else
        EVP_MD_CTX_destroy(p_ctx);
#endif
    }
}

/* Certificate worker thread */
void *cert_worker(void *arg) {
    cert_tlstor_t *ct = (cert_tlstor_t *)arg;
    
    while (!cert_workers_shutdown) {
        pthread_mutex_lock(&cert_q_lock);
        while (!cert_q_head && !cert_workers_shutdown) {
            pthread_cond_wait(&cert_q_cond, &cert_q_lock);
        }
        
        if (cert_workers_shutdown) {
            pthread_mutex_unlock(&cert_q_lock);
            break;
        }
        
        cert_job_t *job = cert_q_head;
        cert_q_head = job->next;
        if (!cert_q_head) cert_q_tail = NULL;
        pthread_mutex_unlock(&cert_q_lock);

        /* Generate certificate */
        generate_cert(job->cert_name, ct->pem_dir, ct->issuer, ct->privkey, ct->cachain);
        
        free(job);
    }
    return NULL;
}

/* OpenSSL threading functions - only for legacy versions */
#if !OPENSSL_API_1_1
static void ssl_lock_cb(int mode, int type, const char *file, int line)
{
    if (mode & CRYPTO_LOCK)
        pthread_mutex_lock(&(locks[type]));
    else
        pthread_mutex_unlock(&(locks[type]));
}

static void ssl_thread_id(CRYPTO_THREADID *id)
{
    CRYPTO_THREADID_set_numeric(id, (unsigned long) pthread_self());
}
#endif

void ssl_init_locks()
{
#if !OPENSSL_API_1_1
    int num_locks = CRYPTO_num_locks();
#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: CRYPTO_num_locks = %d", __FUNCTION__, num_locks);
#endif
    locks = OPENSSL_malloc(num_locks * sizeof(pthread_mutex_t));
    if (!locks) {
#ifdef DEBUG
        log_msg(LGG_ERR, "Failed to allocate SSL locks");
#endif
        return;
    }
    
    for (int i = 0; i < num_locks; i++) {
        pthread_mutex_init(&(locks[i]), NULL);
    }

    CRYPTO_THREADID_set_callback(ssl_thread_id);
    CRYPTO_set_locking_callback(ssl_lock_cb);
#else
    /* OpenSSL 1.1.0+ handles threading automatically */
#ifdef DEBUG
    log_msg(LGG_DEBUG, "Using OpenSSL 1.1.0+ automatic threading");
#endif
#endif
}

void ssl_free_locks()
{
#if !OPENSSL_API_1_1
    if (!locks) return;
    
    CRYPTO_set_locking_callback(NULL);
    int num_locks = CRYPTO_num_locks();
    for (int i = 0; i < num_locks; i++) {
        pthread_mutex_destroy(&(locks[i]));
    }
    OPENSSL_free(locks);
    locks = NULL;
#endif
}

void generate_cert(const char* cert_name,
                          const char *pem_dir,
                          X509_NAME *issuer,
                          EVP_PKEY *privkey,
                          const STACK_OF(X509_INFO) *cachain)
{
    char fname[PIXELSERV_MAX_PATH];
    EVP_PKEY *key = NULL;
    X509 *x509 = NULL;
    X509_EXTENSION *ext = NULL;
    char san_str[PIXELSERV_MAX_SERVER_NAME + 4];
    EVP_MD_CTX *p_ctx = NULL;
    char *pem_fn = NULL;
    
    /* Make a copy since we might modify it */
    pem_fn = strdup(cert_name);
    if (!pem_fn) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to allocate memory for cert name", __FUNCTION__);
#endif
        return;
    }

#if OPENSSL_API_1_1
    p_ctx = EVP_MD_CTX_new();
#else
    p_ctx = EVP_MD_CTX_create();
#endif
    if (!p_ctx || EVP_DigestSignInit(p_ctx, NULL, EVP_sha256(), NULL, privkey) != 1) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to init sign context", __FUNCTION__);
#endif
        goto free_all;
    }

    if (pem_fn[0] == '_') pem_fn[0] = '*';

    /* Generate key pair */
#if OPENSSL_VERSION_NUMBER >= 0x30000000L
    /* OpenSSL 3.0+ */
    key = EVP_RSA_gen(2048);
    if (!key) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to generate RSA key", __FUNCTION__);
#endif
        goto free_all;
    }
#elif OPENSSL_API_1_1
    /* OpenSSL 1.1.x */
    key = EVP_PKEY_new();
    if (!key) goto free_all;
    
    EVP_PKEY_CTX *pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    if (!pkey_ctx) goto free_all;
    
    if (EVP_PKEY_keygen_init(pkey_ctx) <= 0 ||
        EVP_PKEY_CTX_set_rsa_keygen_bits(pkey_ctx, 2048) <= 0 ||
        EVP_PKEY_keygen(pkey_ctx, &key) <= 0) {
        EVP_PKEY_CTX_free(pkey_ctx);
        goto free_all;
    }
    EVP_PKEY_CTX_free(pkey_ctx);
#else
    /* Legacy OpenSSL */
    BIGNUM *e = BN_new();
    if (!e) goto free_all;
    BN_set_word(e, RSA_F4);
    
    RSA *rsa = RSA_new();
    if (!rsa || RSA_generate_key_ex(rsa, 2048, e, NULL) < 0) {
        BN_free(e);
        RSA_free(rsa);
        goto free_all;
    }
    BN_free(e);
    
    key = EVP_PKEY_new();
    if (!key || !EVP_PKEY_assign_RSA(key, rsa)) {
        RSA_free(rsa);
        goto free_all;
    }
#endif

#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: RSA key generated for [%s]", __FUNCTION__, pem_fn);
#endif

    /* Create certificate */
    x509 = X509_new();
    if (!x509) goto free_all;
    
    ASN1_INTEGER_set(X509_get_serialNumber(x509), rand());
    X509_set_version(x509, 2); /* X509 v3 */
    
    /* Random NotBefore date between -864000 and -172800 seconds */
    int offset = -(rand() % (864000 - 172800 + 1) + 172800);
    X509_gmtime_adj(X509_get_notBefore(x509), offset);
    X509_gmtime_adj(X509_get_notAfter(x509), 3600*24*390L); /* 390 days */
    
    X509_set_issuer_name(x509, issuer);
    X509_NAME *name = X509_get_subject_name(x509);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, (unsigned char *)pem_fn, -1, -1, 0);

    /* Enhanced IP detection instead of the dot counting logic */
    int ip_version = is_ip_address(pem_fn);
    if (ip_version > 0) {
        snprintf(san_str, sizeof(san_str), "IP:%s", pem_fn);
#ifdef DEBUG
        log_msg(LGG_DEBUG, "Detected IPv%d address: %s", ip_version, pem_fn);
#endif
    } else {
        snprintf(san_str, sizeof(san_str), "DNS:%s", pem_fn);
#ifdef DEBUG
        log_msg(LGG_DEBUG, "Detected domain name: %s", pem_fn);
#endif
    }
    
    ext = X509V3_EXT_conf_nid(NULL, NULL, NID_subject_alt_name, san_str);
    if (!ext) goto free_all;
    X509_add_ext(x509, ext, -1);
    X509_EXTENSION_free(ext);
    ext = NULL;
    
    ext = X509V3_EXT_conf_nid(NULL, NULL, NID_ext_key_usage, "TLS Web Server Authentication");
    if (!ext) goto free_all;
    X509_add_ext(x509, ext, -1);
    
    X509_set_pubkey(x509, key);
    X509_sign_ctx(x509, p_ctx);

#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: X509 cert created", __FUNCTION__);
#endif

    /* Save certificate to file */
    if (pem_fn[0] == '*') pem_fn[0] = '_';
    snprintf(fname, PIXELSERV_MAX_PATH, "%s/%s", pem_dir, pem_fn);
    
    FILE *fp = fopen(fname, "wb");
    if (!fp) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to open file for write: %s", __FUNCTION__, fname);
#endif
        goto free_all;
    }

    /* Write certificate */
    PEM_write_X509(fp, x509);

    /* Write CA chain */
    if (cachain) {
        for (int i = 0; i < sk_X509_INFO_num(cachain); i++) {
            X509_INFO *xi = sk_X509_INFO_value(cachain, i);
            if (xi && xi->x509) {
                PEM_write_X509(fp, xi->x509);
            }
        }
    }

    /* Write private key */
    PEM_write_PrivateKey(fp, key, NULL, NULL, 0, NULL, NULL);
    fclose(fp);
    
#ifdef DEBUG
    log_msg(LGG_NOTICE, "cert generated to disk: %s", pem_fn);
#endif

free_all:
    free(pem_fn);
    EVP_PKEY_free(key);
    X509_EXTENSION_free(ext);
    X509_free(x509);
    if (p_ctx) {
#if OPENSSL_API_1_1
        EVP_MD_CTX_free(p_ctx);
#else
        EVP_MD_CTX_destroy(p_ctx);
#endif
    }
}

int pem_passwd_cb(char *buf, int size, int rwflag, void *u) {
    int rv = 0, fp;
    char *fname = NULL;
    
    if (asprintf(&fname, "%s/rootCA/ca.key.passphrase", (char*)u) < 0)
        goto quit_cb;

    if ((fp = open(fname, O_RDONLY)) < 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to open ca.key.passphrase", __FUNCTION__);
#endif
    } else {
        rv = read(fp, buf, size - 1);
        close(fp);
        if (rv > 0 && buf[rv-1] == '\n') {
            rv--; /* trim newline */
        }
        if (rv > 0) buf[rv] = '\0';
#ifdef DEBUG
        log_msg(LGG_DEBUG, "%s: passphrase length %d", __FUNCTION__, rv);
#endif
    }

quit_cb:
    free(fname);
    return rv;
}

void cert_tlstor_init(const char *pem_dir, cert_tlstor_t *ct)
{
    FILE *fp = NULL;
    char cert_file[PIXELSERV_MAX_PATH];
    X509 *x509 = NULL;

    memset(ct, 0, sizeof(cert_tlstor_t));
    
    /* Load CA certificate */
    snprintf(cert_file, PIXELSERV_MAX_PATH, "%s/rootCA/ca.crt", pem_dir);
    fp = fopen(cert_file, "r");
    x509 = X509_new();

    if (!fp || !x509 || !PEM_read_X509(fp, &x509, NULL, NULL)) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to load ca.crt", __FUNCTION__);
#endif
        goto cleanup_ca;
    }

    /* Read entire CA file for chain */
    char *cafile = NULL;
    long fsz;
    
    if (fseek(fp, 0L, SEEK_END) < 0 || (fsz = ftell(fp)) < 0 || fseek(fp, 0L, SEEK_SET) < 0) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to seek ca.crt", __FUNCTION__);
#endif
        goto cleanup_ca;
    }

    cafile = malloc(fsz + 1);
    if (!cafile || fread(cafile, 1, fsz, fp) != (size_t)fsz) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to read ca.crt", __FUNCTION__);
#endif
        free(cafile);
        goto cleanup_ca;
    }

    BIO *bioin = BIO_new_mem_buf(cafile, fsz);
    if (!bioin) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to create BIO mem buffer", __FUNCTION__);
#endif
        free(cafile);
        goto cleanup_ca;
    }

    ct->pem_dir = pem_dir;
    ct->cachain = PEM_X509_INFO_read_bio(bioin, NULL, NULL, NULL);
    ct->issuer = X509_NAME_dup(X509_get_subject_name(x509));

    if (!ct->cachain) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to read CA chains", __FUNCTION__);
#endif
    }

    BIO_free(bioin);
    free(cafile);

cleanup_ca:
    if (fp) fclose(fp);
    X509_free(x509);

    /* Load CA private key */
    snprintf(cert_file, PIXELSERV_MAX_PATH, "%s/rootCA/ca.key", pem_dir);
    fp = fopen(cert_file, "r");
    if (!fp || !PEM_read_PrivateKey(fp, &ct->privkey, pem_passwd_cb, (void*)pem_dir)) {
#ifdef DEBUG
        log_msg(LGG_ERR, "%s: failed to load ca.key", __FUNCTION__);
#endif
    }
    if (fp) fclose(fp);

    /* Generate universal IP certificate on startup */
    char universal_ip_file[PIXELSERV_MAX_PATH];
    snprintf(universal_ip_file, sizeof(universal_ip_file), "%s/universal_ips.pem", pem_dir);
    struct stat st;
    if (stat(universal_ip_file, &st) != 0 && ct->privkey && ct->issuer) {
        generate_universal_ip_cert(pem_dir, ct->issuer, ct->privkey, ct->cachain);
    }

    /* Start worker threads for certificate generation */
    cert_workers_shutdown = 0;
    for (int i = 0; i < 4; i++) {
        pthread_t tid;
        if (pthread_create(&tid, NULL, cert_worker, ct) == 0) {
            pthread_detach(tid);
        } else {
#ifdef DEBUG
            log_msg(LGG_ERR, "cert_worker: pthread_create failed");
#endif
        }
    }
}

void cert_tlstor_cleanup(cert_tlstor_t *c)
{
    if (!c) return;
    
    shutdown_cert_workers();
    
    sk_X509_INFO_pop_free(c->cachain, X509_INFO_free);
    X509_NAME_free(c->issuer);
    EVP_PKEY_free(c->privkey);
    
    memset(c, 0, sizeof(*c));
}

void *cert_generator(void *ptr) {
#ifdef DEBUG
    log_msg(LGG_DEBUG, "%s: thread up and running", __FUNCTION__);
#endif
    int idle = 0;
    cert_tlstor_t *ct = (cert_tlstor_t *) ptr;

    char buf[PIXELSERV_MAX_SERVER_NAME * 4 + 1];
    char *half_token = buf + PIXELSERV_MAX_SERVER_NAME * 4;
    buf[PIXELSERV_MAX_SERVER_NAME * 4] = '\0';

    int fd = open(pixel_cert_pipe, O_RDONLY | O_NONBLOCK);
    srand((unsigned int)time(NULL));

    while (!cert_workers_shutdown) {
        if (fd == -1) {
#ifdef DEBUG
            log_msg(LGG_ERR, "%s: failed to open %s: %s", __FUNCTION__, pixel_cert_pipe, strerror(errno));
#endif
            sleep(1);
            fd = open(pixel_cert_pipe, O_RDONLY | O_NONBLOCK);
            continue;
        }
        
        strcpy(buf, half_token);
        struct pollfd pfd = { fd, POLLIN, 0 };
        int ret = poll(&pfd, 1, 1000 * PIXEL_SSL_SESS_TIMEOUT / 4);
        
        if (ret <= 0) {
            /* timeout */
            sslctx_tbl_check_and_flush();
            if (kcc == 0) {
                if (++idle >= (3600 / (PIXEL_SSL_SESS_TIMEOUT / 4))) {
                    conn_stor_flush();
                    idle = 0;
                }
#if defined(__GLIBC__) && !defined(__UCLIBC__)
                malloc_trim(0);
#endif
            }
            continue;
        }
        
        ssize_t cnt = read(fd, buf + strlen(half_token), PIXELSERV_MAX_SERVER_NAME * 4 - strlen(half_token));
        if (cnt == 0) {
#ifdef DEBUG
            log_msg(LGG_DEBUG, "%s: pipe EOF", __FUNCTION__);
#endif
            close(fd);
            fd = open(pixel_cert_pipe, O_RDONLY | O_NONBLOCK);
            continue;
        }
        
        if (cnt < 0) continue;
        
        if ((size_t)cnt < PIXELSERV_MAX_SERVER_NAME * 4 - strlen(half_token)) {
            buf[cnt + strlen(half_token)] = '\0';
            half_token = buf + PIXELSERV_MAX_SERVER_NAME * 4;
        } else {
            size_t i = 1;
            for (i = 1; buf[PIXELSERV_MAX_SERVER_NAME * 4 - i] != ':' && i < strlen(buf); i++);
            half_token = buf + PIXELSERV_MAX_SERVER_NAME * 4 - i + 1;
            buf[PIXELSERV_MAX_SERVER_NAME * 4 - i + 1] = '\0';
        }
        
        if (!ct->privkey || !ct->issuer) continue;
        
        char *p_buf, *p_buf_sav = NULL;
        p_buf = strtok_r(buf, ":", &p_buf_sav);
        while (p_buf != NULL) {
            char cert_file[PIXELSERV_MAX_PATH];
            struct stat st;
            snprintf(cert_file, PIXELSERV_MAX_PATH, "%s/%s", ct->pem_dir, p_buf);
            
            if (stat(cert_file, &st) != 0) { /* doesn't exist */
                enqueue_cert_job(p_buf);
            }
            p_buf = strtok_r(NULL, ":", &p_buf_sav);
        }
        
        sslctx_tbl_check_and_flush();
    }
    
    if (fd >= 0) close(fd);
    return NULL;
}
/*
 * src/ssl/ssl_config.h - SSL Configuration and Declarations
 */

#ifndef _SSL_CONFIG_H_
#define _SSL_CONFIG_H_

#include <arpa/inet.h>
#include <openssl/pem.h>
#include <openssl/ssl.h>
#include <openssl/opensslv.h>

/* OpenSSL version compatibility */
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
#define OPENSSL_API_1_1 1
#else
#define OPENSSL_API_1_1 0
#endif

#define PIXEL_SSL_SESS_CACHE_SIZE 128*20
#define PIXEL_SSL_SESS_TIMEOUT 30 /* seconds - HTTPS Session LÃ¤nge fÃ¼r AdBlock optimiert */
#define PIXEL_TLS_EARLYDATA_SIZE 16384

#ifndef DEFAULT_PEM_PATH
#define DEFAULT_PEM_PATH "/opt/var/cache/pixelserv"
#endif

#define PIXELSERV_MAX_PATH 1024
#define PIXELSERV_MAX_SERVER_NAME 255

extern char pixel_cert_pipe[PIXELSERV_MAX_PATH];

/* Updated cipher lists for modern TLS */
#define PIXELSERV_CIPHER_LIST \
  "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:" \
  "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:" \
  "ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:" \
  "ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:" \
  "DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256:" \
  "DHE-RSA-AES128-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA"

#define PIXELSERV_TLSV1_3_CIPHERS \
  "TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256"

/* Certificate storage structure */
typedef struct {
    const char* pem_dir;
    STACK_OF(X509_INFO) *cachain;
    X509_NAME *issuer;
    EVP_PKEY *privkey;
} cert_tlstor_t;

/* SSL status enumeration */
typedef enum {
    SSL_NOT_TLS,
    SSL_ERR,
    SSL_MISS,
    SSL_HIT,
    SSL_HIT_CLS,
    SSL_HIT_RTT0,
    SSL_UNKNOWN
} ssl_enum;

/* TLS extension callback argument structure */
typedef struct {
    const char *tls_pem;
    const STACK_OF(X509_INFO) *cachain;
    char servername[65]; /* max legal domain name 63 chars; INET6_ADDRSTRLEN 46 bytes */
    char server_ip[INET6_ADDRSTRLEN];
    ssl_enum status;
    int sslctx_idx;
} tlsext_cb_arg_struct;

/* Connection TLS storage structure */
typedef struct {
    int new_fd;
    SSL *ssl;
    double init_time;
    tlsext_cb_arg_struct *tlsext_cb_arg;
    int allow_admin;
    char *early_data;
    tlsext_cb_arg_struct v;
} conn_tlstor_struct;

/* SSL context cache structure - optimized with atomic operations */
typedef struct {
    int alloc_len;
    char *cert_name;
    unsigned int last_use; /* seconds since process up - made atomic in implementation */
    int reuse_count;       /* made atomic in implementation */
    SSL_CTX *sslctx;
    pthread_mutex_t lock;  /* Keep individual locks for SSL_CTX operations */
} sslctx_cache_struct;

/* Global SSL context */
extern SSL_CTX *g_sslctx;

/* External variables from util.h/main */
extern char pixel_cert_pipe[PIXELSERV_MAX_PATH];
extern volatile sig_atomic_t kcc;

/* Function from util.h */
unsigned int process_uptime(void);
double elapsed_time_msec(const struct timespec start_time);
void get_time(struct timespec *tm);

#define CONN_TLSTOR(p, e) ((conn_tlstor_struct*)p)->e

/* Function declarations */
void ssl_init_locks(void);
void ssl_free_locks(void);
void cert_tlstor_init(const char *pem_dir, cert_tlstor_t *c);
void cert_tlstor_cleanup(cert_tlstor_t *c);
void *cert_generator(void *ptr);

/* SSL context table management */
void sslctx_tbl_init(int tbl_size);
void sslctx_tbl_cleanup(void);
void sslctx_tbl_load(const char* pem_dir, const STACK_OF(X509_INFO) *cachain);
void sslctx_tbl_save(const char* pem_dir);
void sslctx_tbl_lock(int idx);
void sslctx_tbl_unlock(int idx);

/* Statistics functions - now with atomic operations */
int sslctx_tbl_get_cnt_total(void);
int sslctx_tbl_get_cnt_hit(void);
int sslctx_tbl_get_cnt_miss(void);
int sslctx_tbl_get_cnt_purge(void);
int sslctx_tbl_get_sess_cnt(void);
int sslctx_tbl_get_sess_hit(void);
int sslctx_tbl_get_sess_miss(void);
int sslctx_tbl_get_sess_purge(void);

/* SSL context creation and management */
SSL_CTX *create_default_sslctx(const char *pem_dir);
SSL_CTX *create_child_sslctx(const char* full_pem_path, const STACK_OF(X509_INFO) *cachain);
int is_ssl_conn(int fd, char *srv_ip, int srv_ip_len, const int *ssl_ports, int num_ssl_ports);

/* Connection storage management - keep original API */
void conn_stor_init(int slots);
void conn_stor_relinq(conn_tlstor_struct *p);
conn_tlstor_struct* conn_stor_acquire(void);
void conn_stor_flush(void);

/* TLS 1.3 specific functions */
#ifdef TLS1_3_VERSION
int tls_clienthello_cb(SSL *ssl, int *ad, void *arg);
char* read_tls_early_data(SSL *ssl, int *err);
#endif

/* Benchmark function */
void run_benchmark(const cert_tlstor_t *ct, const char *cert);

/* Internal SSL context table functions */
int sslctx_tbl_lookup(const char* cert_name, int* found_idx, int* ins_idx);
int sslctx_tbl_cache(const char *cert_name, SSL_CTX *sslctx, int ins_idx);
int sslctx_tbl_purge(int idx);
int sslctx_tbl_check_and_flush(void);

/* Debug function */
#ifdef DEBUG
void sslctx_tbl_dump(int idx, const char *func);
#endif

/* Certificate generation functions */
void generate_cert(const char *cert_name,
                   const char *pem_dir,
                   X509_NAME *issuer,
                   EVP_PKEY *privkey,
                   const STACK_OF(X509_INFO) *cachain);

void generate_universal_ip_cert(const char *pem_dir,
                               X509_NAME *issuer,
                               EVP_PKEY *privkey,
                               const STACK_OF(X509_INFO) *cachain);

/* Worker thread functions */
void *cert_worker(void *arg);
void shutdown_cert_workers(void);
void enqueue_cert_job(const char *cert_name);

/* Utility functions */
int is_ip_address(const char *addr);
int pem_passwd_cb(char *buf, int size, int rwflag, void *u);

/* Additional utility functions */
SSL_CTX* sslctx_tbl_get_ctx(const char *cert_name);
int validate_certificate_chain(SSL_CTX *ctx);
int check_cert_expiration(const char *cert_path, time_t *expires_at);
void log_ssl_errors(const char *operation);
void sslctx_tbl_cleanup_expired(void);
size_t sslctx_tbl_memory_usage(void);
void pregenerate_common_certs(cert_tlstor_t *ct);
void print_cert_statistics(void);

#endif /* _SSL_CONFIG_H_ */
/*
 * src/ssl/ssl_modules.h - SSL Context Management and TLS Callbacks
 */

#ifndef _SSL_MODULES_H_
#define _SSL_MODULES_H_

#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/x509v3.h>
#include <openssl/opensslv.h>
#include "../ssl/ssl_config.h"

/* Job Queue for parallel certificate generation */
typedef struct cert_job {
    char cert_name[PIXELSERV_MAX_SERVER_NAME+1];
    struct cert_job *next;
} cert_job_t;

/* Internal macros */
#define SSLCTX_TBL_ptr(h)         ((sslctx_cache_struct *)(sslctx_tbl + h))
#define SSLCTX_TBL_get(h, k)      SSLCTX_TBL_ptr(h)->k
#define SSLCTX_TBL_set(h, k, v)   SSLCTX_TBL_ptr(h)->k = v

/* External variables */
extern sslctx_cache_struct *sslctx_tbl;
extern cert_job_t *cert_q_head, *cert_q_tail;
extern pthread_mutex_t cert_q_lock;
extern pthread_cond_t cert_q_cond;
extern volatile int cert_workers_shutdown;

/* Certificate generation functions - no longer static */
void generate_cert(const char *cert_name,
                   const char *pem_dir,
                   X509_NAME *issuer,
                   EVP_PKEY *privkey,
                   const STACK_OF(X509_INFO) *cachain);

void generate_universal_ip_cert(const char *pem_dir,
                               X509_NAME *issuer,
                               EVP_PKEY *privkey,
                               const STACK_OF(X509_INFO) *cachain);

/* IP detection functions */
int is_ip_address(const char *addr);

/* Worker thread functions */
void *cert_worker(void *arg);
void shutdown_cert_workers(void);
void enqueue_cert_job(const char *cert_name);

/* Password callback */
int pem_passwd_cb(char *buf, int size, int rwflag, void *u);

#endif /* _SSL_MODULES_H_ */
/*
 * src/sock/socket_handler.c - Socket Handler Koordination und Konfiguration
 * 
 * Nur noch Initialisierung, Konfiguration und ASP-Settings
 * Hauptlogik ist in connection_handler.c
*/

#include "../util/util.h" // _GNU_SOURCE

#include <string.h>

#include "../sock/socket_handler.h"
#include "../log/logger.h"

// =============================================================================
// ASP-KONFIGURATIONSFUNKTIONEN
// =============================================================================

// ASP-Handler Konfiguration
typedef struct {
    int enable_asp_logging;
    int enable_mime_detection;
    int cache_responses;
    char default_charset[32];
} asp_config_t;

// Globale ASP-Konfiguration (Thread-safe)
static asp_config_t asp_config = {
    .enable_asp_logging = 1,
    .enable_mime_detection = 1,
    .cache_responses = 0,
    .default_charset = "UTF-8"
};

// ASP-Handler Konfiguration setzen
void socket_handler_set_asp_config(int enable_logging, int enable_mime, const char *charset) {
    asp_config.enable_asp_logging = enable_logging;
    asp_config.enable_mime_detection = enable_mime;
    
    if (charset && strlen(charset) < sizeof(asp_config.default_charset)) {
        strncpy(asp_config.default_charset, charset, sizeof(asp_config.default_charset) - 1);
        asp_config.default_charset[sizeof(asp_config.default_charset) - 1] = '\0';
    }
}

// =============================================================================
// ERWEITERTE FUNKTIONEN FÃœR SKALIERBARKEIT UND MONITORING
// =============================================================================

// Socket Handler Initialisierung
void socket_handler_init(void) {
    // Initialisierung der ASP-Konfiguration
    asp_config.enable_asp_logging = 1;
    asp_config.enable_mime_detection = 1;
    asp_config.cache_responses = 0;
    strncpy(asp_config.default_charset, "UTF-8", sizeof(asp_config.default_charset) - 1);
    asp_config.default_charset[sizeof(asp_config.default_charset) - 1] = '\0';
    
    log_msg(LGG_INFO, "Socket handler initialized with ASP support");
}

// Socket Handler Cleanup
void socket_handler_cleanup(void) {
    // Cleanup-Operationen falls erforderlich
    log_msg(LGG_INFO, "Socket handler cleanup completed");
}

// Metriken abrufen
void socket_handler_get_metrics(char *buffer, size_t size) {
    if (!buffer || size == 0) return;
    
    snprintf(buffer, size, 
        "ASP Support: %s\n"
        "MIME Detection: %s\n"
        "Default Charset: %s\n"
        "Cache Responses: %s\n",
        asp_config.enable_asp_logging ? "Enabled" : "Disabled",
        asp_config.enable_mime_detection ? "Enabled" : "Disabled",
        asp_config.default_charset,
        asp_config.cache_responses ? "Enabled" : "Disabled"
    );
}

// Thread Pool Konfiguration (Placeholder fÃ¼r zukÃ¼nftige Erweiterungen)
void socket_handler_set_thread_pool(int enable) {
    log_msg(LGG_DEBUG, "Thread pool %s", enable ? "enabled" : "disabled");
}

// Rate Limiting Konfiguration (Placeholder fÃ¼r zukÃ¼nftige Erweiterungen)
void socket_handler_set_rate_limit(int tokens_per_sec) {
    log_msg(LGG_DEBUG, "Rate limit set to %d tokens per second", tokens_per_sec);
}

// Memory Pool GrÃ¶ÃŸe (Placeholder fÃ¼r zukÃ¼nftige Erweiterungen)
void socket_handler_set_memory_pool_size(size_t size) {
    log_msg(LGG_DEBUG, "Memory pool size set to %zu bytes", size);
}
/*
 * src/sock/socket_io.c - Socket I/O Operations
 * 
 * Alle Low-Level Socket-Operationen und SSL-Funktionen
 */

#include "../util/util.h" // _GNU_SOURCE

#include <sys/socket.h>
#include <poll.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <errno.h>
#include <unistd.h>

#include "../sock/socket_io.h"
#include "../log/logger.h"

#ifdef TLS1_3_VERSION
// TLS 1.3 Early Data Support verfÃ¼gbar
#endif

int peek_socket(int fd, SSL *ssl) {
  char buf[10];
  int rv = -1;

  if (!ssl)
    rv = recv(fd, buf, 10, MSG_PEEK);
  else
    rv = SSL_peek(ssl, buf, 10);
  TESTPRINT("%s rv:%d\n", __FUNCTION__, rv);
  return rv;
}

int ssl_read(SSL *ssl, char *buf, int len) {
  int ssl_attempt = 1, ret;

redo_ssl_read:

  ERR_clear_error();
  ret = SSL_read(ssl, (char *)buf, len);
  if (ret <= 0) {
    int sslerr = SSL_get_error(ssl, ret);
    //log_msg(LGG_CRIT, "%s: ret:%d ssl error:%d", __FUNCTION__, ret, sslerr);
    switch(sslerr) {
      case SSL_ERROR_WANT_READ:
        ssl_attempt--;
        if (ssl_attempt > 0) goto redo_ssl_read;
        break;
      case SSL_ERROR_SSL:
        //log_msg(LGG_CRIT, "%s: ssl error %d", __FUNCTION__, ERR_peek_last_error());
        break;
      case SSL_ERROR_SYSCALL:
        //log_msg(LGG_CRIT, "%s: errno:%d", __FUNCTION__, errno);
      default:
        ;
    }
  }
  return ret;
}

int read_socket(int fd, char **msg, SSL *ssl, char *early_data)
{
  if (early_data) {
    log_msg(LGG_DEBUG, "%s: early data\n", __FUNCTION__);
    *msg = early_data;
    return strlen(early_data);
  }

  *msg = realloc(*msg, CHAR_BUF_SIZE + 1);
  if (!(*msg)) {
    log_msg(LGG_ERR, "Out of memory. Cannot malloc receiver buffer.");
    return -1;
  }

  int i, rv, msg_len = 0;
  char *bufptr = *msg;
  for (i=1; i<=MAX_CHAR_BUF_LOTS;) { /* 128K max with CHAR_BUF_SIZE == 4K */
    if (!ssl)
      rv = recv(fd, bufptr, CHAR_BUF_SIZE, 0);
    else
      rv = ssl_read(ssl, (char *)bufptr, CHAR_BUF_SIZE);
    
    if (rv <= 0) break;
    
    msg_len += rv;
    if (rv < CHAR_BUF_SIZE)
      break;
    else {
      ++i;
      // Fix: Memory-Leak bei realloc-Fehler vermeiden
      char *new_msg = realloc(*msg, CHAR_BUF_SIZE * i + 1);
      if (!new_msg) {
          log_msg(LGG_ERR, "Out of memory. Cannot realloc receiver buffer. Size: %d", CHAR_BUF_SIZE * i);
          return msg_len; /* start processing with whatever we received already */
      }
      *msg = new_msg;
      log_msg(LGG_DEBUG, "Realloc receiver buffer. Size: %d", CHAR_BUF_SIZE * i);
      bufptr = *msg + CHAR_BUF_SIZE * (i - 1);
    }
  }
  TESTPRINT("%s: fd:%d msg_len:%d ssl:%p\n", __FUNCTION__, fd, msg_len, ssl);
  return msg_len;
}

int ssl_write(SSL *ssl, const char *buf, int len) {
  int ssl_attempt = 1, ret;
redo_ssl_write:
  ERR_clear_error();
  ret = SSL_write(ssl, (char *)buf, len);
  if (ret <= 0) {
    int sslerr = SSL_get_error(ssl, ret);
    //log_msg(LGG_CRIT, "%s: ret:%d ssl error:%d", __FUNCTION__, ret, sslerr);
    switch(sslerr) {
      case SSL_ERROR_WANT_WRITE:
        ssl_attempt--;
        if (ssl_attempt > 0) goto redo_ssl_write;
        break;
      case SSL_ERROR_SSL:
        //log_msg(LGG_CRIT, "%s: ssl error %d", __FUNCTION__, ERR_peek_last_error());
        break;
      case SSL_ERROR_SYSCALL:
        //log_msg(LGG_CRIT, "%s: errno:%d", __FUNCTION__, errno);
      default:
        ;
    }
  }
  return ret;
}

int write_socket(int fd, const char *msg, int msg_len, SSL *ssl, char **early_data)
{
  int rv;
  if (ssl) {
#ifdef TLS1_3_VERSION
    if (*early_data) {
      log_msg(LGG_DEBUG, "%s: early data\n", __FUNCTION__);
      // Fix: SSL_write_early_data RÃ¼ckgabewert prÃ¼fen
      int early_rv = SSL_write_early_data(ssl, msg, msg_len, (size_t*)&rv);
      if (early_rv <= 0) {
        log_msg(LGG_ERR, "SSL_write_early_data failed: %d", early_rv);
        return -1;
      }

      /* finish the handshake. assume it'll simply succeed */
      if (SSL_accept(ssl) <= 0) {
        log_msg(LGG_ERR, "SSL_accept after early data failed");
        return -1;
      }

      /* job done. reset to NULL.
         memory freed when 'buf' in conn_hanlder freed */
      *early_data = NULL;

    } else
#endif
      rv = ssl_write(ssl, msg, msg_len);
  } else {
    /* a blocking call, so zero should not be returned */
    rv = send(fd, msg, msg_len, 0);
  }
  return rv;
}

int write_pipe(int fd, response_struct *pipedata) {
  // High-Load Fix: Atomarer write() mit Retry-Mechanismus
  // note that the parent must not perform a blocking pipe read without checking
  // for available data, or else it may deadlock when we don't write anything
  
  int attempts = 3;
  while (attempts--) {
    int rv = write(fd, pipedata, sizeof(*pipedata));
    
    if (rv == sizeof(*pipedata)) {
      return rv; // Erfolg
    }
    
    if (rv < 0) {
      if (errno == EINTR || errno == EAGAIN) {
        // Retry bei temporÃ¤ren Fehlern
        continue;
      }
      log_msg(LGG_ERR, "write() to pipe reported error: %m");
      return rv;
    } else if (rv == 0) {
      log_msg(LGG_ERR, "write() to pipe reported no data written and no error");
      return rv;
    } else {
      log_msg(LGG_ERR, "write() to pipe reported writing only %d bytes of expected %u (attempt %d)",
          rv, (unsigned int)sizeof(*pipedata), 3-attempts);
      // Partial write - retry
      continue;
    }
  }
  
  log_msg(LGG_ERR, "write_pipe failed after 3 attempts");
  return -1;
}
/*
 * src/sock/socket_handler.h - Socket Handler Main Header
*/

#ifndef SOCKET_HANDLER_H
#define SOCKET_HANDLER_H

#include "../ssl/ssl_modules.h"
#include "../log/logger.h"

/* Buffer sizes */
#define DEFAULT_REPLY SEND_TXT
#define CHAR_BUF_SIZE       4095     /* initial/incremental size of msg buffer */
#define MAX_CHAR_BUF_LOTS   32       /* max msg buffer size in unit of CHAR_BUF_SIZE */
#define MAX_HTTP_POST_LEN   262143   /* max POST Content-Length before discarding */
#define MAX_HTTP_POST_RETRY 3        /* 3 times */

/* Response types enum */
typedef enum {
  FAIL_GENERAL,
  FAIL_TIMEOUT,
  FAIL_CLOSED,
  FAIL_REPLY,
  SEND_GIF,
  SEND_TXT,
  SEND_JPG,
  SEND_PNG,
  SEND_SWF,
  SEND_ICO,
  SEND_BAD,
  SEND_STATS,
  SEND_STATSTEXT,
  SEND_204,
  SEND_REDIRECT,
  SEND_NO_EXT,
  SEND_UNK_EXT,
  SEND_NO_URL,
  SEND_BAD_PATH,
  SEND_POST,
  SEND_HEAD,
  SEND_OPTIONS,
  /* New response types for extended file support */
  SEND_JSON,
  SEND_XML,
  SEND_WEBP,
  SEND_SVG,
  SEND_FONT,
  SEND_VIDEO,
  SEND_AUDIO,
  SEND_PDF,
  SEND_DOC,
  SEND_ZIP,
  SEND_BIN,
  SEND_CSS,
  SEND_HTML,
  /* ASP/Server-side script support */
  SEND_ASP,
  SEND_ASPX,
  SEND_ASHX,
  SEND_PHP,
  SEND_JSP,
  SEND_JS,
  /* Special actions */
  ACTION_LOG_VERB,
  ACTION_DEC_KCC
} response_enum;

/* Response structure */
typedef struct {
    response_enum status;
    union {
        int rx_total;
        int krq;
        logger_level verb;
    };
    double run_time;
    ssl_enum ssl;
    int ssl_ver;
} response_struct;

/* Public functions - Haupteingangspounkt */
void* conn_handler(void *ptr);

/* Enhanced functions for scalability */
void socket_handler_init(void);
void socket_handler_cleanup(void);
void socket_handler_get_metrics(char *buffer, size_t size);

/* Configuration functions */
void socket_handler_set_thread_pool(int enable);
void socket_handler_set_rate_limit(int tokens_per_sec);
void socket_handler_set_memory_pool_size(size_t size);

/* ASP/Server-side script configuration */
void socket_handler_set_asp_config(int enable_logging, int enable_mime, const char *charset);

#endif /* SOCKET_HANDLER_H */
/*
 * src/sock/socket_io.h - Socket I/O Operations Header
 */

#ifndef SOCKET_IO_H
#define SOCKET_IO_H

#include <openssl/ssl.h>
#include "../sock/socket_handler.h"

/* Socket I/O Functions */
int peek_socket(int fd, SSL *ssl);
int ssl_read(SSL *ssl, char *buf, int len);
int read_socket(int fd, char **msg, SSL *ssl, char *early_data);
int ssl_write(SSL *ssl, const char *buf, int len);
int write_socket(int fd, const char *msg, int msg_len, SSL *ssl, char **early_data);
int write_pipe(int fd, response_struct *pipedata);

#endif /* SOCKET_IO_H */
/*
 * src/log/logger.c
 *
*/

#include <stdarg.h>
#include <string.h>
#include <syslog.h>
#include <openssl/ssl.h>
#include "../log/logger.h"

#ifndef DEBUG
static logger_level _verb = LGG_ERR;
#else
static logger_level _verb = LGG_DEBUG;
#endif

static int ctrl_char(char *buf, size_t len) {
    if (strlen(buf) < len)
        return 1;
    for (size_t i=0; i<(len - 1); i++) {
        if (buf[i] >= 10 && buf[i] <= 13)
            continue;
        if (buf[i] < 32) {
            return 1;
        }
    }
    return 0;
}

void log_set_verb(logger_level verb) { _verb = verb; }
logger_level log_get_verb() { return _verb; }

void log_msg(logger_level verb, char *fmt, ...)
{
    if (verb > _verb)
        return;
      
    va_list args;
    va_start(args, fmt);
    vsyslog(LOG_CRIT + verb, fmt, args);
    va_end(args);
}

void log_xcs(logger_level verb, char *client_ip, char *host, int tls, char *req, char *body, size_t body_len)
{
    if (verb > _verb || !client_ip || !host || !req)
      return;

    const char* tls_ver;
    switch (tls) {
#ifdef TLS1_3_VERSION
        case TLS1_3_VERSION: tls_ver = "1.3"; break;
#endif
        case TLS1_2_VERSION: tls_ver = "1.2"; break;
        case TLS1_VERSION:   tls_ver = "1.0"; break;
        case 0:
        default:
            tls_ver = "none";
    }

    if (strlen(req) < MAX_LOG_CHUNK_SIZE)
        syslog(LOG_CRIT + verb, "%s %s %s tls_%s", client_ip, host, req, tls_ver);
    else {
        int num_chunks = strlen(req) / MAX_LOG_CHUNK_SIZE + 1;
        char store = req[MAX_LOG_CHUNK_SIZE];
        req[MAX_LOG_CHUNK_SIZE] = '\0';
        syslog(LOG_CRIT + verb, "%s %s %s", client_ip, host, req);
        req[MAX_LOG_CHUNK_SIZE] = store;

        int chunk = 1;
        if (num_chunks > 2)
          for (; chunk < num_chunks - 1; chunk++) {
              store = req[MAX_LOG_CHUNK_SIZE * (chunk + 1)];
              req[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = '\0';
              syslog(LOG_CRIT + verb, "%s", req + MAX_LOG_CHUNK_SIZE * chunk);
              req[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = store;
          }
        syslog(LOG_CRIT + verb, "%s tls_%s", req + MAX_LOG_CHUNK_SIZE * chunk, tls_ver);
    }

    if (body_len > 0 && body) {
      if (ctrl_char(body, body_len))
          syslog(LOG_CRIT + verb, "[%s]", "-binary POST content not dumped-");
      else if (strlen(body) < MAX_LOG_CHUNK_SIZE)
          syslog(LOG_CRIT + verb, "[%s]", body);
      else {
          int num_chunks = strlen(body) / MAX_LOG_CHUNK_SIZE + 1;
          char store = body[MAX_LOG_CHUNK_SIZE];
          body[MAX_LOG_CHUNK_SIZE] = '\0';
          syslog(LOG_CRIT + verb, "[%s", body);
          body[MAX_LOG_CHUNK_SIZE] = store;

          int chunk = 1;
          if (num_chunks > 2)
            for (; chunk < num_chunks - 1; chunk++) {
                store = body[MAX_LOG_CHUNK_SIZE * (chunk + 1)];
                body[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = '\0';
                syslog(LOG_CRIT + verb, "%s", body + MAX_LOG_CHUNK_SIZE * chunk);
                body[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = store;
            }
          syslog(LOG_CRIT + verb, "%s]", body + MAX_LOG_CHUNK_SIZE * chunk);
      }
    }
}
/*
 * src/log/logger.h
 *
*/

#ifndef LOGGER_H
#define LOGGER_H

#define MAX_LOG_CHUNK_SIZE  8000   /* size of chunk output to logging facility each time */

typedef enum {    
    LGG_CRIT = 0,
    LGG_ERR,
    LGG_WARNING,
    LGG_NOTICE,
    LGG_INFO,
    LGG_DEBUG
} logger_level;

void log_set_verb(logger_level verb);
logger_level log_get_verb();
void log_msg(logger_level verb, char *fmt, ...);
void log_xcs(logger_level verb, char *client_ip, char *host, int tls, char *req, char *body, size_t body_len);

#endif
/*
 * src/uil/util.c
*/

#include <stdlib.h>
#include <time.h>

#include "../util/util.h"
#include "../log/logger.h"

//#include "src/certs/certs.h"
#include "src/ssl/ssl_modules.h"

#if defined(__GLIBC__) && defined(BACKTRACE)
#include <execinfo.h>
#endif

char pixel_cert_pipe[PIXELSERV_MAX_PATH];

void generate_random_pipe_path(char *buffer, size_t buflen) {
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    int len = 32;

    srand(time(NULL) ^ getpid());
    snprintf(buffer, buflen, "/tmp/");
    for (int i = 0; i < len; ++i) {
        buffer[5 + i] = charset[rand() % (sizeof(charset) - 1)];
    }
    buffer[5 + len] = '\0';
}

// stats data
// note that child processes inherit a snapshot copy
// public data (should probably change to a struct)
volatile sig_atomic_t count = 0;
volatile sig_atomic_t avg = 0;
volatile sig_atomic_t rmx = 0;
volatile sig_atomic_t tav = 0;
volatile sig_atomic_t tmx = 0;
volatile sig_atomic_t ers = 0;
volatile sig_atomic_t tmo = 0;
volatile sig_atomic_t cls = 0;
volatile sig_atomic_t nou = 0;
volatile sig_atomic_t pth = 0;
volatile sig_atomic_t nfe = 0;
volatile sig_atomic_t ufe = 0;
volatile sig_atomic_t gif = 0;
volatile sig_atomic_t bad = 0;
volatile sig_atomic_t txt = 0;
volatile sig_atomic_t jpg = 0;
volatile sig_atomic_t png = 0;
volatile sig_atomic_t swf = 0;
volatile sig_atomic_t ico = 0;
volatile sig_atomic_t sta = 0;
volatile sig_atomic_t stt = 0;
volatile sig_atomic_t noc = 0;
volatile sig_atomic_t rdr = 0;
volatile sig_atomic_t pst = 0;
volatile sig_atomic_t hed = 0;
volatile sig_atomic_t opt = 0;
volatile sig_atomic_t cly = 0;

volatile sig_atomic_t slh = 0;
volatile sig_atomic_t slm = 0;
volatile sig_atomic_t sle = 0;
volatile sig_atomic_t slc = 0;
volatile sig_atomic_t slu = 0;
volatile sig_atomic_t uca = 0;
volatile sig_atomic_t ucb = 0;
volatile sig_atomic_t uce = 0;
volatile sig_atomic_t ush = 0;
volatile sig_atomic_t kcc = 0;
volatile sig_atomic_t kmx = 0;
float kvg = 0.0;
volatile sig_atomic_t krq = 0;
volatile sig_atomic_t clt = 0;
volatile sig_atomic_t v13 = 0;
volatile sig_atomic_t v12 = 0;
volatile sig_atomic_t v10 = 0;
volatile sig_atomic_t zrt = 0;

// private data
static struct timespec startup_time = {0, 0};
static clockid_t clock_source = CLOCK_MONOTONIC;

void get_time(struct timespec *time) {
  if (clock_gettime(clock_source, time) < 0) {
    if (errno == EINVAL &&
        clock_source == CLOCK_MONOTONIC) {
      clock_source = CLOCK_REALTIME;
      syslog(LOG_WARNING, "clock_gettime() reports CLOCK_MONOTONIC not supported; switching to less accurate CLOCK_REALTIME");
      get_time(time); // try again with new clock setting
    } else {
      // this should never happen
      syslog(LOG_ERR, "clock_gettime() reported failure getting time: %m");
      time->tv_sec = time->tv_nsec = 0;
    }
  }
}

unsigned int process_uptime()
{
    struct timespec now;
    get_time(&now);
    return (unsigned int) difftime(now.tv_sec, startup_time.tv_sec);
}

char* get_version(int argc, char* argv[]) {
  char* retbuf = NULL;
  char* optbuf = NULL;
  unsigned int optlen = 0, freeoptbuf = 0;
  unsigned int arglen[argc];

  // capture startup_time if not yet set
  if (!startup_time.tv_sec) {
    get_time(&startup_time);
  }

  // determine total size of all arguments
  for (int i = 1; i < argc; ++i) {
    arglen[i] = strlen(argv[i]) + 1; // add 1 for leading space
    optlen += arglen[i];
  }
  if (optlen > 0) {
    // allocate a buffer to hold all arguments
    optbuf = malloc((optlen * sizeof(char)) + 1);
    if (optbuf) {
      freeoptbuf = 1;
      // concatenate arguments into buffer
      for (int i = 1, optlen = 0; i < argc; ++i) {
        optbuf[optlen] = ' '; // prepend a space to each argument
        strncpy(optbuf + optlen + 1, argv[i], arglen[i]);
        optlen += arglen[i];
      }
      optbuf[optlen] = '\0';
    } else {
      optbuf = " <malloc error>";
    }
  } else {
    optbuf = " <none>";
  }

  if (asprintf(&retbuf, "pixelserv-tls %s (compiled: %s" FEATURE_FLAGS ") options:%s",
          VERSION, __DATE__ " " __TIME__, optbuf) < 1) {
    retbuf = " <asprintf error>";
  }

  if (freeoptbuf) {
    free(optbuf);
    freeoptbuf = 0;
  }

  return retbuf;
}

char* get_stats(const int sta_offset, const int stt_offset) {
    char* retbuf = NULL, *uptimeStr = NULL;
    unsigned int uptime = process_uptime();

	const char* sta_fmt =  "<br><table><tr><td>uts</td><td>%s</td><td>process uptime</td></tr><tr><td>log</td><td>%d</td><td>critical (0) error (1) warning (2) notice (3) info (4) debug (5)</td></tr><tr><td>kcc</td><td>%d</td><td>number of active service threads</td></tr><tr><td>kmx</td><td>%d</td><td>maximum number of service threads</td></tr><tr><td>kvg</td><td>%.2f</td><td>average number of requests per service thread</td></tr><tr><td>krq</td><td>%d</td><td>max number of requests by one service thread</td></tr><tr><th colspan=\"3\"></th></tr><tr><td>req</td><td>%d</td><td>total # of requests (HTTP, HTTPS, success, failure etc)</td></tr><tr><td>avg</td><td>%d bytes</td><td>average size of requests</td></tr><tr><td>rmx</td><td>%d bytes</td><td>largest size of request(s)</td></tr><tr><td>tav</td><td>%d ms</td><td>average processing time (per request)</td></tr><tr><td>tmx</td><td>%d ms</td><td>longest processing time (per request)</td></tr><tr><th colspan=\"3\"></th></tr><tr><td>slh</td><td>%d</td><td># of accepted HTTPS requests</td></tr><tr><td>slm</td><td>%d</td><td># of rejected HTTPS requests (missing certificate)</td></tr><tr><td>sle</td><td>%d</td><td># of rejected HTTPS requests (certificate available but not usable)</td></tr><tr><td>slc</td><td>%d</td><td># of dropped HTTPS requests (client disconnect without sending any request)</td></tr><tr><td>slu</td><td>%d</td><td># of dropped HTTPS requests (other TLS handshake errors)</td></tr><th colspan=\"3\"></th></tr><tr><td>v13</td><td>%d</td><td>slh/slc break-down: TLS 1.3</td></tr><tr><td>v12</td><td>%d</td><td>slh/slc break-down: TLS 1.2</td></tr><tr><td>v10</td><td>%d</td><td>slh/slc break-down: TLS 1.0</td></tr><tr><td>zrt</td><td>%d</td><td>slh break-down: TLS 1.3 Early Data aka 0-RTT</td></tr>    <tr><th colspan=\"3\"></th></tr>    <tr><td>uca</td><td>%d</td><td>slu break-down: # of unknown CA reported by clients</td></tr><tr><td>ucb</td><td>%d</td><td>slu break-down: # of bad certificate reported by clients</td></tr><tr><td>uce</td><td>%d</td><td>slu break-down: # of unknown cert reported by clients</td></tr><tr><td>ush</td><td>%d</td><td>slu break-down: # of shutdown by clients after ServerHello</td></tr><tr><tr><th colspan=\"3\"></th></tr><tr><td>sct</td><td>%d</td><td>cert cache: # of certs in cache</td></tr><tr><td>sch</td><td>%d</td><td>cert cache: # of reuses of cached certs</td></tr><tr><tr><td>scm</td><td>%d</td><td>cert cache: # of misses to find a cert in cache</td></tr><tr><tr><td>scp</td><td>%d</td><td>cert cache: # of purges to give room for a new cert</td></tr><tr><td>ssh</td><td>%d</td><td>sess cache: # of reuses of cached TLS sessions</td></tr><tr><td>ssm</td><td>%d</td><td>sess cache: # of misses to find a TLS session in cache</td></tr><tr><td>ssp</td><td>%d</td><td>sess cache: # of purges to give room for a new TLS session</td></tr><tr><th colspan=\"3\"></th></tr><tr><td>nfe</td><td>%d</td><td># of GET requests for server-side scripting</td></tr><tr><td>gif</td><td>%d</td><td># of GET requests for GIF</td></tr><tr><td>ico</td><td>%d</td><td># of GET requests for ICO</td></tr><tr><td>txt</td><td>%d</td><td># of GET requests for Javascripts</td></tr><tr><td>jpg</td><td>%d</td><td># of GET requests for JPG</td></tr><tr><td>png</td><td>%d</td><td># of GET requests for PNG</td></tr><tr><td>swf</td><td>%d</td><td># of GET requests for SWF</td></tr><tr><td>ufe</td><td>%d</td><td># of GET requests /w unknown file extension</td></tr><tr><th colspan=\"3\"></th></tr><tr><td>opt</td><td>%d</td><td># of OPTIONS requests</td></tr><tr><td>pst</td><td>%d</td><td># of POST requests</td></tr><tr><td>hed</td><td>%d</td><td># of HEAD requests (HTTP 501 response)</td></tr><tr><td>rdr</td><td>%d</td><td># of GET requests resulted in REDIRECT response</td></tr><tr><td>nou</td><td>%d</td><td># of GET requests /w empty URL</td></tr><tr><td>pth</td><td>%d</td><td># of GET requests /w malformed URL</td></tr><tr><td>204</td><td>%d</td><td># of GET requests (HTTP 204 response)</td></tr><tr><td>bad</td><td>%d</td><td># of unknown HTTP requests (HTTP 501 response)</td></tr><tr><th colspan=\"3\"></th></tr><tr><td>cls</td><td>%d</td><td># of dropped requests (client disconnect without sending any  request)</td></tr><tr><td>cly</td><td>%d</td><td># of dropped requests (client disconnect before response sent)</td></tr><tr><td>clt</td><td>%d</td><td># of dropped requests (reached maximum service threads)</td></tr><tr><td>err</td><td>%d</td><td># of dropped requests (unknown reason)</td></tr></table>";

    const char* stt_fmt = "%d uts, %d log, %d kcc, %d kmx, %.2f kvg, %d krq, %d req, %d avg, %d rmx, %d tav, %d tmx, %d slh, %d slm, %d sle, %d slc, %d slu, %d v13, %d v12, %d v10, %d zrt, %d uca, %d ucb, %d uce, %d ush, %d sct, %d sch, %d scm, %d scp, %d ssh, %d ssm, %d ssp, %d nfe, %d gif, %d ico, %d txt, %d jpg, %d png, %d swf, %d ufe, %d opt, %d pst, %d hed, %d rdr, %d nou, %d pth, %d 204, %d bad, %d cls, %d cly, %d clt, %d err";
    int sct = sslctx_tbl_get_cnt_total();
    int sch = sslctx_tbl_get_cnt_hit();
    int scm = sslctx_tbl_get_cnt_miss();
    int scp = sslctx_tbl_get_cnt_purge();
    int sst = sslctx_tbl_get_sess_cnt();
    int ssh = sslctx_tbl_get_sess_hit();
    int ssm = sslctx_tbl_get_sess_miss();
    int ssp = sslctx_tbl_get_sess_purge();

    if (asprintf(&uptimeStr, "%dd %02d:%02d", (int)uptime/86400, (int)(uptime%86400)/3600, (int)((uptime%86400)%3600)/60) < 1
        || asprintf(&retbuf, (sta_offset) ? sta_fmt : stt_fmt,
        (sta_offset) ? (long)uptimeStr : (long)uptime, log_get_verb(), kcc, kmx, kvg, krq, count, avg, rmx, tav, tmx, slh, slm, sle, slc, slu, v13, v12, v10, zrt, uca, ucb, uce, ush, sct, sch, scm, scp, sst + ssh, ssm, ssp, nfe, gif, ico, txt, jpg, png, swf, ufe, opt, pst, hed, rdr, nou, pth, noc, bad, cls, cly, clt, ers
        ) < 1)
        retbuf = " <asprintf error>";

    free(uptimeStr);
    return retbuf;
}

// Use SMA for the first 500 samples approximated by # of requets. Use EMA afterwards
float ema(float curr, int new, int *cnt) {
    if (count < 500) {
      curr *= *cnt;
      curr = (curr + new) / ++(*cnt);
    } else
      curr += 0.002 * (new - curr);
    return curr;
}

double elapsed_time_msec(const struct timespec start_time) {
  struct timespec current_time = {0, 0};
  struct timespec diff_time = {0, 0};

  if (!start_time.tv_sec &&
      !start_time.tv_nsec) {
    log_msg(LGG_DEBUG, "check_time(): returning because start_time not set");
    return -1.0;
  }

  get_time(&current_time);

  diff_time.tv_sec = difftime(current_time.tv_sec, start_time.tv_sec) + 0.5;
  diff_time.tv_nsec = current_time.tv_nsec - start_time.tv_nsec;
  if (diff_time.tv_nsec < 0) {
    // normalize nanoseconds
    diff_time.tv_sec  -= 1;
    diff_time.tv_nsec += 1000000000;
  }

  return diff_time.tv_sec * 1000 + ((double)diff_time.tv_nsec / 1000000);
}

#if defined(__GLIBC__) && defined(BACKTRACE)
void print_trace(int sig) {

  void *buf[32];
  char **strings;
  int size, i;
  log_msg(LGG_CRIT, "signal %d\n", sig);
  size = backtrace(buf, 32);
  strings = backtrace_symbols(buf, size);
  log_msg(LGG_CRIT, "backtrace:");
  for (i = 0; i < size; i++)
    log_msg(LGG_CRIT, "%d %s", buf[i], strings[i]);
  free(strings);
  exit(EXIT_FAILURE);
}
#endif
/*
 * src/uil/util.h
*/

#ifndef UTIL_H
#define UTIL_H
#include <stddef.h>  // fÃ¼r size_t
#include <stdlib.h>  // ebenfalls gÃ¼ltig, bereits teilweise vorhanden

// common configuration items

#define _GNU_SOURCE             // using a bunch of gcc-specific stuff

// system includes used by more than one source file
#include <errno.h>              // EPIPE, errno, EINTR
#include <netdb.h>              // addrinfo(), AI_PASSIVE, gai_strerror(), freeaddrinfo()
#include <netinet/tcp.h>        // SOL_TCP, TCP_NODELAY
#include <signal.h>             // sig_atomic_t
#include <stdio.h>              // printf() and variants
#include <stdlib.h>             // exit(), EXIT_FAILURE
#include <string.h>             // lots of stuff!
#include <syslog.h>             // syslog(), openlog()
#include <unistd.h>             // close(), setuid(), TEMP_FAILURE_RETRY, fork()
#include <time.h>               // struct timespec, clock_gettime(), difftime()
#include <arpa/inet.h>

#ifdef linux
#  include <linux/version.h>
#endif

#include <openssl/ssl.h>

// preprocessor defines
#define VERSION "3.0.18.25"

#define BACKLOG SOMAXCONN       // how many pending connections queue will hold
#define DEFAULT_IP "*"          // default IP address ALL - use this in messages only
#define DEFAULT_PORT "80"       // the default port users will be connecting to
#define DEFAULT_TIMEOUT 1       // default timeout for select() calls, in seconds
#define DEFAULT_KEEPALIVE (DEFAULT_TIMEOUT * 120)
                                // default keep-alive duration for HTTP/1.1 connections, in seconds
                                // it's the time a connection will stay active
                                // until another request comes and refreshes the timer
#define DEFAULT_THREAD_MAX 1200 // maximum number of concurrent service threads
#define DEFAULT_CERT_CACHE_SIZE 500
                                // default number of certificates to be cached in memory
#define SECOND_PORT "443"
#define MAX_PORTS 10
#define MAX_TLS_PORTS 9         // PLEASE ENSURE MAX_TLS_PORTS < MAX_PORTS

#ifdef DROP_ROOT
# define DEFAULT_USER "nobody"  // nobody used by dnsmasq
#endif

# define DEFAULT_STATS_URL "/servstats"
# define DEFAULT_STATS_TEXT_URL "/servstats.txt"

//#include "src/certs/certs.h"
#include "src/ssl/ssl_modules.h"
#include <stddef.h>         // <- fÃ¼r size_t
#include <errno.h>
#include <netdb.h>

extern char pixel_cert_pipe[PIXELSERV_MAX_PATH];
void generate_random_pipe_path(char *buffer, size_t buflen);

/* taken from glibc unistd.h and fixes musl */
#ifndef TEMP_FAILURE_RETRY
#define TEMP_FAILURE_RETRY(expression) \
  (__extension__                                                              \
    ({ long int __result;                                                     \
       do __result = (long int) (expression);                                 \
       while (__result == -1L && errno == EINTR);                             \
       __result; }))
#endif

# define FEAT_TFO
# ifdef linux
#   if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0) || ENABLE_TCP_FASTOPEN
#     undef FEAT_TFO
#     define FEAT_TFO " tfo"
#   endif
# endif
# ifdef TLS1_3_VERSION
#   define FEAT_TLS1_3  " tls1_3"
# else
#   define FEAT_TLS1_3  " no_tls1_3"
# endif
# define FEATURE_FLAGS " flags:" FEAT_TFO FEAT_TLS1_3

#ifdef TEST
# define TESTPRINT printf
#else
# define TESTPRINT(x,y...)
#endif

// cross-thread count variables
extern volatile sig_atomic_t count; // req
extern volatile sig_atomic_t avg; // cumulative moving average request size
extern volatile sig_atomic_t _act; // avg count (updated at time of average calculation)
extern volatile sig_atomic_t rmx; // maximum encountered request size
extern volatile sig_atomic_t _tct; // time count
extern volatile sig_atomic_t tav; // cumulative moving average time in msec
extern volatile sig_atomic_t tmx; // max time in msec
extern volatile sig_atomic_t ers;
extern volatile sig_atomic_t tmo;
extern volatile sig_atomic_t cls;
extern volatile sig_atomic_t nou;
extern volatile sig_atomic_t pth;
extern volatile sig_atomic_t nfe;
extern volatile sig_atomic_t ufe;
extern volatile sig_atomic_t gif;
extern volatile sig_atomic_t bad;
extern volatile sig_atomic_t txt;
extern volatile sig_atomic_t jpg;
extern volatile sig_atomic_t png;
extern volatile sig_atomic_t swf;
extern volatile sig_atomic_t ico;
extern volatile sig_atomic_t sta; // so meta!
extern volatile sig_atomic_t stt;
extern volatile sig_atomic_t noc;
extern volatile sig_atomic_t rdr;
extern volatile sig_atomic_t pst;
extern volatile sig_atomic_t hed;
extern volatile sig_atomic_t opt;
extern volatile sig_atomic_t cly;

extern volatile sig_atomic_t slh;
extern volatile sig_atomic_t slm;
extern volatile sig_atomic_t sle;
extern volatile sig_atomic_t slc;
extern volatile sig_atomic_t slu;
extern volatile sig_atomic_t uca;
extern volatile sig_atomic_t ucb;
extern volatile sig_atomic_t uce;
extern volatile sig_atomic_t ush;
extern volatile sig_atomic_t kcc;
extern volatile sig_atomic_t kmx;
extern volatile sig_atomic_t kct;
extern float kvg;
extern volatile sig_atomic_t krq;
extern volatile sig_atomic_t clt;
extern volatile sig_atomic_t v13;
extern volatile sig_atomic_t v12;
extern volatile sig_atomic_t v10;
extern volatile sig_atomic_t zrt;

struct Global {
    int argc;
    char** argv;
    const time_t select_timeout;
    const time_t http_keepalive;
    const int pipefd;
    const char* const stats_url;
    const char* const stats_text_url;
    const int do_204;
    const int do_redirect;
#ifdef DEBUG
    const int warning_time;
#endif
    const char* pem_dir;
};

#define GLOBAL(p,e) ((struct Global *)p)->e

// util.c functions

// encapsulation of clock_gettime() to perform one-time degradation of source
//  when necessary
void get_time(struct timespec *time);
unsigned int process_uptime();

// generate version string
// note that caller is expected to call free()
//  on the return value when done using it
char* get_version(int argc, char* argv[]);

// stats string generator
// NOTES:
// - The return value is heap-allocated, so the caller is expected to call
//   free() on the return value when done using it in order to avoid a memory
//   leak.
// - The purpose of sta_offset is to allow accounting for an in-progess status
//   response.
// - Similarly, stt_offset is for an in-progress status.txt response.
char* get_stats(const int sta_offset, const int stt_offset);

float ema(float curr, int new, int *cnt);

double elapsed_time_msec(const struct timespec start_time);

#if defined(__GLIBC__) && defined(BACKTRACE)
void print_trace();
#endif

#endif // UTIL_H
/*
 * debug_system.h - Einfaches Debug-System fÃ¼r pixelserv-tls
 * 
 * Production: Nur "Program gestartet" - sonst NICHTS
 * Debug: VollstÃ¤ndiges Logging wie bisher
 */

#ifndef DEBUG_SYSTEM_H
#define DEBUG_SYSTEM_H

#include <stdio.h>
#include <stdarg.h>
#include <syslog.h>

/* Logger Level Definitionen */
typedef enum {    
    LGG_CRIT = 0,
    LGG_ERR,
    LGG_WARNING,
    LGG_NOTICE,
    LGG_INFO,
    LGG_DEBUG
} logger_level;

#ifdef DEBUG
    /* =====================================================================
     * DEBUG BUILD - VollstÃ¤ndiges Logging aktiv
     * ===================================================================== */
    
    /* Debug-Funktionen - werden implementiert */
    void debug_log_msg(logger_level level, const char *fmt, ...);
    void debug_log_xcs(logger_level level, char *client_ip, char *host, 
                       int tls, char *req, char *body, size_t body_len);
    void debug_set_verbose_level(logger_level level);
    logger_level debug_get_verbose_level(void);
    void debug_system_init(void);
    void debug_system_cleanup(void);
    
    /* Makros fÃ¼r Debug-Build */
    #define log_msg(level, fmt, ...) debug_log_msg(level, fmt, ##__VA_ARGS__)
    #define log_xcs(level, ip, host, tls, req, body, len) debug_log_xcs(level, ip, host, tls, req, body, len)
    #define log_set_verb(level) debug_set_verbose_level(level)
    #define log_get_verb() debug_get_verbose_level()
    
    /* Debug-spezifische Makros */
    #define DEBUG_PRINT(fmt, ...) printf("[DEBUG] " fmt "\n", ##__VA_ARGS__)
    #define TIME_CHECK(description) debug_time_check(description)
    #define HEX_DUMP(data, size) debug_hex_dump(data, size)
    
    /* ZusÃ¤tzliche Debug-Funktionen */
    void debug_time_check(const char *description);
    void debug_hex_dump(void *data, int size);
    
    /* Syslog normal verfÃ¼gbar */
    /* openlog, syslog, closelog bleiben unverÃ¤ndert */

#else
    /* =====================================================================
     * PRODUCTION BUILD - Ultra-minimal, nur Startup
     * ===================================================================== */
    
    /* Einzige erlaubte Funktion fÃ¼r Production */
    static inline void production_startup_message(void) {
        printf("Program gestartet\n");
        fflush(stdout);
    }
    
    /* Alle Log-Makros werden zu NICHTS - Zero-Cost in Production */
    #define log_msg(level, fmt, ...)                    /* NICHTS */
    #define log_xcs(level, ip, host, tls, req, body, len) /* NICHTS */
    #define log_set_verb(level)                         /* NICHTS */
    #define log_get_verb() 0                           /* Return 0 */
    
    /* Debug-Makros werden zu NICHTS */
    #define DEBUG_PRINT(fmt, ...)                      /* NICHTS */
    #define TIME_CHECK(description)                    /* NICHTS */
    #define HEX_DUMP(data, size)                       /* NICHTS */
    
    /* Syslog komplett deaktiviert fÃ¼r Production */
    #define openlog(...)                               /* NICHTS */
    #define syslog(...)                                /* NICHTS */
    #define closelog()                                 /* NICHTS */
    
#endif /* DEBUG */

/* =========================================================================
 * SYSTEM STARTUP - Einziger unterschied zwischen Debug/Production
 * ========================================================================= */

static inline void system_startup_log(void) {
#ifdef DEBUG
    debug_system_init();
    debug_log_msg(LGG_NOTICE, "pixelserv-tls DEBUG build gestartet");
#else
    production_startup_message();
#endif
}

static inline void system_shutdown_log(void) {
#ifdef DEBUG
    debug_log_msg(LGG_NOTICE, "pixelserv-tls DEBUG build beendet");
    debug_system_cleanup();
#endif
    /* Production: Nichts beim Shutdown */
}

/* =========================================================================
 * LEGACY COMPATIBILITY - FÃ¼r bestehenden Code
 * ========================================================================= */

/* Diese Konstanten bleiben fÃ¼r KompatibilitÃ¤t */
#define MAX_LOG_CHUNK_SIZE 8000

/* TESTPRINT Makro fÃ¼r Legacy-Code */
#ifdef DEBUG
    #define TESTPRINT(fmt, ...) debug_log_msg(LGG_DEBUG, fmt, ##__VA_ARGS__)
#else
    #define TESTPRINT(fmt, ...)  /* NICHTS */
#endif

#endif /* DEBUG_SYSTEM_H */
/*
 * debug_system.c - Debug System Implementation
 * 
 * Diese Datei wird NUR bei DEBUG-Builds kompiliert!
 * Production Builds enthalten diese Datei GAR NICHT.
 */

#ifdef DEBUG

#include "debug_system.h"
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <ctype.h>

/* =========================================================================
 * DEBUG STATE
 * ========================================================================= */

static logger_level current_verbose_level = LGG_ERR;
static struct timespec debug_start_time = {0, 0};

/* =========================================================================
 * HELPER FUNCTIONS
 * ========================================================================= */

static void get_current_time(struct timespec *ts) {
    clock_gettime(CLOCK_MONOTONIC, ts);
}

static double time_diff_ms(struct timespec start, struct timespec end) {
    return (end.tv_sec - start.tv_sec) * 1000.0 + 
           (end.tv_nsec - start.tv_nsec) / 1000000.0;
}

static int should_log(logger_level level) {
    return level <= current_verbose_level;
}

/* =========================================================================
 * CORE LOGGING FUNCTIONS
 * ========================================================================= */

void debug_log_msg(logger_level level, const char *fmt, ...) {
    if (!should_log(level)) {
        return;
    }
    
    va_list args;
    va_start(args, fmt);
    
    /* Syslog fÃ¼r wichtige Nachrichten */
    if (level <= LGG_WARNING) {
        vsyslog(LOG_CRIT + level, fmt, args);
    }
    
    /* Console-Output fÃ¼r Debug */
    if (level >= LGG_INFO) {
        struct timespec now;
        get_current_time(&now);
        double uptime_ms = time_diff_ms(debug_start_time, now);
        
        const char* level_names[] = {"CRIT", "ERR", "WARN", "NOTICE", "INFO", "DEBUG"};
        printf("[%8.2f] [%s] ", uptime_ms, level_names[level]);
        vprintf(fmt, args);
        printf("\n");
        fflush(stdout);
    }
    
    va_end(args);
}

void debug_log_xcs(logger_level level, char *client_ip, char *host, int tls, 
                   char *req, char *body, size_t body_len) {
    if (!should_log(level)) {
        return;
    }
    
    if (!client_ip || !host || !req) {
        return;
    }
    
    /* TLS Version String */
    const char* tls_ver = "none";
    switch (tls) {
        case 0x0304: tls_ver = "1.3"; break;  /* TLS 1.3 */
        case 0x0303: tls_ver = "1.2"; break;  /* TLS 1.2 */
        case 0x0301: tls_ver = "1.0"; break;  /* TLS 1.0 */
        default: tls_ver = "none"; break;
    }
    
    /* Request Logging */
    if (strlen(req) < MAX_LOG_CHUNK_SIZE) {
        syslog(LOG_CRIT + level, "%s %s %s tls_%s", client_ip, host, req, tls_ver);
    } else {
        /* GroÃŸe Requests in Chunks */
        int num_chunks = strlen(req) / MAX_LOG_CHUNK_SIZE + 1;
        for (int chunk = 0; chunk < num_chunks; chunk++) {
            char temp_char = req[MAX_LOG_CHUNK_SIZE * (chunk + 1)];
            if (chunk < num_chunks - 1) {
                req[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = '\0';
            }
            
            if (chunk == 0) {
                syslog(LOG_CRIT + level, "%s %s %s", client_ip, host, 
                       req + MAX_LOG_CHUNK_SIZE * chunk);
            } else if (chunk == num_chunks - 1) {
                syslog(LOG_CRIT + level, "%s tls_%s", 
                       req + MAX_LOG_CHUNK_SIZE * chunk, tls_ver);
            } else {
                syslog(LOG_CRIT + level, "%s", req + MAX_LOG_CHUNK_SIZE * chunk);
            }
            
            if (chunk < num_chunks - 1) {
                req[MAX_LOG_CHUNK_SIZE * (chunk + 1)] = temp_char;
            }
        }
    }
    
    /* Body Logging falls vorhanden */
    if (body_len > 0 && body) {
        /* Check if binary */
        int is_binary = 0;
        for (size_t i = 0; i < body_len && i < 100; i++) {
            if (body[i] < 32 && body[i] != '\n' && body[i] != '\r' && body[i] != '\t') {
                is_binary = 1;
                break;
            }
        }
        
        if (is_binary) {
            syslog(LOG_CRIT + level, "[binary POST content not dumped - %zu bytes]", body_len);
        } else if (strlen(body) < MAX_LOG_CHUNK_SIZE) {
            syslog(LOG_CRIT + level, "[%s]", body);
        } else {
            syslog(LOG_CRIT + level, "[POST body truncated - %zu bytes]", body_len);
        }
    }
}

/* =========================================================================
 * CONFIGURATION FUNCTIONS
 * ========================================================================= */

void debug_set_verbose_level(logger_level level) {
    if (level >= LGG_CRIT && level <= LGG_DEBUG) {
        current_verbose_level = level;
        debug_log_msg(LGG_NOTICE, "Debug verbose level set to %d", level);
    }
}

logger_level debug_get_verbose_level(void) {
    return current_verbose_level;
}

/* =========================================================================
 * UTILITY FUNCTIONS
 * ========================================================================= */

void debug_time_check(const char *description) {
    static struct timespec last_time = {0, 0};
    struct timespec now;
    get_current_time(&now);
    
    if (last_time.tv_sec != 0) {
        double elapsed = time_diff_ms(last_time, now);
        debug_log_msg(LGG_DEBUG, "TIME_CHECK [%s]: %.2f ms", description, elapsed);
    }
    
    last_time = now;
}

void debug_hex_dump(void *data, int size) {
    if (!should_log(LGG_DEBUG) || !data || size <= 0) {
        return;
    }
    
    unsigned char *p = (unsigned char*)data;
    char hex_str[16*3 + 5] = {0};
    char char_str[16*1 + 5] = {0};
    
    debug_log_msg(LGG_DEBUG, "=== HEX DUMP (%d bytes) ===", size);
    
    for (int n = 0; n < size; n++) {
        if (n % 16 == 0 && n > 0) {
            debug_log_msg(LGG_DEBUG, "[%04x]   %-48s  %s", n - 16, hex_str, char_str);
            hex_str[0] = '\0';
            char_str[0] = '\0';
        }
        
        /* Hex Teil */
        char byte_str[4];
        snprintf(byte_str, sizeof(byte_str), "%02X ", p[n]);
        strncat(hex_str, byte_str, sizeof(hex_str) - strlen(hex_str) - 1);
        
        /* Char Teil */
        char char_byte[2];
        char_byte[0] = isprint(p[n]) ? p[n] : '.';
        char_byte[1] = '\0';
        strncat(char_str, char_byte, sizeof(char_str) - strlen(char_str) - 1);
        
        /* Spacing bei 8 Bytes */
        if ((n + 1) % 8 == 0) {
            strncat(hex_str, " ", sizeof(hex_str) - strlen(hex_str) - 1);
            strncat(char_str, " ", sizeof(char_str) - strlen(char_str) - 1);
        }
    }
    
    /* Letzte Zeile */
    if (strlen(hex_str) > 0) {
        int remaining = size % 16;
        debug_log_msg(LGG_DEBUG, "[%04x]   %-48s  %s", 
                     size - remaining, hex_str, char_str);
    }
    
    debug_log_msg(LGG_DEBUG, "=== END HEX DUMP ===");
}

/* =========================================================================
 * SYSTEM INITIALIZATION
 * ========================================================================= */

void debug_system_init(void) {
    get_current_time(&debug_start_time);
    current_verbose_level = LGG_ERR; /* Default Level */
    
    /* Syslog initialisieren */
    openlog("pixelserv-tls-debug", LOG_PID | LOG_PERROR, LOG_DAEMON);
    
    debug_log_msg(LGG_NOTICE, "Debug system initialized");
}

void debug_system_cleanup(void) {
    debug_log_msg(LGG_NOTICE, "Debug system cleanup");
    closelog();
}

#endif /* DEBUG */
